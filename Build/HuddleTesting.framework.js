
var unityFramework = (() => {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(unityFramework) {
  unityFramework = unityFramework || {};

var Module=typeof unityFramework!="undefined"?unityFramework:{};var readyPromiseResolve,readyPromiseReject;Module["ready"]=new Promise(function(resolve,reject){readyPromiseResolve=resolve;readyPromiseReject=reject});function CreateMediaElementSource(audioContext,audioElement)
{
    const track = new MediaElementAudioSourceNode(audioCtx, {
        mediaElement: audioElement,
      });
    return track;
};
"use strict";
var HuddleWebCore = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

  // ../../node_modules/debug/node_modules/ms/index.js
  var require_ms = __commonJS({
    "../../node_modules/debug/node_modules/ms/index.js"(exports, module) {
      "use strict";
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
          str
        );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // ../../node_modules/debug/src/common.js
  var require_common = __commonJS({
    "../../node_modules/debug/src/common.js"(exports, module) {
      "use strict";
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(/* @__PURE__ */ new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    }
  });

  // ../../node_modules/debug/src/browser.js
  var require_browser = __commonJS({
    "../../node_modules/debug/src/browser.js"(exports, module) {
      "use strict";
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
        typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
        // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
        typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module.exports = require_common()(exports);
      var { formatters } = module.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // ../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js
  var require_ua_parser = __commonJS({
    "../../node_modules/mediasoup-client/node_modules/ua-parser-js/src/ua-parser.js"(exports, module) {
      "use strict";
      (function(window2, undefined2) {
        "use strict";
        var LIBVERSION = "1.0.37", EMPTY = "", UNKNOWN = "?", FUNC_TYPE = "function", UNDEF_TYPE = "undefined", OBJ_TYPE = "object", STR_TYPE = "string", MAJOR = "major", MODEL = "model", NAME = "name", TYPE = "type", VENDOR = "vendor", VERSION = "version", ARCHITECTURE = "architecture", CONSOLE = "console", MOBILE = "mobile", TABLET = "tablet", SMARTTV = "smarttv", WEARABLE = "wearable", EMBEDDED = "embedded", UA_MAX_LENGTH = 500;
        var AMAZON = "Amazon", APPLE = "Apple", ASUS = "ASUS", BLACKBERRY = "BlackBerry", BROWSER = "Browser", CHROME = "Chrome", EDGE = "Edge", FIREFOX = "Firefox", GOOGLE = "Google", HUAWEI = "Huawei", LG = "LG", MICROSOFT = "Microsoft", MOTOROLA = "Motorola", OPERA = "Opera", SAMSUNG = "Samsung", SHARP = "Sharp", SONY = "Sony", XIAOMI = "Xiaomi", ZEBRA = "Zebra", FACEBOOK = "Facebook", CHROMIUM_OS = "Chromium OS", MAC_OS = "Mac OS";
        var extend = function(regexes2, extensions) {
          var mergedRegexes = {};
          for (var i in regexes2) {
            if (extensions[i] && extensions[i].length % 2 === 0) {
              mergedRegexes[i] = extensions[i].concat(regexes2[i]);
            } else {
              mergedRegexes[i] = regexes2[i];
            }
          }
          return mergedRegexes;
        }, enumerize = function(arr) {
          var enums = {};
          for (var i = 0; i < arr.length; i++) {
            enums[arr[i].toUpperCase()] = arr[i];
          }
          return enums;
        }, has = function(str1, str2) {
          return typeof str1 === STR_TYPE ? lowerize(str2).indexOf(lowerize(str1)) !== -1 : false;
        }, lowerize = function(str) {
          return str.toLowerCase();
        }, majorize = function(version) {
          return typeof version === STR_TYPE ? version.replace(/[^\d\.]/g, EMPTY).split(".")[0] : undefined2;
        }, trim = function(str, len) {
          if (typeof str === STR_TYPE) {
            str = str.replace(/^\s\s*/, EMPTY);
            return typeof len === UNDEF_TYPE ? str : str.substring(0, UA_MAX_LENGTH);
          }
        };
        var rgxMapper = function(ua, arrays) {
          var i = 0, j, k, p, q, matches, match;
          while (i < arrays.length && !matches) {
            var regex = arrays[i], props = arrays[i + 1];
            j = k = 0;
            while (j < regex.length && !matches) {
              if (!regex[j]) {
                break;
              }
              matches = regex[j++].exec(ua);
              if (!!matches) {
                for (p = 0; p < props.length; p++) {
                  match = matches[++k];
                  q = props[p];
                  if (typeof q === OBJ_TYPE && q.length > 0) {
                    if (q.length === 2) {
                      if (typeof q[1] == FUNC_TYPE) {
                        this[q[0]] = q[1].call(this, match);
                      } else {
                        this[q[0]] = q[1];
                      }
                    } else if (q.length === 3) {
                      if (typeof q[1] === FUNC_TYPE && !(q[1].exec && q[1].test)) {
                        this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined2;
                      } else {
                        this[q[0]] = match ? match.replace(q[1], q[2]) : undefined2;
                      }
                    } else if (q.length === 4) {
                      this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined2;
                    }
                  } else {
                    this[q] = match ? match : undefined2;
                  }
                }
              }
            }
            i += 2;
          }
        }, strMapper = function(str, map) {
          for (var i in map) {
            if (typeof map[i] === OBJ_TYPE && map[i].length > 0) {
              for (var j = 0; j < map[i].length; j++) {
                if (has(map[i][j], str)) {
                  return i === UNKNOWN ? undefined2 : i;
                }
              }
            } else if (has(map[i], str)) {
              return i === UNKNOWN ? undefined2 : i;
            }
          }
          return str;
        };
        var oldSafariMap = {
          "1.0": "/8",
          "1.2": "/1",
          "1.3": "/3",
          "2.0": "/412",
          "2.0.2": "/416",
          "2.0.3": "/417",
          "2.0.4": "/419",
          "?": "/"
        }, windowsVersionMap = {
          "ME": "4.90",
          "NT 3.11": "NT3.51",
          "NT 4.0": "NT4.0",
          "2000": "NT 5.0",
          "XP": ["NT 5.1", "NT 5.2"],
          "Vista": "NT 6.0",
          "7": "NT 6.1",
          "8": "NT 6.2",
          "8.1": "NT 6.3",
          "10": ["NT 6.4", "NT 10.0"],
          "RT": "ARM"
        };
        var regexes = {
          browser: [
            [
              /\b(?:crmo|crios)\/([\w\.]+)/i
              // Chrome for Android/iOS
            ],
            [VERSION, [NAME, "Chrome"]],
            [
              /edg(?:e|ios|a)?\/([\w\.]+)/i
              // Microsoft Edge
            ],
            [VERSION, [NAME, "Edge"]],
            [
              // Presto based
              /(opera mini)\/([-\w\.]+)/i,
              // Opera Mini
              /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i,
              // Opera Mobi/Tablet
              /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i
              // Opera
            ],
            [NAME, VERSION],
            [
              /opios[\/ ]+([\w\.]+)/i
              // Opera mini on iphone >= 8.0
            ],
            [VERSION, [NAME, OPERA + " Mini"]],
            [
              /\bopr\/([\w\.]+)/i
              // Opera Webkit
            ],
            [VERSION, [NAME, OPERA]],
            [
              // Mixed
              /\bb[ai]*d(?:uhd|[ub]*[aekoprswx]{5,6})[\/ ]?([\w\.]+)/i
              // Baidu
            ],
            [VERSION, [NAME, "Baidu"]],
            [
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i,
              // Lunascape/Maxthon/Netfront/Jasmine/Blazer
              // Trident based
              /(avant|iemobile|slim)\s?(?:browser)?[\/ ]?([\w\.]*)/i,
              // Avant/IEMobile/SlimBrowser
              /(?:ms|\()(ie) ([\w\.]+)/i,
              // Internet Explorer
              // Webkit/KHTML based                                               // Flock/RockMelt/Midori/Epiphany/Silk/Skyfire/Bolt/Iron/Iridium/PhantomJS/Bowser/QupZilla/Falkon
              /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i,
              // Rekonq/Puffin/Brave/Whale/QQBrowserLite/QQ, aka ShouQ
              /(heytap|ovi)browser\/([\d\.]+)/i,
              // Heytap/Ovi
              /(weibo)__([\d\.]+)/i
              // Weibo
            ],
            [NAME, VERSION],
            [
              /(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i
              // UCBrowser
            ],
            [VERSION, [NAME, "UC" + BROWSER]],
            [
              /microm.+\bqbcore\/([\w\.]+)/i,
              // WeChat Desktop for Windows Built-in Browser
              /\bqbcore\/([\w\.]+).+microm/i,
              /micromessenger\/([\w\.]+)/i
              // WeChat
            ],
            [VERSION, [NAME, "WeChat"]],
            [
              /konqueror\/([\w\.]+)/i
              // Konqueror
            ],
            [VERSION, [NAME, "Konqueror"]],
            [
              /trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i
              // IE11
            ],
            [VERSION, [NAME, "IE"]],
            [
              /ya(?:search)?browser\/([\w\.]+)/i
              // Yandex
            ],
            [VERSION, [NAME, "Yandex"]],
            [
              /slbrowser\/([\w\.]+)/i
              // Smart Lenovo Browser
            ],
            [VERSION, [NAME, "Smart Lenovo " + BROWSER]],
            [
              /(avast|avg)\/([\w\.]+)/i
              // Avast/AVG Secure Browser
            ],
            [[NAME, /(.+)/, "$1 Secure " + BROWSER], VERSION],
            [
              /\bfocus\/([\w\.]+)/i
              // Firefox Focus
            ],
            [VERSION, [NAME, FIREFOX + " Focus"]],
            [
              /\bopt\/([\w\.]+)/i
              // Opera Touch
            ],
            [VERSION, [NAME, OPERA + " Touch"]],
            [
              /coc_coc\w+\/([\w\.]+)/i
              // Coc Coc Browser
            ],
            [VERSION, [NAME, "Coc Coc"]],
            [
              /dolfin\/([\w\.]+)/i
              // Dolphin
            ],
            [VERSION, [NAME, "Dolphin"]],
            [
              /coast\/([\w\.]+)/i
              // Opera Coast
            ],
            [VERSION, [NAME, OPERA + " Coast"]],
            [
              /miuibrowser\/([\w\.]+)/i
              // MIUI Browser
            ],
            [VERSION, [NAME, "MIUI " + BROWSER]],
            [
              /fxios\/([-\w\.]+)/i
              // Firefox for iOS
            ],
            [VERSION, [NAME, FIREFOX]],
            [
              /\bqihu|(qi?ho?o?|360)browser/i
              // 360
            ],
            [[NAME, "360 " + BROWSER]],
            [
              /(oculus|sailfish|huawei|vivo)browser\/([\w\.]+)/i
            ],
            [[NAME, /(.+)/, "$1 " + BROWSER], VERSION],
            [
              // Oculus/Sailfish/HuaweiBrowser/VivoBrowser
              /samsungbrowser\/([\w\.]+)/i
              // Samsung Internet
            ],
            [VERSION, [NAME, SAMSUNG + " Internet"]],
            [
              /(comodo_dragon)\/([\w\.]+)/i
              // Comodo Dragon
            ],
            [[NAME, /_/g, " "], VERSION],
            [
              /metasr[\/ ]?([\d\.]+)/i
              // Sogou Explorer
            ],
            [VERSION, [NAME, "Sogou Explorer"]],
            [
              /(sogou)mo\w+\/([\d\.]+)/i
              // Sogou Mobile
            ],
            [[NAME, "Sogou Mobile"], VERSION],
            [
              /(electron)\/([\w\.]+) safari/i,
              // Electron-based App
              /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i,
              // Tesla
              /m?(qqbrowser|2345Explorer)[\/ ]?([\w\.]+)/i
              // QQBrowser/2345 Browser
            ],
            [NAME, VERSION],
            [
              /(lbbrowser)/i,
              // LieBao Browser
              /\[(linkedin)app\]/i
              // LinkedIn App for iOS & Android
            ],
            [NAME],
            [
              // WebView
              /((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i
              // Facebook App for iOS & Android
            ],
            [[NAME, FACEBOOK], VERSION],
            [
              /(Klarna)\/([\w\.]+)/i,
              // Klarna Shopping Browser for iOS & Android
              /(kakao(?:talk|story))[\/ ]([\w\.]+)/i,
              // Kakao App
              /(naver)\(.*?(\d+\.[\w\.]+).*\)/i,
              // Naver InApp
              /safari (line)\/([\w\.]+)/i,
              // Line App for iOS
              /\b(line)\/([\w\.]+)\/iab/i,
              // Line App for Android
              /(alipay)client\/([\w\.]+)/i,
              // Alipay
              /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i
              // Chromium/Instagram/Snapchat
            ],
            [NAME, VERSION],
            [
              /\bgsa\/([\w\.]+) .*safari\//i
              // Google Search Appliance on iOS
            ],
            [VERSION, [NAME, "GSA"]],
            [
              /musical_ly(?:.+app_?version\/|_)([\w\.]+)/i
              // TikTok
            ],
            [VERSION, [NAME, "TikTok"]],
            [
              /headlesschrome(?:\/([\w\.]+)| )/i
              // Chrome Headless
            ],
            [VERSION, [NAME, CHROME + " Headless"]],
            [
              / wv\).+(chrome)\/([\w\.]+)/i
              // Chrome WebView
            ],
            [[NAME, CHROME + " WebView"], VERSION],
            [
              /droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i
              // Android Browser
            ],
            [VERSION, [NAME, "Android " + BROWSER]],
            [
              /(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i
              // Chrome/OmniWeb/Arora/Tizen/Nokia
            ],
            [NAME, VERSION],
            [
              /version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i
              // Mobile Safari
            ],
            [VERSION, [NAME, "Mobile Safari"]],
            [
              /version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i
              // Safari & Safari Mobile
            ],
            [VERSION, NAME],
            [
              /webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i
              // Safari < 3.0
            ],
            [NAME, [VERSION, strMapper, oldSafariMap]],
            [
              /(webkit|khtml)\/([\w\.]+)/i
            ],
            [NAME, VERSION],
            [
              // Gecko based
              /(navigator|netscape\d?)\/([-\w\.]+)/i
              // Netscape
            ],
            [[NAME, "Netscape"], VERSION],
            [
              /mobile vr; rv:([\w\.]+)\).+firefox/i
              // Firefox Reality
            ],
            [VERSION, [NAME, FIREFOX + " Reality"]],
            [
              /ekiohf.+(flow)\/([\w\.]+)/i,
              // Flow
              /(swiftfox)/i,
              // Swiftfox
              /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i,
              // IceDragon/Iceweasel/Camino/Chimera/Fennec/Maemo/Minimo/Conkeror/Klar
              /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i,
              // Firefox/SeaMonkey/K-Meleon/IceCat/IceApe/Firebird/Phoenix
              /(firefox)\/([\w\.]+)/i,
              // Other Firefox-based
              /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i,
              // Mozilla
              // Other
              /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i,
              // Polaris/Lynx/Dillo/iCab/Doris/Amaya/w3m/NetSurf/Sleipnir/Obigo/Mosaic/Go/ICE/UP.Browser
              /(links) \(([\w\.]+)/i,
              // Links
              /panasonic;(viera)/i
              // Panasonic Viera
            ],
            [NAME, VERSION],
            [
              /(cobalt)\/([\w\.]+)/i
              // Cobalt
            ],
            [NAME, [VERSION, /master.|lts./, ""]]
          ],
          cpu: [
            [
              /(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i
              // AMD64 (x64)
            ],
            [[ARCHITECTURE, "amd64"]],
            [
              /(ia32(?=;))/i
              // IA32 (quicktime)
            ],
            [[ARCHITECTURE, lowerize]],
            [
              /((?:i[346]|x)86)[;\)]/i
              // IA32 (x86)
            ],
            [[ARCHITECTURE, "ia32"]],
            [
              /\b(aarch64|arm(v?8e?l?|_?64))\b/i
              // ARM64
            ],
            [[ARCHITECTURE, "arm64"]],
            [
              /\b(arm(?:v[67])?ht?n?[fl]p?)\b/i
              // ARMHF
            ],
            [[ARCHITECTURE, "armhf"]],
            [
              // PocketPC mistakenly identified as PowerPC
              /windows (ce|mobile); ppc;/i
            ],
            [[ARCHITECTURE, "arm"]],
            [
              /((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i
              // PowerPC
            ],
            [[ARCHITECTURE, /ower/, EMPTY, lowerize]],
            [
              /(sun4\w)[;\)]/i
              // SPARC
            ],
            [[ARCHITECTURE, "sparc"]],
            [
              /((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i
              // IA64, 68K, ARM/64, AVR/32, IRIX/64, MIPS/64, SPARC/64, PA-RISC
            ],
            [[ARCHITECTURE, lowerize]]
          ],
          device: [
            [
              //////////////////////////
              // MOBILES & TABLETS
              /////////////////////////
              // Samsung
              /\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, TABLET]],
            [
              /\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i,
              /samsung[- ]([-\w]+)/i,
              /sec-(sgh\w+)/i
            ],
            [MODEL, [VENDOR, SAMSUNG], [TYPE, MOBILE]],
            [
              // Apple
              /(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i
              // iPod/iPhone
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, MOBILE]],
            [
              /\((ipad);[-\w\),; ]+apple/i,
              // iPad
              /applecoremedia\/[\w\.]+ \((ipad)/i,
              /\b(ipad)\d\d?,\d\d?[;\]].+ios/i
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, TABLET]],
            [
              /(macintosh);/i
            ],
            [MODEL, [VENDOR, APPLE]],
            [
              // Sharp
              /\b(sh-?[altvz]?\d\d[a-ekm]?)/i
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, MOBILE]],
            [
              // Huawei
              /\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, TABLET]],
            [
              /(?:huawei|honor)([-\w ]+)[;\)]/i,
              /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i
            ],
            [MODEL, [VENDOR, HUAWEI], [TYPE, MOBILE]],
            [
              // Xiaomi
              /\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i,
              // Xiaomi POCO
              /\b; (\w+) build\/hm\1/i,
              // Xiaomi Hongmi 'numeric' models
              /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i,
              // Xiaomi Hongmi
              /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i,
              // Xiaomi Redmi
              /oid[^\)]+; (m?[12][0-389][01]\w{3,6}[c-y])( bui|; wv|\))/i,
              // Xiaomi Redmi 'numeric' models
              /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i
              // Xiaomi Mi
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, MOBILE]],
            [
              /oid[^\)]+; (2\d{4}(283|rpbf)[cgl])( bui|\))/i,
              // Redmi Pad
              /\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i
              // Mi Pad tablets
            ],
            [[MODEL, /_/g, " "], [VENDOR, XIAOMI], [TYPE, TABLET]],
            [
              // OPPO
              /; (\w+) bui.+ oppo/i,
              /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i
            ],
            [MODEL, [VENDOR, "OPPO"], [TYPE, MOBILE]],
            [
              // Vivo
              /vivo (\w+)(?: bui|\))/i,
              /\b(v[12]\d{3}\w?[at])(?: bui|;)/i
            ],
            [MODEL, [VENDOR, "Vivo"], [TYPE, MOBILE]],
            [
              // Realme
              /\b(rmx[1-3]\d{3})(?: bui|;|\))/i
            ],
            [MODEL, [VENDOR, "Realme"], [TYPE, MOBILE]],
            [
              // Motorola
              /\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i,
              /\bmot(?:orola)?[- ](\w*)/i,
              /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, MOBILE]],
            [
              /\b(mz60\d|xoom[2 ]{0,2}) build\//i
            ],
            [MODEL, [VENDOR, MOTOROLA], [TYPE, TABLET]],
            [
              // LG
              /((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, TABLET]],
            [
              /(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i,
              /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i,
              /\blg-?([\d\w]+) bui/i
            ],
            [MODEL, [VENDOR, LG], [TYPE, MOBILE]],
            [
              // Lenovo
              /(ideatab[-\w ]+)/i,
              /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i
            ],
            [MODEL, [VENDOR, "Lenovo"], [TYPE, TABLET]],
            [
              // Nokia
              /(?:maemo|nokia).*(n900|lumia \d+)/i,
              /nokia[-_ ]?([-\w\.]*)/i
            ],
            [[MODEL, /_/g, " "], [VENDOR, "Nokia"], [TYPE, MOBILE]],
            [
              // Google
              /(pixel c)\b/i
              // Google Pixel C
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, TABLET]],
            [
              /droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i
              // Google Pixel
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, MOBILE]],
            [
              // Sony
              /droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i
            ],
            [MODEL, [VENDOR, SONY], [TYPE, MOBILE]],
            [
              /sony tablet [ps]/i,
              /\b(?:sony)?sgp\w+(?: bui|\))/i
            ],
            [[MODEL, "Xperia Tablet"], [VENDOR, SONY], [TYPE, TABLET]],
            [
              // OnePlus
              / (kb2005|in20[12]5|be20[12][59])\b/i,
              /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i
            ],
            [MODEL, [VENDOR, "OnePlus"], [TYPE, MOBILE]],
            [
              // Amazon
              /(alexa)webm/i,
              /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i,
              // Kindle Fire without Silk / Echo Show
              /(kf[a-z]+)( bui|\)).+silk\//i
              // Kindle Fire HD
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, TABLET]],
            [
              /((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i
              // Fire Phone
            ],
            [[MODEL, /(.+)/g, "Fire Phone $1"], [VENDOR, AMAZON], [TYPE, MOBILE]],
            [
              // BlackBerry
              /(playbook);[-\w\),; ]+(rim)/i
              // BlackBerry PlayBook
            ],
            [MODEL, VENDOR, [TYPE, TABLET]],
            [
              /\b((?:bb[a-f]|st[hv])100-\d)/i,
              /\(bb10; (\w+)/i
              // BlackBerry 10
            ],
            [MODEL, [VENDOR, BLACKBERRY], [TYPE, MOBILE]],
            [
              // Asus
              /(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, TABLET]],
            [
              / (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i
            ],
            [MODEL, [VENDOR, ASUS], [TYPE, MOBILE]],
            [
              // HTC
              /(nexus 9)/i
              // HTC Nexus 9
            ],
            [MODEL, [VENDOR, "HTC"], [TYPE, TABLET]],
            [
              /(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i,
              // HTC
              // ZTE
              /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i,
              /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i
              // Alcatel/GeeksPhone/Nexian/Panasonic/Sony
            ],
            [VENDOR, [MODEL, /_/g, " "], [TYPE, MOBILE]],
            [
              // Acer
              /droid.+; ([ab][1-7]-?[0178a]\d\d?)/i
            ],
            [MODEL, [VENDOR, "Acer"], [TYPE, TABLET]],
            [
              // Meizu
              /droid.+; (m[1-5] note) bui/i,
              /\bmz-([-\w]{2,})/i
            ],
            [MODEL, [VENDOR, "Meizu"], [TYPE, MOBILE]],
            [
              // Ulefone
              /; ((?:power )?armor(?:[\w ]{0,8}))(?: bui|\))/i
            ],
            [MODEL, [VENDOR, "Ulefone"], [TYPE, MOBILE]],
            [
              // MIXED
              /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i,
              // BlackBerry/BenQ/Palm/Sony-Ericsson/Acer/Asus/Dell/Meizu/Motorola/Polytron
              /(hp) ([\w ]+\w)/i,
              // HP iPAQ
              /(asus)-?(\w+)/i,
              // Asus
              /(microsoft); (lumia[\w ]+)/i,
              // Microsoft Lumia
              /(lenovo)[-_ ]?([-\w]+)/i,
              // Lenovo
              /(jolla)/i,
              // Jolla
              /(oppo) ?([\w ]+) bui/i
              // OPPO
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kobo)\s(ereader|touch)/i,
              // Kobo
              /(archos) (gamepad2?)/i,
              // Archos
              /(hp).+(touchpad(?!.+tablet)|tablet)/i,
              // HP TouchPad
              /(kindle)\/([\w\.]+)/i,
              // Kindle
              /(nook)[\w ]+build\/(\w+)/i,
              // Nook
              /(dell) (strea[kpr\d ]*[\dko])/i,
              // Dell Streak
              /(le[- ]+pan)[- ]+(\w{1,9}) bui/i,
              // Le Pan Tablets
              /(trinity)[- ]*(t\d{3}) bui/i,
              // Trinity Tablets
              /(gigaset)[- ]+(q\w{1,9}) bui/i,
              // Gigaset Tablets
              /(vodafone) ([\w ]+)(?:\)| bui)/i
              // Vodafone
            ],
            [VENDOR, MODEL, [TYPE, TABLET]],
            [
              /(surface duo)/i
              // Surface Duo
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, TABLET]],
            [
              /droid [\d\.]+; (fp\du?)(?: b|\))/i
              // Fairphone
            ],
            [MODEL, [VENDOR, "Fairphone"], [TYPE, MOBILE]],
            [
              /(u304aa)/i
              // AT&T
            ],
            [MODEL, [VENDOR, "AT&T"], [TYPE, MOBILE]],
            [
              /\bsie-(\w*)/i
              // Siemens
            ],
            [MODEL, [VENDOR, "Siemens"], [TYPE, MOBILE]],
            [
              /\b(rct\w+) b/i
              // RCA Tablets
            ],
            [MODEL, [VENDOR, "RCA"], [TYPE, TABLET]],
            [
              /\b(venue[\d ]{2,7}) b/i
              // Dell Venue Tablets
            ],
            [MODEL, [VENDOR, "Dell"], [TYPE, TABLET]],
            [
              /\b(q(?:mv|ta)\w+) b/i
              // Verizon Tablet
            ],
            [MODEL, [VENDOR, "Verizon"], [TYPE, TABLET]],
            [
              /\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i
              // Barnes & Noble Tablet
            ],
            [MODEL, [VENDOR, "Barnes & Noble"], [TYPE, TABLET]],
            [
              /\b(tm\d{3}\w+) b/i
            ],
            [MODEL, [VENDOR, "NuVision"], [TYPE, TABLET]],
            [
              /\b(k88) b/i
              // ZTE K Series Tablet
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, TABLET]],
            [
              /\b(nx\d{3}j) b/i
              // ZTE Nubia
            ],
            [MODEL, [VENDOR, "ZTE"], [TYPE, MOBILE]],
            [
              /\b(gen\d{3}) b.+49h/i
              // Swiss GEN Mobile
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, MOBILE]],
            [
              /\b(zur\d{3}) b/i
              // Swiss ZUR Tablet
            ],
            [MODEL, [VENDOR, "Swiss"], [TYPE, TABLET]],
            [
              /\b((zeki)?tb.*\b) b/i
              // Zeki Tablets
            ],
            [MODEL, [VENDOR, "Zeki"], [TYPE, TABLET]],
            [
              /\b([yr]\d{2}) b/i,
              /\b(dragon[- ]+touch |dt)(\w{5}) b/i
              // Dragon Touch Tablet
            ],
            [[VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]],
            [
              /\b(ns-?\w{0,9}) b/i
              // Insignia Tablets
            ],
            [MODEL, [VENDOR, "Insignia"], [TYPE, TABLET]],
            [
              /\b((nxa|next)-?\w{0,9}) b/i
              // NextBook Tablets
            ],
            [MODEL, [VENDOR, "NextBook"], [TYPE, TABLET]],
            [
              /\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i
              // Voice Xtreme Phones
            ],
            [[VENDOR, "Voice"], MODEL, [TYPE, MOBILE]],
            [
              /\b(lvtel\-)?(v1[12]) b/i
              // LvTel Phones
            ],
            [[VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]],
            [
              /\b(ph-1) /i
              // Essential PH-1
            ],
            [MODEL, [VENDOR, "Essential"], [TYPE, MOBILE]],
            [
              /\b(v(100md|700na|7011|917g).*\b) b/i
              // Envizen Tablets
            ],
            [MODEL, [VENDOR, "Envizen"], [TYPE, TABLET]],
            [
              /\b(trio[-\w\. ]+) b/i
              // MachSpeed Tablets
            ],
            [MODEL, [VENDOR, "MachSpeed"], [TYPE, TABLET]],
            [
              /\btu_(1491) b/i
              // Rotor Tablets
            ],
            [MODEL, [VENDOR, "Rotor"], [TYPE, TABLET]],
            [
              /(shield[\w ]+) b/i
              // Nvidia Shield Tablets
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, TABLET]],
            [
              /(sprint) (\w+)/i
              // Sprint Phones
            ],
            [VENDOR, MODEL, [TYPE, MOBILE]],
            [
              /(kin\.[onetw]{3})/i
              // Microsoft Kin
            ],
            [[MODEL, /\./g, " "], [VENDOR, MICROSOFT], [TYPE, MOBILE]],
            [
              /droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i
              // Zebra
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, TABLET]],
            [
              /droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, MOBILE]],
            [
              ///////////////////
              // SMARTTVS
              ///////////////////
              /smart-tv.+(samsung)/i
              // Samsung
            ],
            [VENDOR, [TYPE, SMARTTV]],
            [
              /hbbtv.+maple;(\d+)/i
            ],
            [[MODEL, /^/, "SmartTV"], [VENDOR, SAMSUNG], [TYPE, SMARTTV]],
            [
              /(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i
              // LG SmartTV
            ],
            [[VENDOR, LG], [TYPE, SMARTTV]],
            [
              /(apple) ?tv/i
              // Apple TV
            ],
            [VENDOR, [MODEL, APPLE + " TV"], [TYPE, SMARTTV]],
            [
              /crkey/i
              // Google Chromecast
            ],
            [[MODEL, CHROME + "cast"], [VENDOR, GOOGLE], [TYPE, SMARTTV]],
            [
              /droid.+aft(\w+)( bui|\))/i
              // Fire TV
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, SMARTTV]],
            [
              /\(dtv[\);].+(aquos)/i,
              /(aquos-tv[\w ]+)\)/i
              // Sharp
            ],
            [MODEL, [VENDOR, SHARP], [TYPE, SMARTTV]],
            [
              /(bravia[\w ]+)( bui|\))/i
              // Sony
            ],
            [MODEL, [VENDOR, SONY], [TYPE, SMARTTV]],
            [
              /(mitv-\w{5}) bui/i
              // Xiaomi
            ],
            [MODEL, [VENDOR, XIAOMI], [TYPE, SMARTTV]],
            [
              /Hbbtv.*(technisat) (.*);/i
              // TechniSAT
            ],
            [VENDOR, MODEL, [TYPE, SMARTTV]],
            [
              /\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i,
              // Roku
              /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i
              // HbbTV devices
            ],
            [[VENDOR, trim], [MODEL, trim], [TYPE, SMARTTV]],
            [
              /\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i
              // SmartTV from Unidentified Vendors
            ],
            [[TYPE, SMARTTV]],
            [
              ///////////////////
              // CONSOLES
              ///////////////////
              /(ouya)/i,
              // Ouya
              /(nintendo) ([wids3utch]+)/i
              // Nintendo
            ],
            [VENDOR, MODEL, [TYPE, CONSOLE]],
            [
              /droid.+; (shield) bui/i
              // Nvidia
            ],
            [MODEL, [VENDOR, "Nvidia"], [TYPE, CONSOLE]],
            [
              /(playstation [345portablevi]+)/i
              // Playstation
            ],
            [MODEL, [VENDOR, SONY], [TYPE, CONSOLE]],
            [
              /\b(xbox(?: one)?(?!; xbox))[\); ]/i
              // Microsoft Xbox
            ],
            [MODEL, [VENDOR, MICROSOFT], [TYPE, CONSOLE]],
            [
              ///////////////////
              // WEARABLES
              ///////////////////
              /((pebble))app/i
              // Pebble
            ],
            [VENDOR, MODEL, [TYPE, WEARABLE]],
            [
              /(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i
              // Apple Watch
            ],
            [MODEL, [VENDOR, APPLE], [TYPE, WEARABLE]],
            [
              /droid.+; (glass) \d/i
              // Google Glass
            ],
            [MODEL, [VENDOR, GOOGLE], [TYPE, WEARABLE]],
            [
              /droid.+; (wt63?0{2,3})\)/i
            ],
            [MODEL, [VENDOR, ZEBRA], [TYPE, WEARABLE]],
            [
              /(quest( 2| pro)?)/i
              // Oculus Quest
            ],
            [MODEL, [VENDOR, FACEBOOK], [TYPE, WEARABLE]],
            [
              ///////////////////
              // EMBEDDED
              ///////////////////
              /(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i
              // Tesla
            ],
            [VENDOR, [TYPE, EMBEDDED]],
            [
              /(aeobc)\b/i
              // Echo Dot
            ],
            [MODEL, [VENDOR, AMAZON], [TYPE, EMBEDDED]],
            [
              ////////////////////
              // MIXED (GENERIC)
              ///////////////////
              /droid .+?; ([^;]+?)(?: bui|; wv\)|\) applew).+? mobile safari/i
              // Android Phones from Unidentified Vendors
            ],
            [MODEL, [TYPE, MOBILE]],
            [
              /droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i
              // Android Tablets from Unidentified Vendors
            ],
            [MODEL, [TYPE, TABLET]],
            [
              /\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i
              // Unidentifiable Tablet
            ],
            [[TYPE, TABLET]],
            [
              /(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i
              // Unidentifiable Mobile
            ],
            [[TYPE, MOBILE]],
            [
              /(android[-\w\. ]{0,9});.+buil/i
              // Generic Android Device
            ],
            [MODEL, [VENDOR, "Generic"]]
          ],
          engine: [
            [
              /windows.+ edge\/([\w\.]+)/i
              // EdgeHTML
            ],
            [VERSION, [NAME, EDGE + "HTML"]],
            [
              /webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i
              // Blink
            ],
            [VERSION, [NAME, "Blink"]],
            [
              /(presto)\/([\w\.]+)/i,
              // Presto
              /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i,
              // WebKit/Trident/NetFront/NetSurf/Amaya/Lynx/w3m/Goanna
              /ekioh(flow)\/([\w\.]+)/i,
              // Flow
              /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i,
              // KHTML/Tasman/Links
              /(icab)[\/ ]([23]\.[\d\.]+)/i,
              // iCab
              /\b(libweb)/i
            ],
            [NAME, VERSION],
            [
              /rv\:([\w\.]{1,9})\b.+(gecko)/i
              // Gecko
            ],
            [VERSION, NAME]
          ],
          os: [
            [
              // Windows
              /microsoft (windows) (vista|xp)/i
              // Windows (iTunes)
            ],
            [NAME, VERSION],
            [
              /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i
              // Windows Phone
            ],
            [NAME, [VERSION, strMapper, windowsVersionMap]],
            [
              /windows nt 6\.2; (arm)/i,
              // Windows RT
              /windows[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i,
              /(?:win(?=3|9|n)|win 9x )([nt\d\.]+)/i
            ],
            [[VERSION, strMapper, windowsVersionMap], [NAME, "Windows"]],
            [
              // iOS/macOS
              /ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i,
              // iOS
              /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i,
              /cfnetwork\/.+darwin/i
            ],
            [[VERSION, /_/g, "."], [NAME, "iOS"]],
            [
              /(mac os x) ?([\w\. ]*)/i,
              /(macintosh|mac_powerpc\b)(?!.+haiku)/i
              // Mac OS
            ],
            [[NAME, MAC_OS], [VERSION, /_/g, "."]],
            [
              // Mobile OSes
              /droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i
              // Android-x86/HarmonyOS
            ],
            [VERSION, NAME],
            [
              // Android/WebOS/QNX/Bada/RIM/Maemo/MeeGo/Sailfish OS
              /(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i,
              /(blackberry)\w*\/([\w\.]*)/i,
              // Blackberry
              /(tizen|kaios)[\/ ]([\w\.]+)/i,
              // Tizen/KaiOS
              /\((series40);/i
              // Series 40
            ],
            [NAME, VERSION],
            [
              /\(bb(10);/i
              // BlackBerry 10
            ],
            [VERSION, [NAME, BLACKBERRY]],
            [
              /(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i
              // Symbian
            ],
            [VERSION, [NAME, "Symbian"]],
            [
              /mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i
              // Firefox OS
            ],
            [VERSION, [NAME, FIREFOX + " OS"]],
            [
              /web0s;.+rt(tv)/i,
              /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i
              // WebOS
            ],
            [VERSION, [NAME, "webOS"]],
            [
              /watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i
              // watchOS
            ],
            [VERSION, [NAME, "watchOS"]],
            [
              // Google Chromecast
              /crkey\/([\d\.]+)/i
              // Google Chromecast
            ],
            [VERSION, [NAME, CHROME + "cast"]],
            [
              /(cros) [\w]+(?:\)| ([\w\.]+)\b)/i
              // Chromium OS
            ],
            [[NAME, CHROMIUM_OS], VERSION],
            [
              // Smart TVs
              /panasonic;(viera)/i,
              // Panasonic Viera
              /(netrange)mmh/i,
              // Netrange
              /(nettv)\/(\d+\.[\w\.]+)/i,
              // NetTV
              // Console
              /(nintendo|playstation) ([wids345portablevuch]+)/i,
              // Nintendo/Playstation
              /(xbox); +xbox ([^\);]+)/i,
              // Microsoft Xbox (360, One, X, S, Series X, Series S)
              // Other
              /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i,
              // Joli/Palm
              /(mint)[\/\(\) ]?(\w*)/i,
              // Mint
              /(mageia|vectorlinux)[; ]/i,
              // Mageia/VectorLinux
              /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i,
              // Ubuntu/Debian/SUSE/Gentoo/Arch/Slackware/Fedora/Mandriva/CentOS/PCLinuxOS/RedHat/Zenwalk/Linpus/Raspbian/Plan9/Minix/RISCOS/Contiki/Deepin/Manjaro/elementary/Sabayon/Linspire
              /(hurd|linux) ?([\w\.]*)/i,
              // Hurd/Linux
              /(gnu) ?([\w\.]*)/i,
              // GNU
              /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i,
              // FreeBSD/NetBSD/OpenBSD/PC-BSD/GhostBSD/DragonFly
              /(haiku) (\w+)/i
              // Haiku
            ],
            [NAME, VERSION],
            [
              /(sunos) ?([\w\.\d]*)/i
              // Solaris
            ],
            [[NAME, "Solaris"], VERSION],
            [
              /((?:open)?solaris)[-\/ ]?([\w\.]*)/i,
              // Solaris
              /(aix) ((\d)(?=\.|\)| )[\w\.])*/i,
              // AIX
              /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i,
              // BeOS/OS2/AmigaOS/MorphOS/OpenVMS/Fuchsia/HP-UX/SerenityOS
              /(unix) ?([\w\.]*)/i
              // UNIX
            ],
            [NAME, VERSION]
          ]
        };
        var UAParser = function(ua, extensions) {
          if (typeof ua === OBJ_TYPE) {
            extensions = ua;
            ua = undefined2;
          }
          if (!(this instanceof UAParser)) {
            return new UAParser(ua, extensions).getResult();
          }
          var _navigator = typeof window2 !== UNDEF_TYPE && window2.navigator ? window2.navigator : undefined2;
          var _ua = ua || (_navigator && _navigator.userAgent ? _navigator.userAgent : EMPTY);
          var _uach = _navigator && _navigator.userAgentData ? _navigator.userAgentData : undefined2;
          var _rgxmap = extensions ? extend(regexes, extensions) : regexes;
          var _isSelfNav = _navigator && _navigator.userAgent == _ua;
          this.getBrowser = function() {
            var _browser = {};
            _browser[NAME] = undefined2;
            _browser[VERSION] = undefined2;
            rgxMapper.call(_browser, _ua, _rgxmap.browser);
            _browser[MAJOR] = majorize(_browser[VERSION]);
            if (_isSelfNav && _navigator && _navigator.brave && typeof _navigator.brave.isBrave == FUNC_TYPE) {
              _browser[NAME] = "Brave";
            }
            return _browser;
          };
          this.getCPU = function() {
            var _cpu = {};
            _cpu[ARCHITECTURE] = undefined2;
            rgxMapper.call(_cpu, _ua, _rgxmap.cpu);
            return _cpu;
          };
          this.getDevice = function() {
            var _device = {};
            _device[VENDOR] = undefined2;
            _device[MODEL] = undefined2;
            _device[TYPE] = undefined2;
            rgxMapper.call(_device, _ua, _rgxmap.device);
            if (_isSelfNav && !_device[TYPE] && _uach && _uach.mobile) {
              _device[TYPE] = MOBILE;
            }
            if (_isSelfNav && _device[MODEL] == "Macintosh" && _navigator && typeof _navigator.standalone !== UNDEF_TYPE && _navigator.maxTouchPoints && _navigator.maxTouchPoints > 2) {
              _device[MODEL] = "iPad";
              _device[TYPE] = TABLET;
            }
            return _device;
          };
          this.getEngine = function() {
            var _engine = {};
            _engine[NAME] = undefined2;
            _engine[VERSION] = undefined2;
            rgxMapper.call(_engine, _ua, _rgxmap.engine);
            return _engine;
          };
          this.getOS = function() {
            var _os = {};
            _os[NAME] = undefined2;
            _os[VERSION] = undefined2;
            rgxMapper.call(_os, _ua, _rgxmap.os);
            if (_isSelfNav && !_os[NAME] && _uach && _uach.platform != "Unknown") {
              _os[NAME] = _uach.platform.replace(/chrome os/i, CHROMIUM_OS).replace(/macos/i, MAC_OS);
            }
            return _os;
          };
          this.getResult = function() {
            return {
              ua: this.getUA(),
              browser: this.getBrowser(),
              engine: this.getEngine(),
              os: this.getOS(),
              device: this.getDevice(),
              cpu: this.getCPU()
            };
          };
          this.getUA = function() {
            return _ua;
          };
          this.setUA = function(ua2) {
            _ua = typeof ua2 === STR_TYPE && ua2.length > UA_MAX_LENGTH ? trim(ua2, UA_MAX_LENGTH) : ua2;
            return this;
          };
          this.setUA(_ua);
          return this;
        };
        UAParser.VERSION = LIBVERSION;
        UAParser.BROWSER = enumerize([NAME, VERSION, MAJOR]);
        UAParser.CPU = enumerize([ARCHITECTURE]);
        UAParser.DEVICE = enumerize([MODEL, VENDOR, TYPE, CONSOLE, MOBILE, SMARTTV, TABLET, WEARABLE, EMBEDDED]);
        UAParser.ENGINE = UAParser.OS = enumerize([NAME, VERSION]);
        if (typeof exports !== UNDEF_TYPE) {
          if (typeof module !== UNDEF_TYPE && module.exports) {
            exports = module.exports = UAParser;
          }
          exports.UAParser = UAParser;
        } else {
          if (typeof define === FUNC_TYPE && define.amd) {
            define(function() {
              return UAParser;
            });
          } else if (typeof window2 !== UNDEF_TYPE) {
            window2.UAParser = UAParser;
          }
        }
        var $ = typeof window2 !== UNDEF_TYPE && (window2.jQuery || window2.Zepto);
        if ($ && !$.ua) {
          var parser = new UAParser();
          $.ua = parser.getResult();
          $.ua.get = function() {
            return parser.getUA();
          };
          $.ua.set = function(ua) {
            parser.setUA(ua);
            var result = parser.getResult();
            for (var prop in result) {
              $.ua[prop] = result[prop];
            }
          };
        }
      })(typeof window === "object" ? window : exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/Logger.js
  var require_Logger = __commonJS({
    "../../node_modules/mediasoup-client/lib/Logger.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser());
      var APP_NAME = "mediasoup-client";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/events/events.js
  var require_events = __commonJS({
    "../../node_modules/events/events.js"(exports, module) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter2() {
        EventEmitter2.init.call(this);
      }
      module.exports = EventEmitter2;
      module.exports.once = once;
      EventEmitter2.EventEmitter = EventEmitter2;
      EventEmitter2.prototype._events = void 0;
      EventEmitter2.prototype._eventsCount = 0;
      EventEmitter2.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter2, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter2.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter2.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter2.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter2.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter2.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = /* @__PURE__ */ Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit(
              "newListener",
              type,
              listener.listener ? listener.listener : listener
            );
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter2.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter2.prototype.on = EventEmitter2.prototype.addListener;
      EventEmitter2.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter2.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter2.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = /* @__PURE__ */ Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = /* @__PURE__ */ Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter2.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter2.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter2.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter2.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter2.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/EnhancedEventEmitter.js
  var require_EnhancedEventEmitter = __commonJS({
    "../../node_modules/mediasoup-client/lib/EnhancedEventEmitter.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EnhancedEventEmitter = void 0;
      var events_1 = require_events();
      var Logger_1 = require_Logger();
      var logger12 = new Logger_1.Logger("EnhancedEventEmitter");
      var EnhancedEventEmitter2 = class extends events_1.EventEmitter {
        constructor() {
          super();
          this.setMaxListeners(Infinity);
        }
        emit(eventName, ...args) {
          return super.emit(eventName, ...args);
        }
        /**
         * Special addition to the EventEmitter API.
         */
        safeEmit(eventName, ...args) {
          const numListeners = super.listenerCount(eventName);
          try {
            return super.emit(eventName, ...args);
          } catch (error) {
            logger12.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error);
            return Boolean(numListeners);
          }
        }
        on(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        off(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        addListener(eventName, listener) {
          super.on(eventName, listener);
          return this;
        }
        prependListener(eventName, listener) {
          super.prependListener(eventName, listener);
          return this;
        }
        once(eventName, listener) {
          super.once(eventName, listener);
          return this;
        }
        prependOnceListener(eventName, listener) {
          super.prependOnceListener(eventName, listener);
          return this;
        }
        removeListener(eventName, listener) {
          super.off(eventName, listener);
          return this;
        }
        removeAllListeners(eventName) {
          super.removeAllListeners(eventName);
          return this;
        }
        listenerCount(eventName) {
          return super.listenerCount(eventName);
        }
        listeners(eventName) {
          return super.listeners(eventName);
        }
        rawListeners(eventName) {
          return super.rawListeners(eventName);
        }
      };
      exports.EnhancedEventEmitter = EnhancedEventEmitter2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/errors.js
  var require_errors = __commonJS({
    "../../node_modules/mediasoup-client/lib/errors.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.InvalidStateError = exports.UnsupportedError = void 0;
      var UnsupportedError = class _UnsupportedError extends Error {
        constructor(message) {
          super(message);
          this.name = "UnsupportedError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _UnsupportedError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.UnsupportedError = UnsupportedError;
      var InvalidStateError = class _InvalidStateError extends Error {
        constructor(message) {
          super(message);
          this.name = "InvalidStateError";
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, _InvalidStateError);
          } else {
            this.stack = new Error(message).stack;
          }
        }
      };
      exports.InvalidStateError = InvalidStateError;
    }
  });

  // ../../node_modules/mediasoup-client/lib/utils.js
  var require_utils = __commonJS({
    "../../node_modules/mediasoup-client/lib/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateRandomNumber = exports.clone = void 0;
      function clone(value) {
        if (value === void 0) {
          return void 0;
        } else if (Number.isNaN(value)) {
          return NaN;
        } else if (typeof structuredClone === "function") {
          return structuredClone(value);
        } else {
          return JSON.parse(JSON.stringify(value));
        }
      }
      exports.clone = clone;
      function generateRandomNumber() {
        return Math.round(Math.random() * 1e7);
      }
      exports.generateRandomNumber = generateRandomNumber;
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/Logger.js
  var require_Logger2 = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/Logger.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = __importDefault(require_browser());
      var APP_NAME = "h264-profile-level-id";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(APP_NAME);
            this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/h264-profile-level-id/lib/index.js
  var require_lib = __commonJS({
    "../../node_modules/h264-profile-level-id/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.generateProfileLevelIdStringForAnswer = exports.isSameProfile = exports.parseSdpProfileLevelId = exports.levelToString = exports.profileToString = exports.profileLevelIdToString = exports.parseProfileLevelId = exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
      var Logger_1 = require_Logger2();
      var logger12 = new Logger_1.Logger();
      var Profile;
      (function(Profile2) {
        Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
        Profile2[Profile2["Baseline"] = 2] = "Baseline";
        Profile2[Profile2["Main"] = 3] = "Main";
        Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
        Profile2[Profile2["High"] = 5] = "High";
        Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
      })(Profile || (exports.Profile = Profile = {}));
      var Level;
      (function(Level2) {
        Level2[Level2["L1_b"] = 0] = "L1_b";
        Level2[Level2["L1"] = 10] = "L1";
        Level2[Level2["L1_1"] = 11] = "L1_1";
        Level2[Level2["L1_2"] = 12] = "L1_2";
        Level2[Level2["L1_3"] = 13] = "L1_3";
        Level2[Level2["L2"] = 20] = "L2";
        Level2[Level2["L2_1"] = 21] = "L2_1";
        Level2[Level2["L2_2"] = 22] = "L2_2";
        Level2[Level2["L3"] = 30] = "L3";
        Level2[Level2["L3_1"] = 31] = "L3_1";
        Level2[Level2["L3_2"] = 32] = "L3_2";
        Level2[Level2["L4"] = 40] = "L4";
        Level2[Level2["L4_1"] = 41] = "L4_1";
        Level2[Level2["L4_2"] = 42] = "L4_2";
        Level2[Level2["L5"] = 50] = "L5";
        Level2[Level2["L5_1"] = 51] = "L5_1";
        Level2[Level2["L5_2"] = 52] = "L5_2";
      })(Level || (exports.Level = Level = {}));
      var ProfileLevelId = class {
        constructor(profile, level) {
          this.profile = profile;
          this.level = level;
        }
      };
      exports.ProfileLevelId = ProfileLevelId;
      var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
      var BitPattern = class {
        constructor(str) {
          this.mask = ~byteMaskString("x", str);
          this.masked_value = byteMaskString("1", str);
        }
        isMatch(value) {
          return this.masked_value === (value & this.mask);
        }
      };
      var ProfilePattern = class {
        constructor(profile_idc, profile_iop, profile) {
          this.profile_idc = profile_idc;
          this.profile_iop = profile_iop;
          this.profile = profile;
        }
      };
      var ProfilePatterns = [
        new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
        new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
        new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
        new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
        new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
        new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
        new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
      ];
      function parseProfileLevelId(str) {
        const ConstraintSet3Flag = 16;
        if (typeof str !== "string" || str.length !== 6) {
          return void 0;
        }
        const profile_level_id_numeric = parseInt(str, 16);
        if (profile_level_id_numeric === 0) {
          return void 0;
        }
        const level_idc = profile_level_id_numeric & 255;
        const profile_iop = profile_level_id_numeric >> 8 & 255;
        const profile_idc = profile_level_id_numeric >> 16 & 255;
        let level;
        switch (level_idc) {
          case Level.L1_1: {
            level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
            break;
          }
          case Level.L1:
          case Level.L1_2:
          case Level.L1_3:
          case Level.L2:
          case Level.L2_1:
          case Level.L2_2:
          case Level.L3:
          case Level.L3_1:
          case Level.L3_2:
          case Level.L4:
          case Level.L4_1:
          case Level.L4_2:
          case Level.L5:
          case Level.L5_1:
          case Level.L5_2: {
            level = level_idc;
            break;
          }
          default: {
            logger12.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
            return void 0;
          }
        }
        for (const pattern of ProfilePatterns) {
          if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
            return new ProfileLevelId(pattern.profile, level);
          }
        }
        logger12.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
        return void 0;
      }
      exports.parseProfileLevelId = parseProfileLevelId;
      function profileLevelIdToString(profile_level_id) {
        if (profile_level_id.level == Level.L1_b) {
          switch (profile_level_id.profile) {
            case Profile.ConstrainedBaseline: {
              return "42f00b";
            }
            case Profile.Baseline: {
              return "42100b";
            }
            case Profile.Main: {
              return "4d100b";
            }
            default: {
              logger12.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
              return void 0;
            }
          }
        }
        let profile_idc_iop_string;
        switch (profile_level_id.profile) {
          case Profile.ConstrainedBaseline: {
            profile_idc_iop_string = "42e0";
            break;
          }
          case Profile.Baseline: {
            profile_idc_iop_string = "4200";
            break;
          }
          case Profile.Main: {
            profile_idc_iop_string = "4d00";
            break;
          }
          case Profile.ConstrainedHigh: {
            profile_idc_iop_string = "640c";
            break;
          }
          case Profile.High: {
            profile_idc_iop_string = "6400";
            break;
          }
          case Profile.PredictiveHigh444: {
            profile_idc_iop_string = "f400";
            break;
          }
          default: {
            logger12.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
            return void 0;
          }
        }
        let levelStr = profile_level_id.level.toString(16);
        if (levelStr.length === 1) {
          levelStr = `0${levelStr}`;
        }
        return `${profile_idc_iop_string}${levelStr}`;
      }
      exports.profileLevelIdToString = profileLevelIdToString;
      function profileToString(profile) {
        switch (profile) {
          case Profile.ConstrainedBaseline: {
            return "ConstrainedBaseline";
          }
          case Profile.Baseline: {
            return "Baseline";
          }
          case Profile.Main: {
            return "Main";
          }
          case Profile.ConstrainedHigh: {
            return "ConstrainedHigh";
          }
          case Profile.High: {
            return "High";
          }
          case Profile.PredictiveHigh444: {
            return "PredictiveHigh444";
          }
          default: {
            logger12.warn(`profileToString() | unrecognized profile ${profile}`);
            return void 0;
          }
        }
      }
      exports.profileToString = profileToString;
      function levelToString(level) {
        switch (level) {
          case Level.L1_b: {
            return "1b";
          }
          case Level.L1: {
            return "1";
          }
          case Level.L1_1: {
            return "1.1";
          }
          case Level.L1_2: {
            return "1.2";
          }
          case Level.L1_3: {
            return "1.3";
          }
          case Level.L2: {
            return "2";
          }
          case Level.L2_1: {
            return "2.1";
          }
          case Level.L2_2: {
            return "2.2";
          }
          case Level.L3: {
            return "3";
          }
          case Level.L3_1: {
            return "3.1";
          }
          case Level.L3_2: {
            return "3.2";
          }
          case Level.L4: {
            return "4";
          }
          case Level.L4_1: {
            return "4.1";
          }
          case Level.L4_2: {
            return "4.2";
          }
          case Level.L5: {
            return "5";
          }
          case Level.L5_1: {
            return "5.1";
          }
          case Level.L5_2: {
            return "5.2";
          }
          default: {
            logger12.warn(`levelToString() | unrecognized level ${level}`);
            return void 0;
          }
        }
      }
      exports.levelToString = levelToString;
      function parseSdpProfileLevelId(params = {}) {
        const profile_level_id = params["profile-level-id"];
        return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
      }
      exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
      function isSameProfile(params1 = {}, params2 = {}) {
        const profile_level_id_1 = parseSdpProfileLevelId(params1);
        const profile_level_id_2 = parseSdpProfileLevelId(params2);
        return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
      }
      exports.isSameProfile = isSameProfile;
      function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
        if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
          logger12.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
          return void 0;
        }
        const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
        const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
        if (!local_profile_level_id) {
          throw new TypeError("invalid local_profile_level_id");
        }
        if (!remote_profile_level_id) {
          throw new TypeError("invalid remote_profile_level_id");
        }
        if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
          throw new TypeError("H264 Profile mismatch");
        }
        const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
        const local_level = local_profile_level_id.level;
        const remote_level = remote_profile_level_id.level;
        const min_level = minLevel(local_level, remote_level);
        const answer_level = level_asymmetry_allowed ? local_level : min_level;
        logger12.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
        return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
      }
      exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
      function byteMaskString(c, str) {
        return Number(str[0] === c) << 7 | Number(str[1] === c) << 6 | Number(str[2] === c) << 5 | Number(str[3] === c) << 4 | Number(str[4] === c) << 3 | Number(str[5] === c) << 2 | Number(str[6] === c) << 1 | Number(str[7] === c) << 0;
      }
      function isLessLevel(a, b) {
        if (a === Level.L1_b) {
          return b !== Level.L1 && b !== Level.L1_b;
        }
        if (b === Level.L1_b) {
          return a !== Level.L1;
        }
        return a < b;
      }
      function minLevel(a, b) {
        return isLessLevel(a, b) ? a : b;
      }
      function isLevelAsymmetryAllowed(params = {}) {
        const level_asymmetry_allowed = params["level-asymmetry-allowed"];
        return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/ortc.js
  var require_ortc = __commonJS({
    "../../node_modules/mediasoup-client/lib/ortc.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
      var h264 = __importStar(require_lib());
      var utils = __importStar(require_utils());
      var RTP_PROBATOR_MID = "probator";
      var RTP_PROBATOR_SSRC = 1234;
      var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
      function validateRtpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (caps.codecs && !Array.isArray(caps.codecs)) {
          throw new TypeError("caps.codecs is not an array");
        } else if (!caps.codecs) {
          caps.codecs = [];
        }
        for (const codec of caps.codecs) {
          validateRtpCodecCapability(codec);
        }
        if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
          throw new TypeError("caps.headerExtensions is not an array");
        } else if (!caps.headerExtensions) {
          caps.headerExtensions = [];
        }
        for (const ext of caps.headerExtensions) {
          validateRtpHeaderExtension(ext);
        }
      }
      exports.validateRtpCapabilities = validateRtpCapabilities;
      function validateRtpCodecCapability(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        codec.kind = mimeTypeMatch[1].toLowerCase();
        if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== "number") {
          throw new TypeError("invalid codec.preferredPayloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        if (codec.kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      exports.validateRtpCodecCapability = validateRtpCodecCapability;
      function validateRtcpFeedback(fb) {
        if (typeof fb !== "object") {
          throw new TypeError("fb is not an object");
        }
        if (!fb.type || typeof fb.type !== "string") {
          throw new TypeError("missing fb.type");
        }
        if (!fb.parameter || typeof fb.parameter !== "string") {
          fb.parameter = "";
        }
      }
      exports.validateRtcpFeedback = validateRtcpFeedback;
      function validateRtpHeaderExtension(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (ext.kind !== "audio" && ext.kind !== "video") {
          throw new TypeError("invalid ext.kind");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.preferredId !== "number") {
          throw new TypeError("missing ext.preferredId");
        }
        if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
          throw new TypeError("invalid ext.preferredEncrypt");
        } else if (!ext.preferredEncrypt) {
          ext.preferredEncrypt = false;
        }
        if (ext.direction && typeof ext.direction !== "string") {
          throw new TypeError("invalid ext.direction");
        } else if (!ext.direction) {
          ext.direction = "sendrecv";
        }
      }
      exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
      function validateRtpParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (params.mid && typeof params.mid !== "string") {
          throw new TypeError("params.mid is not a string");
        }
        if (!Array.isArray(params.codecs)) {
          throw new TypeError("missing params.codecs");
        }
        for (const codec of params.codecs) {
          validateRtpCodecParameters(codec);
        }
        if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
          throw new TypeError("params.headerExtensions is not an array");
        } else if (!params.headerExtensions) {
          params.headerExtensions = [];
        }
        for (const ext of params.headerExtensions) {
          validateRtpHeaderExtensionParameters(ext);
        }
        if (params.encodings && !Array.isArray(params.encodings)) {
          throw new TypeError("params.encodings is not an array");
        } else if (!params.encodings) {
          params.encodings = [];
        }
        for (const encoding of params.encodings) {
          validateRtpEncodingParameters(encoding);
        }
        if (params.rtcp && typeof params.rtcp !== "object") {
          throw new TypeError("params.rtcp is not an object");
        } else if (!params.rtcp) {
          params.rtcp = {};
        }
        validateRtcpParameters(params.rtcp);
      }
      exports.validateRtpParameters = validateRtpParameters;
      function validateRtpCodecParameters(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        if (typeof codec !== "object") {
          throw new TypeError("codec is not an object");
        }
        if (!codec.mimeType || typeof codec.mimeType !== "string") {
          throw new TypeError("missing codec.mimeType");
        }
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        if (typeof codec.payloadType !== "number") {
          throw new TypeError("missing codec.payloadType");
        }
        if (typeof codec.clockRate !== "number") {
          throw new TypeError("missing codec.clockRate");
        }
        const kind = mimeTypeMatch[1].toLowerCase();
        if (kind === "audio") {
          if (typeof codec.channels !== "number") {
            codec.channels = 1;
          }
        } else {
          delete codec.channels;
        }
        if (!codec.parameters || typeof codec.parameters !== "object") {
          codec.parameters = {};
        }
        for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === void 0) {
            codec.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          if (key === "apt") {
            if (typeof value !== "number") {
              throw new TypeError("invalid codec apt parameter");
            }
          }
        }
        if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
          codec.rtcpFeedback = [];
        }
        for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
        }
      }
      exports.validateRtpCodecParameters = validateRtpCodecParameters;
      function validateRtpHeaderExtensionParameters(ext) {
        if (typeof ext !== "object") {
          throw new TypeError("ext is not an object");
        }
        if (!ext.uri || typeof ext.uri !== "string") {
          throw new TypeError("missing ext.uri");
        }
        if (typeof ext.id !== "number") {
          throw new TypeError("missing ext.id");
        }
        if (ext.encrypt && typeof ext.encrypt !== "boolean") {
          throw new TypeError("invalid ext.encrypt");
        } else if (!ext.encrypt) {
          ext.encrypt = false;
        }
        if (!ext.parameters || typeof ext.parameters !== "object") {
          ext.parameters = {};
        }
        for (const key of Object.keys(ext.parameters)) {
          let value = ext.parameters[key];
          if (value === void 0) {
            ext.parameters[key] = "";
            value = "";
          }
          if (typeof value !== "string" && typeof value !== "number") {
            throw new TypeError("invalid header extension parameter");
          }
        }
      }
      exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
      function validateRtpEncodingParameters(encoding) {
        if (typeof encoding !== "object") {
          throw new TypeError("encoding is not an object");
        }
        if (encoding.ssrc && typeof encoding.ssrc !== "number") {
          throw new TypeError("invalid encoding.ssrc");
        }
        if (encoding.rid && typeof encoding.rid !== "string") {
          throw new TypeError("invalid encoding.rid");
        }
        if (encoding.rtx && typeof encoding.rtx !== "object") {
          throw new TypeError("invalid encoding.rtx");
        } else if (encoding.rtx) {
          if (typeof encoding.rtx.ssrc !== "number") {
            throw new TypeError("missing encoding.rtx.ssrc");
          }
        }
        if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
          encoding.dtx = false;
        }
        if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
          throw new TypeError("invalid encoding.scalabilityMode");
        }
      }
      exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
      function validateRtcpParameters(rtcp) {
        if (typeof rtcp !== "object") {
          throw new TypeError("rtcp is not an object");
        }
        if (rtcp.cname && typeof rtcp.cname !== "string") {
          throw new TypeError("invalid rtcp.cname");
        }
        if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
          rtcp.reducedSize = true;
        }
      }
      exports.validateRtcpParameters = validateRtcpParameters;
      function validateSctpCapabilities(caps) {
        if (typeof caps !== "object") {
          throw new TypeError("caps is not an object");
        }
        if (!caps.numStreams || typeof caps.numStreams !== "object") {
          throw new TypeError("missing caps.numStreams");
        }
        validateNumSctpStreams(caps.numStreams);
      }
      exports.validateSctpCapabilities = validateSctpCapabilities;
      function validateNumSctpStreams(numStreams) {
        if (typeof numStreams !== "object") {
          throw new TypeError("numStreams is not an object");
        }
        if (typeof numStreams.OS !== "number") {
          throw new TypeError("missing numStreams.OS");
        }
        if (typeof numStreams.MIS !== "number") {
          throw new TypeError("missing numStreams.MIS");
        }
      }
      exports.validateNumSctpStreams = validateNumSctpStreams;
      function validateSctpParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (typeof params.port !== "number") {
          throw new TypeError("missing params.port");
        }
        if (typeof params.OS !== "number") {
          throw new TypeError("missing params.OS");
        }
        if (typeof params.MIS !== "number") {
          throw new TypeError("missing params.MIS");
        }
        if (typeof params.maxMessageSize !== "number") {
          throw new TypeError("missing params.maxMessageSize");
        }
      }
      exports.validateSctpParameters = validateSctpParameters;
      function validateSctpStreamParameters(params) {
        if (typeof params !== "object") {
          throw new TypeError("params is not an object");
        }
        if (typeof params.streamId !== "number") {
          throw new TypeError("missing params.streamId");
        }
        let orderedGiven = false;
        if (typeof params.ordered === "boolean") {
          orderedGiven = true;
        } else {
          params.ordered = true;
        }
        if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") {
          throw new TypeError("invalid params.maxPacketLifeTime");
        }
        if (params.maxRetransmits && typeof params.maxRetransmits !== "number") {
          throw new TypeError("invalid params.maxRetransmits");
        }
        if (params.maxPacketLifeTime && params.maxRetransmits) {
          throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
        }
        if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
          throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
        } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
          params.ordered = false;
        }
        if (params.label && typeof params.label !== "string") {
          throw new TypeError("invalid params.label");
        }
        if (params.protocol && typeof params.protocol !== "string") {
          throw new TypeError("invalid params.protocol");
        }
      }
      exports.validateSctpStreamParameters = validateSctpStreamParameters;
      function getExtendedRtpCapabilities(localCaps, remoteCaps) {
        const extendedRtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const remoteCodec of remoteCaps.codecs || []) {
          if (isRtxCodec(remoteCodec)) {
            continue;
          }
          const matchingLocalCodec = (localCaps.codecs || []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
          if (!matchingLocalCodec) {
            continue;
          }
          const extendedCodec = {
            mimeType: matchingLocalCodec.mimeType,
            kind: matchingLocalCodec.kind,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: void 0,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: void 0,
            localParameters: matchingLocalCodec.parameters,
            remoteParameters: remoteCodec.parameters,
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        }
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) && localCodec.parameters.apt === extendedCodec.localPayloadType);
          const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) && remoteCodec.parameters.apt === extendedCodec.remotePayloadType);
          if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
            extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
            extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
          }
        }
        for (const remoteExt of remoteCaps.headerExtensions) {
          const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
          if (!matchingLocalExt) {
            continue;
          }
          const extendedExt = {
            kind: remoteExt.kind,
            uri: remoteExt.uri,
            sendId: matchingLocalExt.preferredId,
            recvId: remoteExt.preferredId,
            encrypt: matchingLocalExt.preferredEncrypt,
            direction: "sendrecv"
          };
          switch (remoteExt.direction) {
            case "sendrecv": {
              extendedExt.direction = "sendrecv";
              break;
            }
            case "recvonly": {
              extendedExt.direction = "sendonly";
              break;
            }
            case "sendonly": {
              extendedExt.direction = "recvonly";
              break;
            }
            case "inactive": {
              extendedExt.direction = "inactive";
              break;
            }
          }
          extendedRtpCapabilities.headerExtensions.push(extendedExt);
        }
        return extendedRtpCapabilities;
      }
      exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
      function getRecvRtpCapabilities(extendedRtpCapabilities) {
        const rtpCapabilities = {
          codecs: [],
          headerExtensions: []
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const codec = {
            mimeType: extendedCodec.mimeType,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remotePayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpCapabilities.codecs.push(codec);
          if (!extendedCodec.remoteRtxPayloadType) {
            continue;
          }
          const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            kind: extendedCodec.kind,
            preferredPayloadType: extendedCodec.remoteRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
              apt: extendedCodec.remotePayloadType
            },
            rtcpFeedback: []
          };
          rtpCapabilities.codecs.push(rtxCodec);
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
            continue;
          }
          const ext = {
            kind: extendedExtension.kind,
            uri: extendedExtension.uri,
            preferredId: extendedExtension.recvId,
            preferredEncrypt: extendedExtension.encrypt,
            direction: extendedExtension.direction
          };
          rtpCapabilities.headerExtensions.push(ext);
        }
        return rtpCapabilities;
      }
      exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
      function getSendingRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.localParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        return rtpParameters;
      }
      exports.getSendingRtpParameters = getSendingRtpParameters;
      function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
        const rtpParameters = {
          mid: void 0,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
        };
        for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind) {
            continue;
          }
          const codec = {
            mimeType: extendedCodec.mimeType,
            payloadType: extendedCodec.localPayloadType,
            clockRate: extendedCodec.clockRate,
            channels: extendedCodec.channels,
            parameters: extendedCodec.remoteParameters,
            rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          if (extendedCodec.localRtxPayloadType) {
            const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              payloadType: extendedCodec.localRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                apt: extendedCodec.localPayloadType
              },
              rtcpFeedback: []
            };
            rtpParameters.codecs.push(rtxCodec);
          }
        }
        for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
            continue;
          }
          const ext = {
            uri: extendedExtension.uri,
            id: extendedExtension.sendId,
            encrypt: extendedExtension.encrypt,
            parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
        }
        if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "goog-remb");
          }
        } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "transport-cc");
          }
        } else {
          for (const codec of rtpParameters.codecs) {
            codec.rtcpFeedback = (codec.rtcpFeedback || []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
          }
        }
        return rtpParameters;
      }
      exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
      function reduceCodecs(codecs, capCodec) {
        const filteredCodecs = [];
        if (!capCodec) {
          filteredCodecs.push(codecs[0]);
          if (isRtxCodec(codecs[1])) {
            filteredCodecs.push(codecs[1]);
          }
        } else {
          for (let idx = 0; idx < codecs.length; ++idx) {
            if (matchCodecs(codecs[idx], capCodec)) {
              filteredCodecs.push(codecs[idx]);
              if (isRtxCodec(codecs[idx + 1])) {
                filteredCodecs.push(codecs[idx + 1]);
              }
              break;
            }
          }
          if (filteredCodecs.length === 0) {
            throw new TypeError("no matching codec found");
          }
        }
        return filteredCodecs;
      }
      exports.reduceCodecs = reduceCodecs;
      function generateProbatorRtpParameters(videoRtpParameters) {
        videoRtpParameters = utils.clone(videoRtpParameters);
        validateRtpParameters(videoRtpParameters);
        const rtpParameters = {
          mid: RTP_PROBATOR_MID,
          codecs: [],
          headerExtensions: [],
          encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
          rtcp: { cname: "probator" }
        };
        rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
        rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
        rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
        return rtpParameters;
      }
      exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
      function canSend(kind, extendedRtpCapabilities) {
        return extendedRtpCapabilities.codecs.some((codec) => codec.kind === kind);
      }
      exports.canSend = canSend;
      function canReceive(rtpParameters, extendedRtpCapabilities) {
        validateRtpParameters(rtpParameters);
        if (rtpParameters.codecs.length === 0) {
          return false;
        }
        const firstMediaCodec = rtpParameters.codecs[0];
        return extendedRtpCapabilities.codecs.some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
      }
      exports.canReceive = canReceive;
      function isRtxCodec(codec) {
        if (!codec) {
          return false;
        }
        return /.+\/rtx$/i.test(codec.mimeType);
      }
      function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
        const aMimeType = aCodec.mimeType.toLowerCase();
        const bMimeType = bCodec.mimeType.toLowerCase();
        if (aMimeType !== bMimeType) {
          return false;
        }
        if (aCodec.clockRate !== bCodec.clockRate) {
          return false;
        }
        if (aCodec.channels !== bCodec.channels) {
          return false;
        }
        switch (aMimeType) {
          case "video/h264": {
            if (strict) {
              const aPacketizationMode = aCodec.parameters["packetization-mode"] || 0;
              const bPacketizationMode = bCodec.parameters["packetization-mode"] || 0;
              if (aPacketizationMode !== bPacketizationMode) {
                return false;
              }
              if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
                return false;
              }
              let selectedProfileLevelId;
              try {
                selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
              } catch (error) {
                return false;
              }
              if (modify) {
                if (selectedProfileLevelId) {
                  aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                  bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                } else {
                  delete aCodec.parameters["profile-level-id"];
                  delete bCodec.parameters["profile-level-id"];
                }
              }
            }
            break;
          }
          case "video/vp9": {
            if (strict) {
              const aProfileId = aCodec.parameters["profile-id"] || 0;
              const bProfileId = bCodec.parameters["profile-id"] || 0;
              if (aProfileId !== bProfileId) {
                return false;
              }
            }
            break;
          }
        }
        return true;
      }
      function matchHeaderExtensions(aExt, bExt) {
        if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
          return false;
        }
        if (aExt.uri !== bExt.uri) {
          return false;
        }
        return true;
      }
      function reduceRtcpFeedback(codecA, codecB) {
        const reducedRtcpFeedback = [];
        for (const aFb of codecA.rtcpFeedback || []) {
          const matchingBFb = (codecB.rtcpFeedback || []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
          if (matchingBFb) {
            reducedRtcpFeedback.push(matchingBFb);
          }
        }
        return reducedRtcpFeedback;
      }
    }
  });

  // ../../node_modules/awaitqueue/lib/Logger.js
  var require_Logger3 = __commonJS({
    "../../node_modules/awaitqueue/lib/Logger.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Logger = void 0;
      var debug_1 = require_browser();
      var LIB_NAME = "awaitqueue";
      var Logger = class {
        constructor(prefix) {
          if (prefix) {
            this._debug = (0, debug_1.default)(`${LIB_NAME}:${prefix}`);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN:${prefix}`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR:${prefix}`);
          } else {
            this._debug = (0, debug_1.default)(LIB_NAME);
            this._warn = (0, debug_1.default)(`${LIB_NAME}:WARN`);
            this._error = (0, debug_1.default)(`${LIB_NAME}:ERROR`);
          }
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
        }
        get debug() {
          return this._debug;
        }
        get warn() {
          return this._warn;
        }
        get error() {
          return this._error;
        }
      };
      exports.Logger = Logger;
    }
  });

  // ../../node_modules/awaitqueue/lib/index.js
  var require_lib2 = __commonJS({
    "../../node_modules/awaitqueue/lib/index.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AwaitQueue = exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
      var Logger_1 = require_Logger3();
      var logger12 = new Logger_1.Logger();
      var AwaitQueueStoppedError = class _AwaitQueueStoppedError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue stopped");
          this.name = "AwaitQueueStoppedError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueStoppedError);
          }
        }
      };
      exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
      var AwaitQueueRemovedTaskError = class _AwaitQueueRemovedTaskError extends Error {
        constructor(message) {
          super(message ?? "AwaitQueue task removed");
          this.name = "AwaitQueueRemovedTaskError";
          if (typeof Error.captureStackTrace === "function") {
            Error.captureStackTrace(this, _AwaitQueueRemovedTaskError);
          }
        }
      };
      exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
      var AwaitQueue = class {
        constructor() {
          this.pendingTasks = /* @__PURE__ */ new Map();
          this.nextTaskId = 0;
          this.stopping = false;
        }
        get size() {
          return this.pendingTasks.size;
        }
        async push(task, name) {
          name = name ?? task.name;
          logger12.debug(`push() [name:${name}]`);
          if (typeof task !== "function") {
            throw new TypeError("given task is not a function");
          }
          if (name) {
            try {
              Object.defineProperty(task, "name", { value: name });
            } catch (error) {
            }
          }
          return new Promise((resolve, reject) => {
            const pendingTask = {
              id: this.nextTaskId++,
              task,
              name,
              enqueuedAt: Date.now(),
              executedAt: void 0,
              completed: false,
              resolve: (result) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger12.debug(`resolving task [name:${pendingTask.name}]`);
                resolve(result);
                const [nextPendingTask] = this.pendingTasks.values();
                if (nextPendingTask && !nextPendingTask.executedAt) {
                  void this.execute(nextPendingTask);
                }
              },
              reject: (error) => {
                if (pendingTask.completed) {
                  return;
                }
                pendingTask.completed = true;
                this.pendingTasks.delete(pendingTask.id);
                logger12.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error));
                reject(error);
                if (!this.stopping) {
                  const [nextPendingTask] = this.pendingTasks.values();
                  if (nextPendingTask && !nextPendingTask.executedAt) {
                    void this.execute(nextPendingTask);
                  }
                }
              }
            };
            this.pendingTasks.set(pendingTask.id, pendingTask);
            if (this.pendingTasks.size === 1) {
              void this.execute(pendingTask);
            }
          });
        }
        stop() {
          logger12.debug("stop()");
          this.stopping = true;
          for (const pendingTask of this.pendingTasks.values()) {
            logger12.debug(`stop() | stopping task [name:${pendingTask.name}]`);
            pendingTask.reject(new AwaitQueueStoppedError());
          }
          this.stopping = false;
        }
        remove(taskIdx) {
          logger12.debug(`remove() [taskIdx:${taskIdx}]`);
          const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
          if (!pendingTask) {
            logger12.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
            return;
          }
          pendingTask.reject(new AwaitQueueRemovedTaskError());
        }
        dump() {
          const now = Date.now();
          let idx = 0;
          return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
            idx: idx++,
            task: pendingTask.task,
            name: pendingTask.name,
            enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
            executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
          }));
        }
        async execute(pendingTask) {
          logger12.debug(`execute() [name:${pendingTask.name}]`);
          if (pendingTask.executedAt) {
            throw new Error("task already being executed");
          }
          pendingTask.executedAt = Date.now();
          try {
            const result = await pendingTask.task();
            pendingTask.resolve(result);
          } catch (error) {
            pendingTask.reject(error);
          }
        }
      };
      exports.AwaitQueue = AwaitQueue;
    }
  });

  // ../../node_modules/queue-microtask/index.js
  var require_queue_microtask = __commonJS({
    "../../node_modules/queue-microtask/index.js"(exports, module) {
      "use strict";
      var promise;
      module.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
        throw err;
      }, 0));
    }
  });

  // ../../node_modules/mediasoup-client/lib/Producer.js
  var require_Producer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Producer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Producer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("Producer");
      var Producer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._rtpSender = rtpSender;
          this._track = track;
          this._kind = track.kind;
          this._rtpParameters = rtpParameters;
          this._paused = disableTrackOnPause ? !track.enabled : false;
          this._maxSpatialLayer = void 0;
          this._stopTracks = stopTracks;
          this._disableTrackOnPause = disableTrackOnPause;
          this._zeroRtpOnPause = zeroRtpOnPause;
          this._appData = appData || {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Producer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Whether the Producer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._kind;
        }
        /**
         * Associated RTCRtpSender.
         */
        get rtpSender() {
          return this._rtpSender;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Producer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * Max spatial layer.
         *
         * @type {Number | undefined}
         */
        get maxSpatialLayer() {
          return this._maxSpatialLayer;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Producer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpSender stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses sending media.
         */
        pause() {
          logger12.debug("pause()");
          if (this._closed) {
            logger12.error("pause() | Producer closed");
            return;
          }
          this._paused = true;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = false;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@pause", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes sending media.
         */
        resume() {
          logger12.debug("resume()");
          if (this._closed) {
            logger12.error("resume() | Producer closed");
            return;
          }
          this._paused = false;
          if (this._track && this._disableTrackOnPause) {
            this._track.enabled = true;
          }
          if (this._zeroRtpOnPause) {
            new Promise((resolve, reject) => {
              this.safeEmit("@resume", resolve, reject);
            }).catch(() => {
            });
          }
          this._observer.safeEmit("resume");
        }
        /**
         * Replaces the current track with a new one or null.
         */
        async replaceTrack({ track }) {
          logger12.debug("replaceTrack() [track:%o]", track);
          if (this._closed) {
            if (track && this._stopTracks) {
              try {
                track.stop();
              } catch (error) {
              }
            }
            throw new errors_1.InvalidStateError("closed");
          } else if (track && track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          }
          if (track === this._track) {
            logger12.debug("replaceTrack() | same track, ignored");
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@replacetrack", track, resolve, reject);
          });
          this.destroyTrack();
          this._track = track;
          if (this._track && this._disableTrackOnPause) {
            if (!this._paused) {
              this._track.enabled = true;
            } else if (this._paused) {
              this._track.enabled = false;
            }
          }
          this.handleTrack();
        }
        /**
         * Sets the video max spatial layer to be sent.
         */
        async setMaxSpatialLayer(spatialLayer) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._kind !== "video") {
            throw new errors_1.UnsupportedError("not a video Producer");
          } else if (typeof spatialLayer !== "number") {
            throw new TypeError("invalid spatialLayer");
          }
          if (spatialLayer === this._maxSpatialLayer) {
            return;
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
          }).catch(() => {
          });
          this._maxSpatialLayer = spatialLayer;
        }
        async setRtpEncodingParameters(params) {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (typeof params !== "object") {
            throw new TypeError("invalid params");
          }
          await new Promise((resolve, reject) => {
            this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
          });
        }
        onTrackEnded() {
          logger12.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          if (!this._track) {
            return;
          }
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          if (!this._track) {
            return;
          }
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            if (this._stopTracks) {
              this._track.stop();
            }
          } catch (error) {
          }
        }
      };
      exports.Producer = Producer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Consumer.js
  var require_Consumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/Consumer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Consumer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("Consumer");
      var Consumer2 = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._localId = localId;
          this._producerId = producerId;
          this._rtpReceiver = rtpReceiver;
          this._track = track;
          this._rtpParameters = rtpParameters;
          this._paused = !track.enabled;
          this._appData = appData || {};
          this.onTrackEnded = this.onTrackEnded.bind(this);
          this.handleTrack();
        }
        /**
         * Consumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Local id.
         */
        get localId() {
          return this._localId;
        }
        /**
         * Associated Producer id.
         */
        get producerId() {
          return this._producerId;
        }
        /**
         * Whether the Consumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Media kind.
         */
        get kind() {
          return this._track.kind;
        }
        /**
         * Associated RTCRtpReceiver.
         */
        get rtpReceiver() {
          return this._rtpReceiver;
        }
        /**
         * The associated track.
         */
        get track() {
          return this._track;
        }
        /**
         * RTP parameters.
         */
        get rtpParameters() {
          return this._rtpParameters;
        }
        /**
         * Whether the Consumer is paused.
         */
        get paused() {
          return this._paused;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the Consumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this.destroyTrack();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this.destroyTrack();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Get associated RTCRtpReceiver stats.
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return new Promise((resolve, reject) => {
            this.safeEmit("@getstats", resolve, reject);
          });
        }
        /**
         * Pauses receiving media.
         */
        pause() {
          logger12.debug("pause()");
          if (this._closed) {
            logger12.error("pause() | Consumer closed");
            return;
          }
          if (this._paused) {
            logger12.debug("pause() | Consumer is already paused");
            return;
          }
          this._paused = true;
          this._track.enabled = false;
          this.emit("@pause");
          this._observer.safeEmit("pause");
        }
        /**
         * Resumes receiving media.
         */
        resume() {
          logger12.debug("resume()");
          if (this._closed) {
            logger12.error("resume() | Consumer closed");
            return;
          }
          if (!this._paused) {
            logger12.debug("resume() | Consumer is already resumed");
            return;
          }
          this._paused = false;
          this._track.enabled = true;
          this.emit("@resume");
          this._observer.safeEmit("resume");
        }
        onTrackEnded() {
          logger12.debug('track "ended" event');
          this.safeEmit("trackended");
          this._observer.safeEmit("trackended");
        }
        handleTrack() {
          this._track.addEventListener("ended", this.onTrackEnded);
        }
        destroyTrack() {
          try {
            this._track.removeEventListener("ended", this.onTrackEnded);
            this._track.stop();
          } catch (error) {
          }
        }
      };
      exports.Consumer = Consumer2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataProducer.js
  var require_DataProducer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataProducer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataProducer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var logger12 = new Logger_1.Logger("DataProducer");
      var DataProducer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData || {};
          this.handleDataChannel();
        }
        /**
         * DataProducer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the DataProducer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel bufferedAmount.
         */
        get bufferedAmount() {
          return this._dataChannel.bufferedAmount;
        }
        /**
         * DataChannel bufferedAmountLowThreshold.
         */
        get bufferedAmountLowThreshold() {
          return this._dataChannel.bufferedAmountLowThreshold;
        }
        /**
         * Set DataChannel bufferedAmountLowThreshold.
         */
        set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
          this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataProducer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        /**
         * Send a message.
         *
         * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
         */
        send(data) {
          logger12.debug("send()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          this._dataChannel.send(data);
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger12.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger12.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger12.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "message" event in a DataProducer, message discarded');
          });
          this._dataChannel.addEventListener("bufferedamountlow", () => {
            if (this._closed) {
              return;
            }
            this.safeEmit("bufferedamountlow");
          });
        }
      };
      exports.DataProducer = DataProducer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/DataConsumer.js
  var require_DataConsumer = __commonJS({
    "../../node_modules/mediasoup-client/lib/DataConsumer.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DataConsumer = void 0;
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var logger12 = new Logger_1.Logger("DataConsumer");
      var DataConsumer = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
          super();
          this._closed = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          this._id = id;
          this._dataProducerId = dataProducerId;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData || {};
          this.handleDataChannel();
        }
        /**
         * DataConsumer id.
         */
        get id() {
          return this._id;
        }
        /**
         * Associated DataProducer id.
         */
        get dataProducerId() {
          return this._dataProducerId;
        }
        /**
         * Whether the DataConsumer is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * SCTP stream parameters.
         */
        get sctpStreamParameters() {
          return this._sctpStreamParameters;
        }
        /**
         * DataChannel readyState.
         */
        get readyState() {
          return this._dataChannel.readyState;
        }
        /**
         * DataChannel label.
         */
        get label() {
          return this._dataChannel.label;
        }
        /**
         * DataChannel protocol.
         */
        get protocol() {
          return this._dataChannel.protocol;
        }
        /**
         * DataChannel binaryType.
         */
        get binaryType() {
          return this._dataChannel.binaryType;
        }
        /**
         * Set DataChannel binaryType.
         */
        set binaryType(binaryType) {
          this._dataChannel.binaryType = binaryType;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Closes the DataConsumer.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._dataChannel.close();
          this.emit("@close");
          this._observer.safeEmit("close");
        }
        /**
         * Transport was closed.
         */
        transportClosed() {
          if (this._closed) {
            return;
          }
          logger12.debug("transportClosed()");
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit("transportclose");
          this._observer.safeEmit("close");
        }
        handleDataChannel() {
          this._dataChannel.addEventListener("open", () => {
            if (this._closed) {
              return;
            }
            logger12.debug('DataChannel "open" event');
            this.safeEmit("open");
          });
          this._dataChannel.addEventListener("error", (event) => {
            if (this._closed) {
              return;
            }
            let { error } = event;
            if (!error) {
              error = new Error("unknown DataChannel error");
            }
            if (error.errorDetail === "sctp-failure") {
              logger12.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", error.sctpCauseCode, error.message);
            } else {
              logger12.error('DataChannel "error" event: %o', error);
            }
            this.safeEmit("error", error);
          });
          this._dataChannel.addEventListener("close", () => {
            if (this._closed) {
              return;
            }
            logger12.warn('DataChannel "close" event');
            this._closed = true;
            this.emit("@close");
            this.safeEmit("close");
            this._observer.safeEmit("close");
          });
          this._dataChannel.addEventListener("message", (event) => {
            if (this._closed) {
              return;
            }
            this.safeEmit("message", event.data);
          });
        }
      };
      exports.DataConsumer = DataConsumer;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Transport.js
  var require_Transport = __commonJS({
    "../../node_modules/mediasoup-client/lib/Transport.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Transport = void 0;
      var awaitqueue_1 = require_lib2();
      var queue_microtask_1 = __importDefault(require_queue_microtask());
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Producer_1 = require_Producer();
      var Consumer_1 = require_Consumer();
      var DataProducer_1 = require_DataProducer();
      var DataConsumer_1 = require_DataConsumer();
      var logger12 = new Logger_1.Logger("Transport");
      var ConsumerCreationTask = class {
        constructor(consumerOptions) {
          this.consumerOptions = consumerOptions;
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
        }
      };
      var Transport2 = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {
          super();
          this._closed = false;
          this._iceGatheringState = "new";
          this._connectionState = "new";
          this._producers = /* @__PURE__ */ new Map();
          this._consumers = /* @__PURE__ */ new Map();
          this._dataProducers = /* @__PURE__ */ new Map();
          this._dataConsumers = /* @__PURE__ */ new Map();
          this._probatorConsumerCreated = false;
          this._awaitQueue = new awaitqueue_1.AwaitQueue();
          this._pendingConsumerTasks = [];
          this._consumerCreationInProgress = false;
          this._pendingPauseConsumers = /* @__PURE__ */ new Map();
          this._consumerPauseInProgress = false;
          this._pendingResumeConsumers = /* @__PURE__ */ new Map();
          this._consumerResumeInProgress = false;
          this._pendingCloseConsumers = /* @__PURE__ */ new Map();
          this._consumerCloseInProgress = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor() [id:%s, direction:%s]", id, direction);
          this._id = id;
          this._direction = direction;
          this._extendedRtpCapabilities = extendedRtpCapabilities;
          this._canProduceByKind = canProduceByKind;
          this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
          additionalSettings = utils.clone(additionalSettings) || {};
          delete additionalSettings.iceServers;
          delete additionalSettings.iceTransportPolicy;
          delete additionalSettings.bundlePolicy;
          delete additionalSettings.rtcpMuxPolicy;
          delete additionalSettings.sdpSemantics;
          this._handler = handlerFactory();
          this._handler.run({
            direction,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            extendedRtpCapabilities
          });
          this._appData = appData || {};
          this.handleHandler();
        }
        /**
         * Transport id.
         */
        get id() {
          return this._id;
        }
        /**
         * Whether the Transport is closed.
         */
        get closed() {
          return this._closed;
        }
        /**
         * Transport direction.
         */
        get direction() {
          return this._direction;
        }
        /**
         * RTC handler instance.
         */
        get handler() {
          return this._handler;
        }
        /**
         * ICE gathering state.
         */
        get iceGatheringState() {
          return this._iceGatheringState;
        }
        /**
         * Connection state.
         */
        get connectionState() {
          return this._connectionState;
        }
        /**
         * App custom data.
         */
        get appData() {
          return this._appData;
        }
        /**
         * App custom data setter.
         */
        set appData(appData) {
          this._appData = appData;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Close the Transport.
         */
        close() {
          if (this._closed) {
            return;
          }
          logger12.debug("close()");
          this._closed = true;
          this._awaitQueue.stop();
          this._handler.close();
          this._connectionState = "closed";
          for (const producer of this._producers.values()) {
            producer.transportClosed();
          }
          this._producers.clear();
          for (const consumer of this._consumers.values()) {
            consumer.transportClosed();
          }
          this._consumers.clear();
          for (const dataProducer of this._dataProducers.values()) {
            dataProducer.transportClosed();
          }
          this._dataProducers.clear();
          for (const dataConsumer of this._dataConsumers.values()) {
            dataConsumer.transportClosed();
          }
          this._dataConsumers.clear();
          this._observer.safeEmit("close");
        }
        /**
         * Get associated Transport (RTCPeerConnection) stats.
         *
         * @returns {RTCStatsReport}
         */
        async getStats() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          }
          return this._handler.getTransportStats();
        }
        /**
         * Restart ICE connection.
         */
        async restartIce({ iceParameters }) {
          logger12.debug("restartIce()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!iceParameters) {
            throw new TypeError("missing iceParameters");
          }
          return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
        }
        /**
         * Update ICE servers.
         */
        async updateIceServers({ iceServers } = {}) {
          logger12.debug("updateIceServers()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!Array.isArray(iceServers)) {
            throw new TypeError("missing iceServers");
          }
          return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
        }
        /**
         * Create a Producer.
         */
        async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {
          logger12.debug("produce() [track:%o]", track);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (!track) {
            throw new TypeError("missing track");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._canProduceByKind[track.kind]) {
            throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
          } else if (track.readyState === "ended") {
            throw new errors_1.InvalidStateError("track ended");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("produce") === 0) {
            throw new TypeError('no "produce" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          return this._awaitQueue.push(async () => {
            let normalizedEncodings;
            if (encodings && !Array.isArray(encodings)) {
              throw TypeError("encodings must be an array");
            } else if (encodings && encodings.length === 0) {
              normalizedEncodings = void 0;
            } else if (encodings) {
              normalizedEncodings = encodings.map((encoding) => {
                const normalizedEncoding = { active: true };
                if (encoding.active === false) {
                  normalizedEncoding.active = false;
                }
                if (typeof encoding.dtx === "boolean") {
                  normalizedEncoding.dtx = encoding.dtx;
                }
                if (typeof encoding.scalabilityMode === "string") {
                  normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                }
                if (typeof encoding.scaleResolutionDownBy === "number") {
                  normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                }
                if (typeof encoding.maxBitrate === "number") {
                  normalizedEncoding.maxBitrate = encoding.maxBitrate;
                }
                if (typeof encoding.maxFramerate === "number") {
                  normalizedEncoding.maxFramerate = encoding.maxFramerate;
                }
                if (typeof encoding.adaptivePtime === "boolean") {
                  normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                }
                if (typeof encoding.priority === "string") {
                  normalizedEncoding.priority = encoding.priority;
                }
                if (typeof encoding.networkPriority === "string") {
                  normalizedEncoding.networkPriority = encoding.networkPriority;
                }
                return normalizedEncoding;
              });
            }
            const { localId, rtpParameters, rtpSender } = await this._handler.send({
              track,
              encodings: normalizedEncodings,
              codecOptions,
              codec
            });
            try {
              ortc.validateRtpParameters(rtpParameters);
              const { id } = await new Promise((resolve, reject) => {
                this.safeEmit("produce", {
                  kind: track.kind,
                  rtpParameters,
                  appData
                }, resolve, reject);
              });
              const producer = new Producer_1.Producer({
                id,
                localId,
                rtpSender,
                track,
                rtpParameters,
                stopTracks,
                disableTrackOnPause,
                zeroRtpOnPause,
                appData
              });
              this._producers.set(producer.id, producer);
              this.handleProducer(producer);
              this._observer.safeEmit("newproducer", producer);
              return producer;
            } catch (error) {
              this._handler.stopSending(localId).catch(() => {
              });
              throw error;
            }
          }, "transport.produce()").catch((error) => {
            if (stopTracks) {
              try {
                track.stop();
              } catch (error2) {
              }
            }
            throw error;
          });
        }
        /**
         * Create a Consumer to consume a remote Producer.
         */
        async consume({ id, producerId, kind, rtpParameters, streamId, appData = {} }) {
          logger12.debug("consume()");
          rtpParameters = utils.clone(rtpParameters);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof producerId !== "string") {
            throw new TypeError("missing producerId");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind '${kind}'`);
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
          if (!canConsume) {
            throw new errors_1.UnsupportedError("cannot consume this Producer");
          }
          const consumerCreationTask = new ConsumerCreationTask({
            id,
            producerId,
            kind,
            rtpParameters,
            streamId,
            appData
          });
          this._pendingConsumerTasks.push(consumerCreationTask);
          (0, queue_microtask_1.default)(() => {
            if (this._closed) {
              return;
            }
            if (this._consumerCreationInProgress === false) {
              this.createPendingConsumers();
            }
          });
          return consumerCreationTask.promise;
        }
        /**
         * Create a DataProducer
         */
        async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol = "", appData = {} } = {}) {
          logger12.debug("produceData()");
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "send") {
            throw new errors_1.UnsupportedError("not a sending Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (this.listenerCount("producedata") === 0) {
            throw new TypeError('no "producedata" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          if (maxPacketLifeTime || maxRetransmits) {
            ordered = false;
          }
          return this._awaitQueue.push(async () => {
            const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              label,
              protocol
            });
            ortc.validateSctpStreamParameters(sctpStreamParameters);
            const { id } = await new Promise((resolve, reject) => {
              this.safeEmit("producedata", {
                sctpStreamParameters,
                label,
                protocol,
                appData
              }, resolve, reject);
            });
            const dataProducer = new DataProducer_1.DataProducer({
              id,
              dataChannel,
              sctpStreamParameters,
              appData
            });
            this._dataProducers.set(dataProducer.id, dataProducer);
            this.handleDataProducer(dataProducer);
            this._observer.safeEmit("newdataproducer", dataProducer);
            return dataProducer;
          }, "transport.produceData()");
        }
        /**
         * Create a DataConsumer
         */
        async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol = "", appData = {} }) {
          logger12.debug("consumeData()");
          sctpStreamParameters = utils.clone(sctpStreamParameters);
          if (this._closed) {
            throw new errors_1.InvalidStateError("closed");
          } else if (this._direction !== "recv") {
            throw new errors_1.UnsupportedError("not a receiving Transport");
          } else if (!this._maxSctpMessageSize) {
            throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof dataProducerId !== "string") {
            throw new TypeError("missing dataProducerId");
          } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
            throw new TypeError('no "connect" listener set into this transport');
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          ortc.validateSctpStreamParameters(sctpStreamParameters);
          return this._awaitQueue.push(async () => {
            const { dataChannel } = await this._handler.receiveDataChannel({
              sctpStreamParameters,
              label,
              protocol
            });
            const dataConsumer = new DataConsumer_1.DataConsumer({
              id,
              dataProducerId,
              dataChannel,
              sctpStreamParameters,
              appData
            });
            this._dataConsumers.set(dataConsumer.id, dataConsumer);
            this.handleDataConsumer(dataConsumer);
            this._observer.safeEmit("newdataconsumer", dataConsumer);
            return dataConsumer;
          }, "transport.consumeData()");
        }
        // This method is guaranteed to never throw.
        async createPendingConsumers() {
          this._consumerCreationInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingConsumerTasks.length === 0) {
              logger12.debug("createPendingConsumers() | there is no Consumer to be created");
              return;
            }
            const pendingConsumerTasks = [...this._pendingConsumerTasks];
            this._pendingConsumerTasks = [];
            let videoConsumerForProbator = void 0;
            const optionsList = [];
            for (const task of pendingConsumerTasks) {
              const { id, kind, rtpParameters, streamId } = task.consumerOptions;
              optionsList.push({
                trackId: id,
                kind,
                rtpParameters,
                streamId
              });
            }
            try {
              const results = await this._handler.receive(optionsList);
              for (let idx = 0; idx < results.length; ++idx) {
                const task = pendingConsumerTasks[idx];
                const result = results[idx];
                const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
                const { localId, rtpReceiver, track } = result;
                const consumer = new Consumer_1.Consumer({
                  id,
                  localId,
                  producerId,
                  rtpReceiver,
                  track,
                  rtpParameters,
                  appData
                });
                this._consumers.set(consumer.id, consumer);
                this.handleConsumer(consumer);
                if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
                  videoConsumerForProbator = consumer;
                }
                this._observer.safeEmit("newconsumer", consumer);
                task.resolve(consumer);
              }
            } catch (error) {
              for (const task of pendingConsumerTasks) {
                task.reject(error);
              }
            }
            if (videoConsumerForProbator) {
              try {
                const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
                await this._handler.receive([
                  {
                    trackId: "probator",
                    kind: "video",
                    rtpParameters: probatorRtpParameters
                  }
                ]);
                logger12.debug("createPendingConsumers() | Consumer for RTP probation created");
                this._probatorConsumerCreated = true;
              } catch (error) {
                logger12.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error);
              }
            }
          }, "transport.createPendingConsumers()").then(() => {
            this._consumerCreationInProgress = false;
            if (this._pendingConsumerTasks.length > 0) {
              this.createPendingConsumers();
            }
          }).catch(() => {
          });
        }
        pausePendingConsumers() {
          this._consumerPauseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingPauseConsumers.size === 0) {
              logger12.debug("pausePendingConsumers() | there is no Consumer to be paused");
              return;
            }
            const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
            this._pendingPauseConsumers.clear();
            try {
              const localIds = pendingPauseConsumers.map((consumer) => consumer.localId);
              await this._handler.pauseReceiving(localIds);
            } catch (error) {
              logger12.error("pausePendingConsumers() | failed to pause Consumers:", error);
            }
          }, "transport.pausePendingConsumers").then(() => {
            this._consumerPauseInProgress = false;
            if (this._pendingPauseConsumers.size > 0) {
              this.pausePendingConsumers();
            }
          }).catch(() => {
          });
        }
        resumePendingConsumers() {
          this._consumerResumeInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingResumeConsumers.size === 0) {
              logger12.debug("resumePendingConsumers() | there is no Consumer to be resumed");
              return;
            }
            const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
            this._pendingResumeConsumers.clear();
            try {
              const localIds = pendingResumeConsumers.map((consumer) => consumer.localId);
              await this._handler.resumeReceiving(localIds);
            } catch (error) {
              logger12.error("resumePendingConsumers() | failed to resume Consumers:", error);
            }
          }, "transport.resumePendingConsumers").then(() => {
            this._consumerResumeInProgress = false;
            if (this._pendingResumeConsumers.size > 0) {
              this.resumePendingConsumers();
            }
          }).catch(() => {
          });
        }
        closePendingConsumers() {
          this._consumerCloseInProgress = true;
          this._awaitQueue.push(async () => {
            if (this._pendingCloseConsumers.size === 0) {
              logger12.debug("closePendingConsumers() | there is no Consumer to be closed");
              return;
            }
            const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
            this._pendingCloseConsumers.clear();
            try {
              await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));
            } catch (error) {
              logger12.error("closePendingConsumers() | failed to close Consumers:", error);
            }
          }, "transport.closePendingConsumers").then(() => {
            this._consumerCloseInProgress = false;
            if (this._pendingCloseConsumers.size > 0) {
              this.closePendingConsumers();
            }
          }).catch(() => {
          });
        }
        handleHandler() {
          const handler = this._handler;
          handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
            if (this._closed) {
              errback(new errors_1.InvalidStateError("closed"));
              return;
            }
            this.safeEmit("connect", { dtlsParameters }, callback, errback);
          });
          handler.on("@icegatheringstatechange", (iceGatheringState) => {
            if (iceGatheringState === this._iceGatheringState) {
              return;
            }
            logger12.debug("ICE gathering state changed to %s", iceGatheringState);
            this._iceGatheringState = iceGatheringState;
            if (!this._closed) {
              this.safeEmit("icegatheringstatechange", iceGatheringState);
            }
          });
          handler.on("@connectionstatechange", (connectionState) => {
            if (connectionState === this._connectionState) {
              return;
            }
            logger12.debug("connection state changed to %s", connectionState);
            this._connectionState = connectionState;
            if (!this._closed) {
              this.safeEmit("connectionstatechange", connectionState);
            }
          });
        }
        handleProducer(producer) {
          producer.on("@close", () => {
            this._producers.delete(producer.id);
            if (this._closed) {
              return;
            }
            this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), "producer @close event").catch((error) => logger12.warn("producer.close() failed:%o", error));
          });
          producer.on("@pause", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
          });
          producer.on("@resume", (callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
          });
          producer.on("@replacetrack", (track, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
          });
          producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
          });
          producer.on("@setrtpencodingparameters", (params, callback, errback) => {
            this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
          });
          producer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
          });
        }
        handleConsumer(consumer) {
          consumer.on("@close", () => {
            this._consumers.delete(consumer.id);
            this._pendingPauseConsumers.delete(consumer.id);
            this._pendingResumeConsumers.delete(consumer.id);
            if (this._closed) {
              return;
            }
            this._pendingCloseConsumers.set(consumer.id, consumer);
            if (this._consumerCloseInProgress === false) {
              this.closePendingConsumers();
            }
          });
          consumer.on("@pause", () => {
            if (this._pendingResumeConsumers.has(consumer.id)) {
              this._pendingResumeConsumers.delete(consumer.id);
            }
            this._pendingPauseConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerPauseInProgress === false) {
                this.pausePendingConsumers();
              }
            });
          });
          consumer.on("@resume", () => {
            if (this._pendingPauseConsumers.has(consumer.id)) {
              this._pendingPauseConsumers.delete(consumer.id);
            }
            this._pendingResumeConsumers.set(consumer.id, consumer);
            (0, queue_microtask_1.default)(() => {
              if (this._closed) {
                return;
              }
              if (this._consumerResumeInProgress === false) {
                this.resumePendingConsumers();
              }
            });
          });
          consumer.on("@getstats", (callback, errback) => {
            if (this._closed) {
              return errback(new errors_1.InvalidStateError("closed"));
            }
            this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
          });
        }
        handleDataProducer(dataProducer) {
          dataProducer.on("@close", () => {
            this._dataProducers.delete(dataProducer.id);
          });
        }
        handleDataConsumer(dataConsumer) {
          dataConsumer.on("@close", () => {
            this._dataConsumers.delete(dataConsumer.id);
          });
        }
      };
      exports.Transport = Transport2;
    }
  });

  // ../../node_modules/sdp-transform/lib/grammar.js
  var require_grammar = __commonJS({
    "../../node_modules/sdp-transform/lib/grammar.js"(exports, module) {
      "use strict";
      var grammar = module.exports = {
        v: [{
          name: "version",
          reg: /^(\d*)$/
        }],
        o: [{
          // o=- 20518 0 IN IP4 203.0.113.1
          // NB: sessionId will be a String in most cases because it is huge
          name: "origin",
          reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
          names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
          format: "%s %s %d %s IP%d %s"
        }],
        // default parsing of these only (though some of these feel outdated)
        s: [{ name: "name" }],
        i: [{ name: "description" }],
        u: [{ name: "uri" }],
        e: [{ name: "email" }],
        p: [{ name: "phone" }],
        z: [{ name: "timezones" }],
        // TODO: this one can actually be parsed properly...
        r: [{ name: "repeats" }],
        // TODO: this one can also be parsed properly
        // k: [{}], // outdated thing ignored
        t: [{
          // t=0 0
          name: "timing",
          reg: /^(\d*) (\d*)/,
          names: ["start", "stop"],
          format: "%d %d"
        }],
        c: [{
          // c=IN IP4 10.47.197.26
          name: "connection",
          reg: /^IN IP(\d) (\S*)/,
          names: ["version", "ip"],
          format: "IN IP%d %s"
        }],
        b: [{
          // b=AS:4000
          push: "bandwidth",
          reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
          names: ["type", "limit"],
          format: "%s:%s"
        }],
        m: [{
          // m=video 51744 RTP/AVP 126 97 98 34 31
          // NB: special - pushes to session
          // TODO: rtp/fmtp should be filtered by the payloads found here?
          reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
          names: ["type", "port", "protocol", "payloads"],
          format: "%s %d %s %s"
        }],
        a: [
          {
            // a=rtpmap:110 opus/48000/2
            push: "rtp",
            reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
            names: ["payload", "codec", "rate", "encoding"],
            format: function(o) {
              return o.encoding ? "rtpmap:%d %s/%s/%s" : o.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
            }
          },
          {
            // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
            // a=fmtp:111 minptime=10; useinbandfec=1
            push: "fmtp",
            reg: /^fmtp:(\d*) ([\S| ]*)/,
            names: ["payload", "config"],
            format: "fmtp:%d %s"
          },
          {
            // a=control:streamid=0
            name: "control",
            reg: /^control:(.*)/,
            format: "control:%s"
          },
          {
            // a=rtcp:65179 IN IP4 193.84.77.194
            name: "rtcp",
            reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
            names: ["port", "netType", "ipVer", "address"],
            format: function(o) {
              return o.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
            }
          },
          {
            // a=rtcp-fb:98 trr-int 100
            push: "rtcpFbTrrInt",
            reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
            names: ["payload", "value"],
            format: "rtcp-fb:%s trr-int %d"
          },
          {
            // a=rtcp-fb:98 nack rpsi
            push: "rtcpFb",
            reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
            names: ["payload", "type", "subtype"],
            format: function(o) {
              return o.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
            }
          },
          {
            // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
            // a=extmap:1/recvonly URI-gps-string
            // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
            push: "ext",
            reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
            names: ["value", "direction", "encrypt-uri", "uri", "config"],
            format: function(o) {
              return "extmap:%d" + (o.direction ? "/%s" : "%v") + (o["encrypt-uri"] ? " %s" : "%v") + " %s" + (o.config ? " %s" : "");
            }
          },
          {
            // a=extmap-allow-mixed
            name: "extmapAllowMixed",
            reg: /^(extmap-allow-mixed)/
          },
          {
            // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
            push: "crypto",
            reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
            names: ["id", "suite", "config", "sessionConfig"],
            format: function(o) {
              return o.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
            }
          },
          {
            // a=setup:actpass
            name: "setup",
            reg: /^setup:(\w*)/,
            format: "setup:%s"
          },
          {
            // a=connection:new
            name: "connectionType",
            reg: /^connection:(new|existing)/,
            format: "connection:%s"
          },
          {
            // a=mid:1
            name: "mid",
            reg: /^mid:([^\s]*)/,
            format: "mid:%s"
          },
          {
            // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
            name: "msid",
            reg: /^msid:(.*)/,
            format: "msid:%s"
          },
          {
            // a=ptime:20
            name: "ptime",
            reg: /^ptime:(\d*(?:\.\d*)*)/,
            format: "ptime:%d"
          },
          {
            // a=maxptime:60
            name: "maxptime",
            reg: /^maxptime:(\d*(?:\.\d*)*)/,
            format: "maxptime:%d"
          },
          {
            // a=sendrecv
            name: "direction",
            reg: /^(sendrecv|recvonly|sendonly|inactive)/
          },
          {
            // a=ice-lite
            name: "icelite",
            reg: /^(ice-lite)/
          },
          {
            // a=ice-ufrag:F7gI
            name: "iceUfrag",
            reg: /^ice-ufrag:(\S*)/,
            format: "ice-ufrag:%s"
          },
          {
            // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
            name: "icePwd",
            reg: /^ice-pwd:(\S*)/,
            format: "ice-pwd:%s"
          },
          {
            // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
            name: "fingerprint",
            reg: /^fingerprint:(\S*) (\S*)/,
            names: ["type", "hash"],
            format: "fingerprint:%s %s"
          },
          {
            // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
            // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
            // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
            // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
            push: "candidates",
            reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
            names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
            format: function(o) {
              var str = "candidate:%s %d %s %d %s %d typ %s";
              str += o.raddr != null ? " raddr %s rport %d" : "%v%v";
              str += o.tcptype != null ? " tcptype %s" : "%v";
              if (o.generation != null) {
                str += " generation %d";
              }
              str += o["network-id"] != null ? " network-id %d" : "%v";
              str += o["network-cost"] != null ? " network-cost %d" : "%v";
              return str;
            }
          },
          {
            // a=end-of-candidates (keep after the candidates line for readability)
            name: "endOfCandidates",
            reg: /^(end-of-candidates)/
          },
          {
            // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
            name: "remoteCandidates",
            reg: /^remote-candidates:(.*)/,
            format: "remote-candidates:%s"
          },
          {
            // a=ice-options:google-ice
            name: "iceOptions",
            reg: /^ice-options:(\S*)/,
            format: "ice-options:%s"
          },
          {
            // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
            push: "ssrcs",
            reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
            names: ["id", "attribute", "value"],
            format: function(o) {
              var str = "ssrc:%d";
              if (o.attribute != null) {
                str += " %s";
                if (o.value != null) {
                  str += ":%s";
                }
              }
              return str;
            }
          },
          {
            // a=ssrc-group:FEC 1 2
            // a=ssrc-group:FEC-FR 3004364195 1080772241
            push: "ssrcGroups",
            // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
            reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
            names: ["semantics", "ssrcs"],
            format: "ssrc-group:%s %s"
          },
          {
            // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
            name: "msidSemantic",
            reg: /^msid-semantic:\s?(\w*) (\S*)/,
            names: ["semantic", "token"],
            format: "msid-semantic: %s %s"
            // space after ':' is not accidental
          },
          {
            // a=group:BUNDLE audio video
            push: "groups",
            reg: /^group:(\w*) (.*)/,
            names: ["type", "mids"],
            format: "group:%s %s"
          },
          {
            // a=rtcp-mux
            name: "rtcpMux",
            reg: /^(rtcp-mux)/
          },
          {
            // a=rtcp-rsize
            name: "rtcpRsize",
            reg: /^(rtcp-rsize)/
          },
          {
            // a=sctpmap:5000 webrtc-datachannel 1024
            name: "sctpmap",
            reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
            names: ["sctpmapNumber", "app", "maxMessageSize"],
            format: function(o) {
              return o.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
            }
          },
          {
            // a=x-google-flag:conference
            name: "xGoogleFlag",
            reg: /^x-google-flag:([^\s]*)/,
            format: "x-google-flag:%s"
          },
          {
            // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
            push: "rids",
            reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
            names: ["id", "direction", "params"],
            format: function(o) {
              return o.params ? "rid:%s %s %s" : "rid:%s %s";
            }
          },
          {
            // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
            // a=imageattr:* send [x=800,y=640] recv *
            // a=imageattr:100 recv [x=320,y=240]
            push: "imageattrs",
            reg: new RegExp(
              // a=imageattr:97
              "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
            ),
            names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
            format: function(o) {
              return "imageattr:%s %s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
            // a=simulcast:recv 1;4,5 send 6;7
            name: "simulcast",
            reg: new RegExp(
              // a=simulcast:
              "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
            ),
            names: ["dir1", "list1", "dir2", "list2"],
            format: function(o) {
              return "simulcast:%s %s" + (o.dir2 ? " %s %s" : "");
            }
          },
          {
            // old simulcast draft 03 (implemented by Firefox)
            //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
            // a=simulcast: recv pt=97;98 send pt=97
            // a=simulcast: send rid=5;6;7 paused=6,7
            name: "simulcast_03",
            reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
            names: ["value"],
            format: "simulcast: %s"
          },
          {
            // a=framerate:25
            // a=framerate:29.97
            name: "framerate",
            reg: /^framerate:(\d+(?:$|\.\d+))/,
            format: "framerate:%s"
          },
          {
            // RFC4570
            // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
            name: "sourceFilter",
            reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
            names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
            format: "source-filter: %s %s %s %s %s"
          },
          {
            // a=bundle-only
            name: "bundleOnly",
            reg: /^(bundle-only)/
          },
          {
            // a=label:1
            name: "label",
            reg: /^label:(.+)/,
            format: "label:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
            name: "sctpPort",
            reg: /^sctp-port:(\d+)$/,
            format: "sctp-port:%s"
          },
          {
            // RFC version 26 for SCTP over DTLS
            // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
            name: "maxMessageSize",
            reg: /^max-message-size:(\d+)$/,
            format: "max-message-size:%s"
          },
          {
            // RFC7273
            // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
            push: "tsRefClocks",
            reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
            names: ["clksrc", "clksrcExt"],
            format: function(o) {
              return "ts-refclk:%s" + (o.clksrcExt != null ? "=%s" : "");
            }
          },
          {
            // RFC7273
            // a=mediaclk:direct=963214424
            name: "mediaClk",
            reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
            names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
            format: function(o) {
              var str = "mediaclk:";
              str += o.id != null ? "id=%s %s" : "%v%s";
              str += o.mediaClockValue != null ? "=%s" : "";
              str += o.rateNumerator != null ? " rate=%s" : "";
              str += o.rateDenominator != null ? "/%s" : "";
              return str;
            }
          },
          {
            // a=keywds:keywords
            name: "keywords",
            reg: /^keywds:(.+)$/,
            format: "keywds:%s"
          },
          {
            // a=content:main
            name: "content",
            reg: /^content:(.+)/,
            format: "content:%s"
          },
          // BFCP https://tools.ietf.org/html/rfc4583
          {
            // a=floorctrl:c-s
            name: "bfcpFloorCtrl",
            reg: /^floorctrl:(c-only|s-only|c-s)/,
            format: "floorctrl:%s"
          },
          {
            // a=confid:1
            name: "bfcpConfId",
            reg: /^confid:(\d+)/,
            format: "confid:%s"
          },
          {
            // a=userid:1
            name: "bfcpUserId",
            reg: /^userid:(\d+)/,
            format: "userid:%s"
          },
          {
            // a=floorid:1
            name: "bfcpFloorId",
            reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
            names: ["id", "mStream"],
            format: "floorid:%s mstrm:%s"
          },
          {
            // any a= that we don't understand is kept verbatim on media.invalid
            push: "invalid",
            names: ["value"]
          }
        ]
      };
      Object.keys(grammar).forEach(function(key) {
        var objs = grammar[key];
        objs.forEach(function(obj) {
          if (!obj.reg) {
            obj.reg = /(.*)/;
          }
          if (!obj.format) {
            obj.format = "%s";
          }
        });
      });
    }
  });

  // ../../node_modules/sdp-transform/lib/parser.js
  var require_parser = __commonJS({
    "../../node_modules/sdp-transform/lib/parser.js"(exports) {
      "use strict";
      var toIntIfInt = function(v) {
        return String(Number(v)) === v ? Number(v) : v;
      };
      var attachProperties = function(match, location, names, rawName) {
        if (rawName && !names) {
          location[rawName] = toIntIfInt(match[1]);
        } else {
          for (var i = 0; i < names.length; i += 1) {
            if (match[i + 1] != null) {
              location[names[i]] = toIntIfInt(match[i + 1]);
            }
          }
        }
      };
      var parseReg = function(obj, location, content) {
        var needsBlank = obj.name && obj.names;
        if (obj.push && !location[obj.push]) {
          location[obj.push] = [];
        } else if (needsBlank && !location[obj.name]) {
          location[obj.name] = {};
        }
        var keyLocation = obj.push ? {} : (
          // blank object that will be pushed
          needsBlank ? location[obj.name] : location
        );
        attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
        if (obj.push) {
          location[obj.push].push(keyLocation);
        }
      };
      var grammar = require_grammar();
      var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
      exports.parse = function(sdp) {
        var session = {}, media = [], location = session;
        sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l) {
          var type = l[0];
          var content = l.slice(2);
          if (type === "m") {
            media.push({ rtp: [], fmtp: [] });
            location = media[media.length - 1];
          }
          for (var j = 0; j < (grammar[type] || []).length; j += 1) {
            var obj = grammar[type][j];
            if (obj.reg.test(content)) {
              return parseReg(obj, location, content);
            }
          }
        });
        session.media = media;
        return session;
      };
      var paramReducer = function(acc, expr) {
        var s = expr.split(/=(.+)/, 2);
        if (s.length === 2) {
          acc[s[0]] = toIntIfInt(s[1]);
        } else if (s.length === 1 && expr.length > 1) {
          acc[s[0]] = void 0;
        }
        return acc;
      };
      exports.parseParams = function(str) {
        return str.split(/;\s?/).reduce(paramReducer, {});
      };
      exports.parseFmtpConfig = exports.parseParams;
      exports.parsePayloads = function(str) {
        return str.toString().split(" ").map(Number);
      };
      exports.parseRemoteCandidates = function(str) {
        var candidates = [];
        var parts = str.split(" ").map(toIntIfInt);
        for (var i = 0; i < parts.length; i += 3) {
          candidates.push({
            component: parts[i],
            ip: parts[i + 1],
            port: parts[i + 2]
          });
        }
        return candidates;
      };
      exports.parseImageAttributes = function(str) {
        return str.split(" ").map(function(item) {
          return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
        });
      };
      exports.parseSimulcastStreamList = function(str) {
        return str.split(";").map(function(stream) {
          return stream.split(",").map(function(format) {
            var scid, paused = false;
            if (format[0] !== "~") {
              scid = toIntIfInt(format);
            } else {
              scid = toIntIfInt(format.substring(1, format.length));
              paused = true;
            }
            return {
              scid,
              paused
            };
          });
        });
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/writer.js
  var require_writer = __commonJS({
    "../../node_modules/sdp-transform/lib/writer.js"(exports, module) {
      "use strict";
      var grammar = require_grammar();
      var formatRegExp = /%[sdv%]/g;
      var format = function(formatStr) {
        var i = 1;
        var args = arguments;
        var len = args.length;
        return formatStr.replace(formatRegExp, function(x) {
          if (i >= len) {
            return x;
          }
          var arg = args[i];
          i += 1;
          switch (x) {
            case "%%":
              return "%";
            case "%s":
              return String(arg);
            case "%d":
              return Number(arg);
            case "%v":
              return "";
          }
        });
      };
      var makeLine = function(type, obj, location) {
        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
        var args = [type + "=" + str];
        if (obj.names) {
          for (var i = 0; i < obj.names.length; i += 1) {
            var n = obj.names[i];
            if (obj.name) {
              args.push(location[obj.name][n]);
            } else {
              args.push(location[obj.names[i]]);
            }
          }
        } else {
          args.push(location[obj.name]);
        }
        return format.apply(null, args);
      };
      var defaultOuterOrder = [
        "v",
        "o",
        "s",
        "i",
        "u",
        "e",
        "p",
        "c",
        "b",
        "t",
        "r",
        "z",
        "a"
      ];
      var defaultInnerOrder = ["i", "c", "b", "a"];
      module.exports = function(session, opts) {
        opts = opts || {};
        if (session.version == null) {
          session.version = 0;
        }
        if (session.name == null) {
          session.name = " ";
        }
        session.media.forEach(function(mLine) {
          if (mLine.payloads == null) {
            mLine.payloads = "";
          }
        });
        var outerOrder = opts.outerOrder || defaultOuterOrder;
        var innerOrder = opts.innerOrder || defaultInnerOrder;
        var sdp = [];
        outerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in session && session[obj.name] != null) {
              sdp.push(makeLine(type, obj, session));
            } else if (obj.push in session && session[obj.push] != null) {
              session[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
        session.media.forEach(function(mLine) {
          sdp.push(makeLine("m", grammar.m[0], mLine));
          innerOrder.forEach(function(type) {
            grammar[type].forEach(function(obj) {
              if (obj.name in mLine && mLine[obj.name] != null) {
                sdp.push(makeLine(type, obj, mLine));
              } else if (obj.push in mLine && mLine[obj.push] != null) {
                mLine[obj.push].forEach(function(el) {
                  sdp.push(makeLine(type, obj, el));
                });
              }
            });
          });
        });
        return sdp.join("\r\n") + "\r\n";
      };
    }
  });

  // ../../node_modules/sdp-transform/lib/index.js
  var require_lib3 = __commonJS({
    "../../node_modules/sdp-transform/lib/index.js"(exports) {
      "use strict";
      var parser = require_parser();
      var writer = require_writer();
      exports.write = writer;
      exports.parse = parser.parse;
      exports.parseParams = parser.parseParams;
      exports.parseFmtpConfig = parser.parseFmtpConfig;
      exports.parsePayloads = parser.parsePayloads;
      exports.parseRemoteCandidates = parser.parseRemoteCandidates;
      exports.parseImageAttributes = parser.parseImageAttributes;
      exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js
  var require_commonUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
      var sdpTransform = __importStar(require_lib3());
      function extractRtpCapabilities({ sdpObject }) {
        const codecsMap = /* @__PURE__ */ new Map();
        const headerExtensions = [];
        let gotAudio = false;
        let gotVideo = false;
        for (const m of sdpObject.media) {
          const kind = m.type;
          switch (kind) {
            case "audio": {
              if (gotAudio) {
                continue;
              }
              gotAudio = true;
              break;
            }
            case "video": {
              if (gotVideo) {
                continue;
              }
              gotVideo = true;
              break;
            }
            default: {
              continue;
            }
          }
          for (const rtp of m.rtp) {
            const codec = {
              kind,
              mimeType: `${kind}/${rtp.codec}`,
              preferredPayloadType: rtp.payload,
              clockRate: rtp.rate,
              channels: rtp.encoding,
              parameters: {},
              rtcpFeedback: []
            };
            codecsMap.set(codec.preferredPayloadType, codec);
          }
          for (const fmtp of m.fmtp || []) {
            const parameters = sdpTransform.parseParams(fmtp.config);
            const codec = codecsMap.get(fmtp.payload);
            if (!codec) {
              continue;
            }
            if (parameters && parameters.hasOwnProperty("profile-level-id")) {
              parameters["profile-level-id"] = String(parameters["profile-level-id"]);
            }
            codec.parameters = parameters;
          }
          for (const fb of m.rtcpFb || []) {
            const feedback = {
              type: fb.type,
              parameter: fb.subtype
            };
            if (!feedback.parameter) {
              delete feedback.parameter;
            }
            if (fb.payload !== "*") {
              const codec = codecsMap.get(fb.payload);
              if (!codec) {
                continue;
              }
              codec.rtcpFeedback.push(feedback);
            } else {
              for (const codec of codecsMap.values()) {
                if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                  codec.rtcpFeedback.push(feedback);
                }
              }
            }
          }
          for (const ext of m.ext || []) {
            if (ext["encrypt-uri"]) {
              continue;
            }
            const headerExtension = {
              kind,
              uri: ext.uri,
              preferredId: ext.value
            };
            headerExtensions.push(headerExtension);
          }
        }
        const rtpCapabilities = {
          codecs: Array.from(codecsMap.values()),
          headerExtensions
        };
        return rtpCapabilities;
      }
      exports.extractRtpCapabilities = extractRtpCapabilities;
      function extractDtlsParameters({ sdpObject }) {
        let setup = sdpObject.setup;
        let fingerprint = sdpObject.fingerprint;
        if (!setup || !fingerprint) {
          const mediaObject = (sdpObject.media || []).find((m) => m.port !== 0);
          if (mediaObject) {
            setup ?? (setup = mediaObject.setup);
            fingerprint ?? (fingerprint = mediaObject.fingerprint);
          }
        }
        if (!setup) {
          throw new Error("no a=setup found at SDP session or media level");
        } else if (!fingerprint) {
          throw new Error("no a=fingerprint found at SDP session or media level");
        }
        let role;
        switch (setup) {
          case "active": {
            role = "client";
            break;
          }
          case "passive": {
            role = "server";
            break;
          }
          case "actpass": {
            role = "auto";
            break;
          }
        }
        const dtlsParameters = {
          role,
          fingerprints: [
            {
              algorithm: fingerprint.type,
              value: fingerprint.hash
            }
          ]
        };
        return dtlsParameters;
      }
      exports.extractDtlsParameters = extractDtlsParameters;
      function getCname({ offerMediaObject }) {
        const ssrcCnameLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          return "";
        }
        return ssrcCnameLine.value;
      }
      exports.getCname = getCname;
      function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
        for (const codec of offerRtpParameters.codecs) {
          const mimeType = codec.mimeType.toLowerCase();
          if (mimeType !== "audio/opus") {
            continue;
          }
          const rtp = (answerMediaObject.rtp || []).find((r) => r.payload === codec.payloadType);
          if (!rtp) {
            continue;
          }
          answerMediaObject.fmtp = answerMediaObject.fmtp || [];
          let fmtp = answerMediaObject.fmtp.find((f) => f.payload === codec.payloadType);
          if (!fmtp) {
            fmtp = { payload: codec.payloadType, config: "" };
            answerMediaObject.fmtp.push(fmtp);
          }
          const parameters = sdpTransform.parseParams(fmtp.config);
          switch (mimeType) {
            case "audio/opus": {
              const spropStereo = codec.parameters["sprop-stereo"];
              if (spropStereo !== void 0) {
                parameters.stereo = spropStereo ? 1 : 0;
              }
              break;
            }
          }
          fmtp.config = "";
          for (const key of Object.keys(parameters)) {
            if (fmtp.config) {
              fmtp.config += ";";
            }
            fmtp.config += `${key}=${parameters[key]}`;
          }
        }
      }
      exports.applyCodecParameters = applyCodecParameters;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js
  var require_unifiedPlanUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
      function getRtpEncodings({ offerMediaObject }) {
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          const ssrc = line.id;
          ssrcs.add(ssrc);
        }
        if (ssrcs.size === 0) {
          throw new Error("no a=ssrc lines found");
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      exports.getRtpEncodings = getRtpEncodings;
      function addLegacySimulcast({ offerMediaObject, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => line.attribute === "msid");
        if (!ssrcMsidLine) {
          throw new Error("a=ssrc line with msid information not found");
        }
        const [streamId, trackId] = ssrcMsidLine.value.split(" ");
        const firstSsrc = ssrcMsidLine.id;
        let firstRtxSsrc;
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname");
        if (!ssrcCnameLine) {
          throw new Error("a=ssrc line with cname information not found");
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = [];
        offerMediaObject.ssrcs = [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${trackId}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
      exports.addLegacySimulcast = addLegacySimulcast;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js
  var require_utils2 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/utils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addNackSuppportForOpus = void 0;
      function addNackSuppportForOpus(rtpCapabilities) {
        for (const codec of rtpCapabilities.codecs || []) {
          if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !codec.rtcpFeedback?.some((fb) => fb.type === "nack" && !fb.parameter)) {
            if (!codec.rtcpFeedback) {
              codec.rtcpFeedback = [];
            }
            codec.rtcpFeedback.push({ type: "nack" });
          }
        }
      }
      exports.addNackSuppportForOpus = addNackSuppportForOpus;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js
  var require_HandlerInterface = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HandlerInterface = void 0;
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var HandlerInterface = class extends EnhancedEventEmitter_1.EnhancedEventEmitter {
        constructor() {
          super();
        }
      };
      exports.HandlerInterface = HandlerInterface;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js
  var require_MediaSection = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
      var sdpTransform = __importStar(require_lib3());
      var utils = __importStar(require_utils());
      var MediaSection = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {
          this._mediaObject = {};
          this._planB = planB;
          if (iceParameters) {
            this.setIceParameters(iceParameters);
          }
          if (iceCandidates) {
            this._mediaObject.candidates = [];
            for (const candidate of iceCandidates) {
              const candidateObject = {};
              candidateObject.component = 1;
              candidateObject.foundation = candidate.foundation;
              candidateObject.ip = candidate.ip;
              candidateObject.port = candidate.port;
              candidateObject.priority = candidate.priority;
              candidateObject.transport = candidate.protocol;
              candidateObject.type = candidate.type;
              if (candidate.tcpType) {
                candidateObject.tcptype = candidate.tcpType;
              }
              this._mediaObject.candidates.push(candidateObject);
            }
            this._mediaObject.endOfCandidates = "end-of-candidates";
            this._mediaObject.iceOptions = "renomination";
          }
          if (dtlsParameters) {
            this.setDtlsRole(dtlsParameters.role);
          }
        }
        get mid() {
          return String(this._mediaObject.mid);
        }
        get closed() {
          return this._mediaObject.port === 0;
        }
        getObject() {
          return this._mediaObject;
        }
        setIceParameters(iceParameters) {
          this._mediaObject.iceUfrag = iceParameters.usernameFragment;
          this._mediaObject.icePwd = iceParameters.password;
        }
        pause() {
          this._mediaObject.direction = "inactive";
        }
        disable() {
          this.pause();
          delete this._mediaObject.ext;
          delete this._mediaObject.ssrcs;
          delete this._mediaObject.ssrcGroups;
          delete this._mediaObject.simulcast;
          delete this._mediaObject.simulcast_03;
          delete this._mediaObject.rids;
          delete this._mediaObject.extmapAllowMixed;
        }
        close() {
          this.disable();
          this._mediaObject.port = 0;
        }
      };
      exports.MediaSection = MediaSection;
      var AnswerMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(offerMediaObject.mid);
          this._mediaObject.type = offerMediaObject.type;
          this._mediaObject.protocol = offerMediaObject.protocol;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (offerMediaObject.type) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "recvonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              for (const codec of answerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const codecParameters = utils.clone(codec.parameters) ?? {};
                let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
                if (codecOptions) {
                  const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                  const offerCodec = offerRtpParameters.codecs.find((c) => c.payloadType === codec.payloadType);
                  switch (codec.mimeType.toLowerCase()) {
                    case "audio/opus":
                    case "audio/multiopus": {
                      if (opusStereo !== void 0) {
                        offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                        codecParameters.stereo = opusStereo ? 1 : 0;
                      }
                      if (opusFec !== void 0) {
                        offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                        codecParameters.useinbandfec = opusFec ? 1 : 0;
                      }
                      if (opusDtx !== void 0) {
                        offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                        codecParameters.usedtx = opusDtx ? 1 : 0;
                      }
                      if (opusMaxPlaybackRate !== void 0) {
                        codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                      }
                      if (opusMaxAverageBitrate !== void 0) {
                        codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                      }
                      if (opusPtime !== void 0) {
                        offerCodec.parameters.ptime = opusPtime;
                        codecParameters.ptime = opusPtime;
                      }
                      if (!opusNack) {
                        offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                        codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                      }
                      break;
                    }
                    case "video/vp8":
                    case "video/vp9":
                    case "video/h264":
                    case "video/h265": {
                      if (videoGoogleStartBitrate !== void 0) {
                        codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                      }
                      if (videoGoogleMaxBitrate !== void 0) {
                        codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                      }
                      if (videoGoogleMinBitrate !== void 0) {
                        codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                      }
                      break;
                    }
                  }
                }
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codecParameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codecParameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codecRtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of answerRtpParameters.headerExtensions) {
                const found = (offerMediaObject.ext || []).some((localExt) => localExt.uri === ext.uri);
                if (!found) {
                  continue;
                }
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              if (extmapAllowMixed && offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
                this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
              }
              if (offerMediaObject.simulcast) {
                this._mediaObject.simulcast = {
                  dir1: "recv",
                  list1: offerMediaObject.simulcast.list1
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids || []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              } else if (offerMediaObject.simulcast_03) {
                this._mediaObject.simulcast_03 = {
                  value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
                };
                this._mediaObject.rids = [];
                for (const rid of offerMediaObject.rids || []) {
                  if (rid.direction !== "send") {
                    continue;
                  }
                  this._mediaObject.rids.push({
                    id: rid.id,
                    direction: "recv"
                  });
                }
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              if (this._planB && this._mediaObject.type === "video") {
                this._mediaObject.xGoogleFlag = "conference";
              }
              break;
            }
            case "application": {
              if (typeof offerMediaObject.sctpPort === "number") {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else if (offerMediaObject.sctpmap) {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        setDtlsRole(role) {
          switch (role) {
            case "client": {
              this._mediaObject.setup = "active";
              break;
            }
            case "server": {
              this._mediaObject.setup = "passive";
              break;
            }
            case "auto": {
              this._mediaObject.setup = "actpass";
              break;
            }
          }
        }
        resume() {
          this._mediaObject.direction = "recvonly";
        }
        muxSimulcastStreams(encodings) {
          if (!this._mediaObject.simulcast || !this._mediaObject.simulcast.list1) {
            return;
          }
          const layers = {};
          for (const encoding of encodings) {
            if (encoding.rid) {
              layers[encoding.rid] = encoding;
            }
          }
          const raw = this._mediaObject.simulcast.list1;
          const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
          for (const simulcastStream of simulcastStreams) {
            for (const simulcastFormat of simulcastStream) {
              simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
            }
          }
          this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f) => `${f.paused ? "~" : ""}${f.scid}`).join(",")).join(";");
        }
      };
      exports.AnswerMediaSection = AnswerMediaSection;
      var OfferMediaSection = class extends MediaSection {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(mid);
          this._mediaObject.type = kind;
          if (!plainRtpParameters) {
            this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
            if (!sctpParameters) {
              this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
            } else {
              this._mediaObject.protocol = "UDP/DTLS/SCTP";
            }
            this._mediaObject.port = 7;
          } else {
            this._mediaObject.connection = {
              ip: plainRtpParameters.ip,
              version: plainRtpParameters.ipVersion
            };
            this._mediaObject.protocol = "RTP/AVP";
            this._mediaObject.port = plainRtpParameters.port;
          }
          switch (kind) {
            case "audio":
            case "video": {
              this._mediaObject.direction = "sendonly";
              this._mediaObject.rtp = [];
              this._mediaObject.rtcpFb = [];
              this._mediaObject.fmtp = [];
              if (!this._planB) {
                this._mediaObject.msid = `${streamId || "-"} ${trackId}`;
              }
              for (const codec of offerRtpParameters.codecs) {
                const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
                };
                if (codec.channels > 1) {
                  rtp.encoding = codec.channels;
                }
                this._mediaObject.rtp.push(rtp);
                const fmtp = {
                  payload: codec.payloadType,
                  config: ""
                };
                for (const key of Object.keys(codec.parameters)) {
                  if (fmtp.config) {
                    fmtp.config += ";";
                  }
                  fmtp.config += `${key}=${codec.parameters[key]}`;
                }
                if (fmtp.config) {
                  this._mediaObject.fmtp.push(fmtp);
                }
                for (const fb of codec.rtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                    payload: codec.payloadType,
                    type: fb.type,
                    subtype: fb.parameter
                  });
                }
              }
              this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
              this._mediaObject.ext = [];
              for (const ext of offerRtpParameters.headerExtensions) {
                this._mediaObject.ext.push({
                  uri: ext.uri,
                  value: ext.id
                });
              }
              this._mediaObject.rtcpMux = "rtcp-mux";
              this._mediaObject.rtcpRsize = "rtcp-rsize";
              const encoding = offerRtpParameters.encodings[0];
              const ssrc = encoding.ssrc;
              const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
              this._mediaObject.ssrcs = [];
              this._mediaObject.ssrcGroups = [];
              if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "cname",
                  value: offerRtpParameters.rtcp.cname
                });
              }
              if (this._planB) {
                this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: "msid",
                  value: `${streamId || "-"} ${trackId}`
                });
              }
              if (rtxSsrc) {
                if (offerRtpParameters.rtcp.cname) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "cname",
                    value: offerRtpParameters.rtcp.cname
                  });
                }
                if (this._planB) {
                  this._mediaObject.ssrcs.push({
                    id: rtxSsrc,
                    attribute: "msid",
                    value: `${streamId || "-"} ${trackId}`
                  });
                }
                this._mediaObject.ssrcGroups.push({
                  semantics: "FID",
                  ssrcs: `${ssrc} ${rtxSsrc}`
                });
              }
              break;
            }
            case "application": {
              if (!oldDataChannelSpec) {
                this._mediaObject.payloads = "webrtc-datachannel";
                this._mediaObject.sctpPort = sctpParameters.port;
                this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
              } else {
                this._mediaObject.payloads = sctpParameters.port;
                this._mediaObject.sctpmap = {
                  app: "webrtc-datachannel",
                  sctpmapNumber: sctpParameters.port,
                  maxMessageSize: sctpParameters.maxMessageSize
                };
              }
              break;
            }
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        setDtlsRole(role) {
          this._mediaObject.setup = "actpass";
        }
        resume() {
          this._mediaObject.direction = "sendonly";
        }
        planBReceive({ offerRtpParameters, streamId, trackId }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
          const payloads = this._mediaObject.payloads.split(" ");
          for (const codec of offerRtpParameters.codecs) {
            if (payloads.includes(String(codec.payloadType))) {
              continue;
            }
            const rtp = {
              payload: codec.payloadType,
              codec: getCodecName(codec),
              rate: codec.clockRate
            };
            if (codec.channels > 1) {
              rtp.encoding = codec.channels;
            }
            this._mediaObject.rtp.push(rtp);
            const fmtp = {
              payload: codec.payloadType,
              config: ""
            };
            for (const key of Object.keys(codec.parameters)) {
              if (fmtp.config) {
                fmtp.config += ";";
              }
              fmtp.config += `${key}=${codec.parameters[key]}`;
            }
            if (fmtp.config) {
              this._mediaObject.fmtp.push(fmtp);
            }
            for (const fb of codec.rtcpFeedback) {
              this._mediaObject.rtcpFb.push({
                payload: codec.payloadType,
                type: fb.type,
                subtype: fb.parameter
              });
            }
          }
          this._mediaObject.payloads += ` ${offerRtpParameters.codecs.filter((codec) => !this._mediaObject.payloads.includes(codec.payloadType)).map((codec) => codec.payloadType).join(" ")}`;
          this._mediaObject.payloads = this._mediaObject.payloads.trim();
          if (offerRtpParameters.rtcp.cname) {
            this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: "cname",
              value: offerRtpParameters.rtcp.cname
            });
          }
          this._mediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId || "-"} ${trackId}`
          });
          if (rtxSsrc) {
            if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: rtxSsrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
              });
            }
            this._mediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: "msid",
              value: `${streamId || "-"} ${trackId}`
            });
            this._mediaObject.ssrcGroups.push({
              semantics: "FID",
              ssrcs: `${ssrc} ${rtxSsrc}`
            });
          }
        }
        planBStopReceiving({ offerRtpParameters }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = encoding.rtx && encoding.rtx.ssrc ? encoding.rtx.ssrc : void 0;
          this._mediaObject.ssrcs = this._mediaObject.ssrcs.filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
          if (rtxSsrc) {
            this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups.filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
          }
        }
      };
      exports.OfferMediaSection = OfferMediaSection;
      function getCodecName(codec) {
        const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
        const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
        if (!mimeTypeMatch) {
          throw new TypeError("invalid codec.mimeType");
        }
        return mimeTypeMatch[2];
      }
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js
  var require_RemoteSdp = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RemoteSdp = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var MediaSection_1 = require_MediaSection();
      var logger12 = new Logger_1.Logger("RemoteSdp");
      var RemoteSdp = class {
        constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {
          this._mediaSections = [];
          this._midToIndex = /* @__PURE__ */ new Map();
          this._iceParameters = iceParameters;
          this._iceCandidates = iceCandidates;
          this._dtlsParameters = dtlsParameters;
          this._sctpParameters = sctpParameters;
          this._plainRtpParameters = plainRtpParameters;
          this._planB = planB;
          this._sdpObject = {
            version: 0,
            origin: {
              address: "0.0.0.0",
              ipVer: 4,
              netType: "IN",
              sessionId: 1e4,
              sessionVersion: 0,
              username: "mediasoup-client"
            },
            name: "-",
            timing: { start: 0, stop: 0 },
            media: []
          };
          if (iceParameters && iceParameters.iceLite) {
            this._sdpObject.icelite = "ice-lite";
          }
          if (dtlsParameters) {
            this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
            const numFingerprints = this._dtlsParameters.fingerprints.length;
            this._sdpObject.fingerprint = {
              type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
              hash: dtlsParameters.fingerprints[numFingerprints - 1].value
            };
            this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
          }
          if (plainRtpParameters) {
            this._sdpObject.origin.address = plainRtpParameters.ip;
            this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
          }
        }
        updateIceParameters(iceParameters) {
          logger12.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
          this._iceParameters = iceParameters;
          this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setIceParameters(iceParameters);
          }
        }
        updateDtlsRole(role) {
          logger12.debug("updateDtlsRole() [role:%s]", role);
          this._dtlsParameters.role = role;
          for (const mediaSection of this._mediaSections) {
            mediaSection.setDtlsRole(role);
          }
        }
        getNextMediaSectionIdx() {
          for (let idx = 0; idx < this._mediaSections.length; ++idx) {
            const mediaSection = this._mediaSections[idx];
            if (mediaSection.closed) {
              return { idx, reuseMid: mediaSection.mid };
            }
          }
          return { idx: this._mediaSections.length };
        }
        send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            plainRtpParameters: this._plainRtpParameters,
            planB: this._planB,
            offerMediaObject,
            offerRtpParameters,
            answerRtpParameters,
            codecOptions,
            extmapAllowMixed
          });
          if (reuseMid) {
            this._replaceMediaSection(mediaSection, reuseMid);
          } else if (!this._midToIndex.has(mediaSection.mid)) {
            this._addMediaSection(mediaSection);
          } else {
            this._replaceMediaSection(mediaSection);
          }
        }
        receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
          const idx = this._midToIndex.get(mid);
          let mediaSection;
          if (idx !== void 0) {
            mediaSection = this._mediaSections[idx];
          }
          if (!mediaSection) {
            mediaSection = new MediaSection_1.OfferMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              plainRtpParameters: this._plainRtpParameters,
              planB: this._planB,
              mid,
              kind,
              offerRtpParameters,
              streamId,
              trackId
            });
            const oldMediaSection = this._mediaSections.find((m) => m.closed);
            if (oldMediaSection) {
              this._replaceMediaSection(mediaSection, oldMediaSection.mid);
            } else {
              this._addMediaSection(mediaSection);
            }
          } else {
            mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
            this._replaceMediaSection(mediaSection);
          }
        }
        pauseMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.pause();
        }
        resumeSendingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        resumeReceivingMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.resume();
        }
        disableMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.disable();
        }
        /**
         * Closes media section. Returns true if the given MID corresponds to a m
         * section that has been indeed closed. False otherwise.
         *
         * NOTE: Closing the first m section is a pain since it invalidates the bundled
         * transport, so instead closing it we just disable it.
         */
        closeMediaSection(mid) {
          const mediaSection = this._findMediaSection(mid);
          if (mid === this._firstMid) {
            logger12.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
            this.disableMediaSection(mid);
            return false;
          }
          mediaSection.close();
          this._regenerateBundleMids();
          return true;
        }
        muxMediaSectionSimulcast(mid, encodings) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.muxSimulcastStreams(encodings);
          this._replaceMediaSection(mediaSection);
        }
        planBStopReceiving({ mid, offerRtpParameters }) {
          const mediaSection = this._findMediaSection(mid);
          mediaSection.planBStopReceiving({ offerRtpParameters });
          this._replaceMediaSection(mediaSection);
        }
        sendSctpAssociation({ offerMediaObject }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            offerMediaObject
          });
          this._addMediaSection(mediaSection);
        }
        receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
          const mediaSection = new MediaSection_1.OfferMediaSection({
            iceParameters: this._iceParameters,
            iceCandidates: this._iceCandidates,
            dtlsParameters: this._dtlsParameters,
            sctpParameters: this._sctpParameters,
            plainRtpParameters: this._plainRtpParameters,
            mid: "datachannel",
            kind: "application",
            oldDataChannelSpec
          });
          this._addMediaSection(mediaSection);
        }
        getSdp() {
          this._sdpObject.origin.sessionVersion++;
          return sdpTransform.write(this._sdpObject);
        }
        _addMediaSection(newMediaSection) {
          if (!this._firstMid) {
            this._firstMid = newMediaSection.mid;
          }
          this._mediaSections.push(newMediaSection);
          this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
          this._sdpObject.media.push(newMediaSection.getObject());
          this._regenerateBundleMids();
        }
        _replaceMediaSection(newMediaSection, reuseMid) {
          if (typeof reuseMid === "string") {
            const idx = this._midToIndex.get(reuseMid);
            if (idx === void 0) {
              throw new Error(`no media section found for reuseMid '${reuseMid}'`);
            }
            const oldMediaSection = this._mediaSections[idx];
            this._mediaSections[idx] = newMediaSection;
            this._midToIndex.delete(oldMediaSection.mid);
            this._midToIndex.set(newMediaSection.mid, idx);
            this._sdpObject.media[idx] = newMediaSection.getObject();
            this._regenerateBundleMids();
          } else {
            const idx = this._midToIndex.get(newMediaSection.mid);
            if (idx === void 0) {
              throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
            }
            this._mediaSections[idx] = newMediaSection;
            this._sdpObject.media[idx] = newMediaSection.getObject();
          }
        }
        _findMediaSection(mid) {
          const idx = this._midToIndex.get(mid);
          if (idx === void 0) {
            throw new Error(`no media section found with mid '${mid}'`);
          }
          return this._mediaSections[idx];
        }
        _regenerateBundleMids() {
          if (!this._dtlsParameters) {
            return;
          }
          this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
        }
      };
      exports.RemoteSdp = RemoteSdp;
    }
  });

  // ../../node_modules/mediasoup-client/lib/scalabilityModes.js
  var require_scalabilityModes = __commonJS({
    "../../node_modules/mediasoup-client/lib/scalabilityModes.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parse = void 0;
      var ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
      function parse(scalabilityMode) {
        const match = ScalabilityModeRegex.exec(scalabilityMode || "");
        if (match) {
          return {
            spatialLayers: Number(match[1]),
            temporalLayers: Number(match[2])
          };
        } else {
          return {
            spatialLayers: 1,
            temporalLayers: 1
          };
        }
      }
      exports.parse = parse;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome111.js
  var require_Chrome111 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome111.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome111 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome111");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome111 = class _Chrome111 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome111();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome111";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
            let nextRid = 1;
            let maxTemporalLayers = 1;
            for (const encoding of encodings) {
              const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
              if (temporalLayers > maxTemporalLayers) {
                maxTemporalLayers = temporalLayers;
              }
            }
            for (const encoding of encodings) {
              encoding.rid = `r${nextRid++}`;
              encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
            }
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome111 = Chrome111;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome74.js
  var require_Chrome74 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome74.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome74 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome74");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome74 = class _Chrome74 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome74();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome74";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
            this._pc.addEventListener("iceconnectionstatechange", () => {
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome74 = Chrome74;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome70.js
  var require_Chrome70 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome70.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome70 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Chrome70");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome70 = class _Chrome70 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome70();
        }
        constructor() {
          super();
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome70";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (encodings && encodings.length > 1) {
            logger12.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          if (encodings) {
            logger12.debug("send() | applying given encodings");
            const parameters = transceiver.sender.getParameters();
            for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {
              const encoding = parameters.encodings[idx];
              const desiredEncoding = encodings[idx];
              if (!desiredEncoding) {
                break;
              }
              parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
            }
            await transceiver.sender.setParameters(parameters);
          }
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (hackVp9Svc) {
            sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome70 = Chrome70;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js
  var require_planBUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
      function getRtpEncodings({ offerMediaObject, track }) {
        let firstSsrc;
        const ssrcs = /* @__PURE__ */ new Set();
        for (const line of offerMediaObject.ssrcs || []) {
          if (line.attribute !== "msid") {
            continue;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            const ssrc = line.id;
            ssrcs.add(ssrc);
            if (!firstSsrc) {
              firstSsrc = ssrc;
            }
          }
        }
        if (ssrcs.size === 0) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
        for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== "FID") {
            continue;
          }
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
            ssrcs.delete(ssrc);
            ssrcs.delete(rtxSsrc);
            ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
        }
        for (const ssrc of ssrcs) {
          ssrcToRtxSsrc.set(ssrc, null);
        }
        const encodings = [];
        for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc) {
            encoding.rtx = { ssrc: rtxSsrc };
          }
          encodings.push(encoding);
        }
        return encodings;
      }
      exports.getRtpEncodings = getRtpEncodings;
      function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
        if (numStreams <= 1) {
          throw new TypeError("numStreams must be greater than 1");
        }
        let firstSsrc;
        let firstRtxSsrc;
        let streamId;
        const ssrcMsidLine = (offerMediaObject.ssrcs || []).find((line) => {
          if (line.attribute !== "msid") {
            return false;
          }
          const trackId = line.value.split(" ")[1];
          if (trackId === track.id) {
            firstSsrc = line.id;
            streamId = line.value.split(" ")[0];
            return true;
          } else {
            return false;
          }
        });
        if (!ssrcMsidLine) {
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
        }
        (offerMediaObject.ssrcGroups || []).some((line) => {
          if (line.semantics !== "FID") {
            return false;
          }
          const ssrcs2 = line.ssrcs.split(/\s+/);
          if (Number(ssrcs2[0]) === firstSsrc) {
            firstRtxSsrc = Number(ssrcs2[1]);
            return true;
          } else {
            return false;
          }
        });
        const ssrcCnameLine = offerMediaObject.ssrcs.find((line) => line.attribute === "cname" && line.id === firstSsrc);
        if (!ssrcCnameLine) {
          throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
        }
        const cname = ssrcCnameLine.value;
        const ssrcs = [];
        const rtxSsrcs = [];
        for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc) {
            rtxSsrcs.push(firstRtxSsrc + i);
          }
        }
        offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
        offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
        offerMediaObject.ssrcGroups.push({
          semantics: "SIM",
          ssrcs: ssrcs.join(" ")
        });
        for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: ssrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
        }
        for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "cname",
            value: cname
          });
          offerMediaObject.ssrcs.push({
            id: rtxSsrc,
            attribute: "msid",
            value: `${streamId} ${track.id}`
          });
          offerMediaObject.ssrcGroups.push({
            semantics: "FID",
            ssrcs: `${ssrc} ${rtxSsrc}`
          });
        }
      }
      exports.addLegacySimulcast = addLegacySimulcast;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome67.js
  var require_Chrome67 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome67.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome67 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Chrome67");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome67 = class _Chrome67 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome67();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome67";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          this._pc.removeTrack(rtpSender);
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome67 = Chrome67;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Chrome55.js
  var require_Chrome55 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Chrome55.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Chrome55 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Chrome55");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Chrome55 = class _Chrome55 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Chrome55();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Chrome55";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError(" not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not supported");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const streamId = options.streamId || rtpParameters.rtcp.cname;
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Chrome55 = Chrome55;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Firefox60.js
  var require_Firefox60 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Firefox60.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Firefox60 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Firefox60");
      var SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
      var Firefox60 = class _Firefox60 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Firefox60();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Firefox60";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          const canvas = document.createElement("canvas");
          canvas.getContext("2d");
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
            pc.addTransceiver("audio", { direction: "sendrecv" });
            const videoTransceiver = pc.addTransceiver(fakeVideoTrack, {
              direction: "sendrecv"
            });
            const parameters = videoTransceiver.sender.getParameters();
            const encodings = [
              { rid: "r0", maxBitrate: 1e5 },
              { rid: "r1", maxBitrate: 5e5 }
            ];
            parameters.encodings = encodings;
            await videoTransceiver.sender.setParameters(parameters);
            const offer = await pc.createOffer();
            try {
              canvas.remove();
            } catch (error) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error) {
            }
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              canvas.remove();
            } catch (error2) {
            }
            try {
              fakeVideoTrack.stop();
            } catch (error2) {
            }
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings) {
            encodings = utils.clone(encodings);
            if (encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                encoding.rid = `r${idx}`;
              });
              encodings.reverse();
            }
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          if (encodings) {
            const parameters = transceiver.sender.getParameters();
            parameters.encodings = encodings;
            await transceiver.sender.setParameters(parameters);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings.reverse();
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          if (this._closed) {
            return;
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.disableMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated transceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          spatialLayer = parameters.encodings.length - 1 - spatialLayer;
          parameters.encodings.forEach((encoding, idx) => {
            if (idx >= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
            answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({ localDtlsRole: "client", localSdpObject });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Firefox60 = Firefox60;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari12.js
  var require_Safari12 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari12.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari12 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("Safari12");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari12 = class _Safari12 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari12();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Safari12";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream]
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length > 1) {
            logger12.debug("send() | enabling legacy simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          this._remoteSdp.resumeSendingMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            }
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari12 = Safari12;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Safari11.js
  var require_Safari11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Safari11.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Safari11 = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("Safari11");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var Safari11 = class _Safari11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Safari11();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdRtpSender = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Safari11";
        }
        close() {
          logger12.debug("close()");
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8") {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders().find((s) => s.track === track);
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          if (rtpSender.track) {
            this._sendStream.removeTrack(rtpSender.track);
          }
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          if (oldTrack) {
            this._sendStream.removeTrack(oldTrack);
          }
          if (track) {
            this._sendStream.addTrack(track);
          }
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          this.assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender) {
            throw new Error("associated RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const mid = kind;
            const localId = trackId;
            const rtpReceiver = this._pc.getReceivers().find((r) => r.track && r.track.id === localId);
            if (!rtpReceiver) {
              throw new Error("new RTCRtpReceiver not");
            }
            this._mapRecvLocalIdInfo.set(localId, {
              mid,
              rtpParameters,
              rtpReceiver
            });
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver) {
            throw new Error("associated RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.Safari11 = Safari11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js
  var require_edgeUtils = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.mangleRtpParameters = exports.getCapabilities = void 0;
      var utils = __importStar(require_utils());
      function getCapabilities() {
        const nativeCaps = RTCRtpReceiver.getCapabilities();
        const caps = utils.clone(nativeCaps);
        for (const codec of caps.codecs ?? []) {
          codec.channels = codec.numChannels;
          delete codec.numChannels;
          codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
          if (codec.parameters) {
            const parameters = codec.parameters;
            if (parameters.apt) {
              parameters.apt = Number(parameters.apt);
            }
            if (parameters["packetization-mode"]) {
              parameters["packetization-mode"] = Number(parameters["packetization-mode"]);
            }
          }
          for (const feedback of codec.rtcpFeedback || []) {
            if (!feedback.parameter) {
              feedback.parameter = "";
            }
          }
        }
        return caps;
      }
      exports.getCapabilities = getCapabilities;
      function mangleRtpParameters(rtpParameters) {
        const params = utils.clone(rtpParameters);
        if (params.mid) {
          params.muxId = params.mid;
          delete params.mid;
        }
        for (const codec of params.codecs) {
          if (codec.channels) {
            codec.numChannels = codec.channels;
            delete codec.channels;
          }
          if (codec.mimeType && !codec.name) {
            codec.name = codec.mimeType.split("/")[1];
          }
          delete codec.mimeType;
        }
        return params;
      }
      exports.mangleRtpParameters = mangleRtpParameters;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/Edge11.js
  var require_Edge11 = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/Edge11.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Edge11 = void 0;
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var edgeUtils = __importStar(require_edgeUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var logger12 = new Logger_1.Logger("Edge11");
      var Edge11 = class _Edge11 extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _Edge11();
        }
        constructor() {
          super();
          this._rtpSenders = /* @__PURE__ */ new Map();
          this._rtpReceivers = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._transportReady = false;
        }
        get name() {
          return "Edge11";
        }
        close() {
          logger12.debug("close()");
          try {
            this._iceGatherer.close();
          } catch (error) {
          }
          try {
            this._iceTransport.stop();
          } catch (error) {
          }
          try {
            this._dtlsTransport.stop();
          } catch (error) {
          }
          for (const rtpSender of this._rtpSenders.values()) {
            try {
              rtpSender.stop();
            } catch (error) {
            }
          }
          for (const rtpReceiver of this._rtpReceivers.values()) {
            try {
              rtpReceiver.stop();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          return edgeUtils.getCapabilities();
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: { OS: 0, MIS: 0 }
          };
        }
        run({
          direction,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          proprietaryConstraints,
          // eslint-disable-line @typescript-eslint/no-unused-vars
          extendedRtpCapabilities
        }) {
          logger12.debug("run()");
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._remoteIceParameters = iceParameters;
          this._remoteIceCandidates = iceCandidates;
          this._remoteDtlsParameters = dtlsParameters;
          this._cname = `CNAME-${utils.generateRandomNumber()}`;
          this.setIceGatherer({ iceServers, iceTransportPolicy });
          this.setIceTransport();
          this.setDtlsTransport();
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async updateIceServers(iceServers) {
          throw new errors_1.UnsupportedError("not supported");
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteIceParameters = iceParameters;
          if (!this._transportReady) {
            return;
          }
          logger12.debug("restartIce() | calling iceTransport.start()");
          this._iceTransport.start(this._iceGatherer, iceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
        }
        async getTransportStats() {
          return this._iceTransport.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          logger12.debug("send() | calling new RTCRtpSender()");
          const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
          const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
          const useRtx = rtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
          if (!encodings) {
            encodings = [{}];
          }
          for (const encoding of encodings) {
            encoding.ssrc = utils.generateRandomNumber();
            if (useRtx) {
              encoding.rtx = { ssrc: utils.generateRandomNumber() };
            }
          }
          rtpParameters.encodings = encodings;
          rtpParameters.rtcp = {
            cname: this._cname,
            reducedSize: true,
            mux: true
          };
          const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
          logger12.debug("send() | calling rtpSender.send() [params:%o]", edgeRtpParameters);
          await rtpSender.send(edgeRtpParameters);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._rtpSenders.set(localId, rtpSender);
          return { localId, rtpParameters, rtpSender };
        }
        async stopSending(localId) {
          logger12.debug("stopSending() [localId:%s]", localId);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          this._rtpSenders.delete(localId);
          try {
            logger12.debug("stopSending() | calling rtpSender.stop()");
            rtpSender.stop();
          } catch (error) {
            logger12.warn("stopSending() | rtpSender.stop() failed:%o", error);
            throw error;
          }
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          rtpSender.setTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await rtpSender.setParameters(parameters);
        }
        async setRtpEncodingParameters(localId, params) {
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await rtpSender.setParameters(parameters);
        }
        async getSenderStats(localId) {
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender) {
            throw new Error("RTCRtpSender not found");
          }
          return rtpSender.getStats();
        }
        async sendDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receive(optionsList) {
          const results = [];
          for (const options of optionsList) {
            const { trackId, kind } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          }
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "server" });
          }
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger12.debug("receive() | calling new RTCRtpReceiver()");
            const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
            rtpReceiver.addEventListener("error", (event) => {
              logger12.error('rtpReceiver "error" event [event:%o]', event);
            });
            const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
            logger12.debug("receive() | calling rtpReceiver.receive() [params:%o]", edgeRtpParameters);
            await rtpReceiver.receive(edgeRtpParameters);
            const localId = trackId;
            this._rtpReceivers.set(localId, rtpReceiver);
            results.push({
              localId,
              track: rtpReceiver.track,
              rtpReceiver
            });
          }
          return results;
        }
        async stopReceiving(localIds) {
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const rtpReceiver = this._rtpReceivers.get(localId);
            if (!rtpReceiver) {
              throw new Error("RTCRtpReceiver not found");
            }
            this._rtpReceivers.delete(localId);
            try {
              logger12.debug("stopReceiving() | calling rtpReceiver.stop()");
              rtpReceiver.stop();
            } catch (error) {
              logger12.warn("stopReceiving() | rtpReceiver.stop() failed:%o", error);
            }
          }
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        async getReceiverStats(localId) {
          const rtpReceiver = this._rtpReceivers.get(localId);
          if (!rtpReceiver) {
            throw new Error("RTCRtpReceiver not found");
          }
          return rtpReceiver.getStats();
        }
        async receiveDataChannel(options) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        setIceGatherer({ iceServers, iceTransportPolicy }) {
          const iceGatherer = new RTCIceGatherer({
            iceServers: iceServers || [],
            gatherPolicy: iceTransportPolicy || "all"
          });
          iceGatherer.addEventListener("error", (event) => {
            logger12.error('iceGatherer "error" event [event:%o]', event);
          });
          try {
            iceGatherer.gather();
          } catch (error) {
            logger12.debug("setIceGatherer() | iceGatherer.gather() failed: %s", error.toString());
          }
          this._iceGatherer = iceGatherer;
        }
        setIceTransport() {
          const iceTransport = new RTCIceTransport(this._iceGatherer);
          iceTransport.addEventListener("statechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("icestatechange", () => {
            switch (iceTransport.state) {
              case "checking": {
                this.emit("@connectionstatechange", "connecting");
                break;
              }
              case "connected":
              case "completed": {
                this.emit("@connectionstatechange", "connected");
                break;
              }
              case "failed": {
                this.emit("@connectionstatechange", "failed");
                break;
              }
              case "disconnected": {
                this.emit("@connectionstatechange", "disconnected");
                break;
              }
              case "closed": {
                this.emit("@connectionstatechange", "closed");
                break;
              }
            }
          });
          iceTransport.addEventListener("candidatepairchange", (event) => {
            logger12.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
          });
          this._iceTransport = iceTransport;
        }
        setDtlsTransport() {
          const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
          dtlsTransport.addEventListener("statechange", () => {
            logger12.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
          });
          dtlsTransport.addEventListener("dtlsstatechange", () => {
            logger12.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
            if (dtlsTransport.state === "closed") {
              this.emit("@connectionstatechange", "closed");
            }
          });
          dtlsTransport.addEventListener("error", (event) => {
            logger12.error('dtlsTransport "error" event [event:%o]', event);
          });
          this._dtlsTransport = dtlsTransport;
        }
        async setupTransport({ localDtlsRole }) {
          logger12.debug("setupTransport()");
          const dtlsParameters = this._dtlsTransport.getLocalParameters();
          dtlsParameters.role = localDtlsRole;
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, "controlling");
          for (const candidate of this._remoteIceCandidates) {
            this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
          this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints.filter((fingerprint) => {
            return fingerprint.algorithm === "sha-256" || fingerprint.algorithm === "sha-384" || fingerprint.algorithm === "sha-512";
          });
          this._dtlsTransport.start(this._remoteDtlsParameters);
          this._transportReady = true;
        }
      };
      exports.Edge11 = Edge11;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js
  var require_ReactNativeUnifiedPlan = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNativeUnifiedPlan.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNativeUnifiedPlan = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpUnifiedPlanUtils = __importStar(require_unifiedPlanUtils());
      var ortcUtils = __importStar(require_utils2());
      var errors_1 = require_errors();
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var scalabilityModes_1 = require_scalabilityModes();
      var logger12 = new Logger_1.Logger("ReactNativeUnifiedPlan");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNativeUnifiedPlan = class _ReactNativeUnifiedPlan extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNativeUnifiedPlan();
        }
        constructor() {
          super();
          this._closed = false;
          this._mapMidTransceiver = /* @__PURE__ */ new Map();
          this._sendStream = new MediaStream();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "ReactNativeUnifiedPlan";
        }
        close() {
          logger12.debug("close()");
          if (this._closed) {
            return;
          }
          this._closed = true;
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan"
          });
          try {
            pc.addTransceiver("audio");
            pc.addTransceiver("video");
            const offer = await pc.createOffer();
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            ortcUtils.addNackSuppportForOpus(nativeRtpCapabilities);
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          this.assertNotClosed();
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "unified-plan",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          this.assertNotClosed();
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          this.assertNotClosed();
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          this.assertNotClosed();
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (encodings && encodings.length > 1) {
            encodings.forEach((encoding, idx) => {
              encoding.rid = `r${idx}`;
            });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
            direction: "sendonly",
            streams: [this._sendStream],
            sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          let hackVp9Svc = false;
          const layers = (0, scalabilityModes_1.parse)((encodings || [{}])[0].scalabilityMode);
          if (encodings && encodings.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
            logger12.debug("send() | enabling legacy simulcast for VP9 SVC");
            hackVp9Svc = true;
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
            sdpUnifiedPlanUtils.addLegacySimulcast({
              offerMediaObject,
              numStreams: layers.spatialLayers
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          let localId = transceiver.mid ?? void 0;
          if (!localId) {
            logger12.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
          }
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          if (!encodings) {
            sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
          } else if (encodings.length === 1) {
            let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
              offerMediaObject
            });
            Object.assign(newEncodings[0], encodings[0]);
            if (hackVp9Svc) {
              newEncodings = [newEncodings[0]];
            }
            sendingRtpParameters.encodings = newEncodings;
          } else {
            sendingRtpParameters.encodings = encodings;
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              if (encoding.scalabilityMode) {
                encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
              } else {
                encoding.scalabilityMode = "L1T3";
              }
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            reuseMid: mediaSectionIdx.reuseMid,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions,
            extmapAllowMixed: true
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          if (!localId) {
            localId = transceiver.mid;
            sendingRtpParameters.mid = localId;
          }
          this._mapMidTransceiver.set(localId, transceiver);
          return {
            localId,
            rtpParameters: sendingRtpParameters,
            rtpSender: transceiver.sender
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          if (this._closed) {
            return;
          }
          logger12.debug("stopSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
          if (mediaSectionClosed) {
            try {
              transceiver.stop();
            } catch (error) {
            }
          }
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._mapMidTransceiver.delete(localId);
        }
        async pauseSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("pauseSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
          const offer = await this._pc.createOffer();
          logger12.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async resumeSending(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("resumeSending() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          this._remoteSdp.resumeSendingMediaSection(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "sendonly";
          const offer = await this._pc.createOffer();
          logger12.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async replaceTrack(localId, track) {
          this.assertNotClosed();
          this.assertSendDirection();
          if (track) {
            logger12.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
          } else {
            logger12.debug("replaceTrack() [localId:%s, no track]", localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          await transceiver.sender.replaceTrack(track);
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            if (idx <= spatialLayer) {
              encoding.active = true;
            } else {
              encoding.active = false;
            }
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async setRtpEncodingParameters(localId, params) {
          this.assertNotClosed();
          this.assertSendDirection();
          logger12.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
            parameters.encodings[idx] = { ...encoding, ...params };
          });
          await transceiver.sender.setParameters(parameters);
          this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
          const offer = await this._pc.createOffer();
          logger12.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        async getSenderStats(localId) {
          this.assertNotClosed();
          this.assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.sender.getStats();
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertNotClosed();
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const results = [];
          const mapLocalId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters, streamId } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
            mapLocalId.set(trackId, localId);
            this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: streamId || rtpParameters.rtcp.cname,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { trackId, rtpParameters } = options;
            const localId = mapLocalId.get(trackId);
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === localId);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { trackId } = options;
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t) => t.mid === localId);
            if (!transceiver) {
              throw new Error("new RTCRtpTransceiver not found");
            } else {
              this._mapMidTransceiver.set(localId, transceiver);
              results.push({
                localId,
                track: transceiver.receiver.track,
                rtpReceiver: transceiver.receiver
              });
            }
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          if (this._closed) {
            return;
          }
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            this._remoteSdp.closeMediaSection(transceiver.mid);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const localId of localIds) {
            this._mapMidTransceiver.delete(localId);
          }
        }
        async pauseReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("pauseReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "inactive";
            this._remoteSdp.pauseMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async resumeReceiving(localIds) {
          this.assertNotClosed();
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("resumeReceiving() [localId:%s]", localId);
            const transceiver = this._mapMidTransceiver.get(localId);
            if (!transceiver) {
              throw new Error("associated RTCRtpTransceiver not found");
            }
            transceiver.direction = "recvonly";
            this._remoteSdp.resumeReceivingMediaSection(localId);
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async getReceiverStats(localId) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          return transceiver.receiver.getStats();
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertNotClosed();
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation();
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertNotClosed() {
          if (this._closed) {
            throw new errors_1.InvalidStateError("method called in a closed handler");
          }
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNativeUnifiedPlan = ReactNativeUnifiedPlan;
    }
  });

  // ../../node_modules/mediasoup-client/lib/handlers/ReactNative.js
  var require_ReactNative = __commonJS({
    "../../node_modules/mediasoup-client/lib/handlers/ReactNative.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReactNative = void 0;
      var sdpTransform = __importStar(require_lib3());
      var Logger_1 = require_Logger();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var sdpCommonUtils = __importStar(require_commonUtils());
      var sdpPlanBUtils = __importStar(require_planBUtils());
      var HandlerInterface_1 = require_HandlerInterface();
      var RemoteSdp_1 = require_RemoteSdp();
      var logger12 = new Logger_1.Logger("ReactNative");
      var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
      var ReactNative = class _ReactNative extends HandlerInterface_1.HandlerInterface {
        /**
         * Creates a factory function.
         */
        static createFactory() {
          return () => new _ReactNative();
        }
        constructor() {
          super();
          this._sendStream = new MediaStream();
          this._mapSendLocalIdTrack = /* @__PURE__ */ new Map();
          this._nextSendLocalId = 0;
          this._mapRecvLocalIdInfo = /* @__PURE__ */ new Map();
          this._hasDataChannelMediaSection = false;
          this._nextSendSctpStreamId = 0;
          this._transportReady = false;
        }
        get name() {
          return "ReactNative";
        }
        close() {
          logger12.debug("close()");
          this._sendStream.release(
            /* releaseTracks */
            false
          );
          if (this._pc) {
            try {
              this._pc.close();
            } catch (error) {
            }
          }
          this.emit("@close");
        }
        async getNativeRtpCapabilities() {
          logger12.debug("getNativeRtpCapabilities()");
          const pc = new RTCPeerConnection({
            iceServers: [],
            iceTransportPolicy: "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b"
          });
          try {
            const offer = await pc.createOffer({
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            });
            try {
              pc.close();
            } catch (error) {
            }
            const sdpObject = sdpTransform.parse(offer.sdp);
            const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
              sdpObject
            });
            return nativeRtpCapabilities;
          } catch (error) {
            try {
              pc.close();
            } catch (error2) {
            }
            throw error;
          }
        }
        async getNativeSctpCapabilities() {
          logger12.debug("getNativeSctpCapabilities()");
          return {
            numStreams: SCTP_NUM_STREAMS
          };
        }
        run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger12.debug("run()");
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            planB: true
          });
          this._sendingRtpParametersByKind = {
            audio: ortc.getSendingRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRtpParameters("video", extendedRtpCapabilities)
          };
          this._sendingRemoteRtpParametersByKind = {
            audio: ortc.getSendingRemoteRtpParameters("audio", extendedRtpCapabilities),
            video: ortc.getSendingRemoteRtpParameters("video", extendedRtpCapabilities)
          };
          if (dtlsParameters.role && dtlsParameters.role !== "auto") {
            this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
          }
          this._pc = new RTCPeerConnection({
            iceServers: iceServers || [],
            iceTransportPolicy: iceTransportPolicy || "all",
            bundlePolicy: "max-bundle",
            rtcpMuxPolicy: "require",
            sdpSemantics: "plan-b",
            ...additionalSettings
          }, proprietaryConstraints);
          this._pc.addEventListener("icegatheringstatechange", () => {
            this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
          });
          if (this._pc.connectionState) {
            this._pc.addEventListener("connectionstatechange", () => {
              this.emit("@connectionstatechange", this._pc.connectionState);
            });
          } else {
            this._pc.addEventListener("iceconnectionstatechange", () => {
              logger12.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
              switch (this._pc.iceConnectionState) {
                case "checking": {
                  this.emit("@connectionstatechange", "connecting");
                  break;
                }
                case "connected":
                case "completed": {
                  this.emit("@connectionstatechange", "connected");
                  break;
                }
                case "failed": {
                  this.emit("@connectionstatechange", "failed");
                  break;
                }
                case "disconnected": {
                  this.emit("@connectionstatechange", "disconnected");
                  break;
                }
                case "closed": {
                  this.emit("@connectionstatechange", "closed");
                  break;
                }
              }
            });
          }
        }
        async updateIceServers(iceServers) {
          logger12.debug("updateIceServers()");
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
        }
        async restartIce(iceParameters) {
          logger12.debug("restartIce()");
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady) {
            return;
          }
          if (this._direction === "send") {
            const offer = await this._pc.createOffer({ iceRestart: true });
            logger12.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
          } else {
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            logger12.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
          }
        }
        async getTransportStats() {
          return this._pc.getStats();
        }
        async send({ track, encodings, codecOptions, codec }) {
          this.assertSendDirection();
          logger12.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
          if (codec) {
            logger12.warn("send() | codec selection is not available in %s handler", this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind]);
          sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind]);
          sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          if (track.kind === "video" && encodings && encodings.length > 1) {
            logger12.debug("send() | enabling simulcast");
            localSdpObject = sdpTransform.parse(offer.sdp);
            offerMediaObject = localSdpObject.media.find((m) => m.type === "video");
            sdpPlanBUtils.addLegacySimulcast({
              offerMediaObject,
              track,
              numStreams: encodings.length
            });
            offer = { type: "offer", sdp: sdpTransform.write(localSdpObject) };
          }
          logger12.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media.find((m) => m.type === track.kind);
          sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
            offerMediaObject
          });
          sendingRtpParameters.encodings = sdpPlanBUtils.getRtpEncodings({
            offerMediaObject,
            track
          });
          if (encodings) {
            for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
              if (encodings[idx]) {
                Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
            }
          }
          if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
            for (const encoding of sendingRtpParameters.encodings) {
              encoding.scalabilityMode = "L1T3";
            }
          }
          this._remoteSdp.send({
            offerMediaObject,
            offerRtpParameters: sendingRtpParameters,
            answerRtpParameters: sendingRemoteRtpParameters,
            codecOptions
          });
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          this._mapSendLocalIdTrack.set(localId, track);
          return {
            localId,
            rtpParameters: sendingRtpParameters
          };
        }
        async stopSending(localId) {
          this.assertSendDirection();
          logger12.debug("stopSending() [localId:%s]", localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track) {
            throw new Error("track not found");
          }
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger12.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
          try {
            await this._pc.setLocalDescription(offer);
          } catch (error) {
            if (this._sendStream.getTracks().length === 0) {
              logger12.warn("stopSending() | ignoring expected error due no sending tracks: %s", error.toString());
              return;
            }
            throw error;
          }
          if (this._pc.signalingState === "stable") {
            return;
          }
          const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async pauseSending(localId) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async resumeSending(localId) {
        }
        async replaceTrack(localId, track) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getSenderStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this.assertSendDirection();
          const options = {
            negotiated: true,
            id: this._nextSendSctpStreamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("sendDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          if (!this._hasDataChannelMediaSection) {
            const offer = await this._pc.createOffer();
            const localSdpObject = sdpTransform.parse(offer.sdp);
            const offerMediaObject = localSdpObject.media.find((m) => m.type === "application");
            if (!this._transportReady) {
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
            await this._pc.setLocalDescription(offer);
            this._remoteSdp.sendSctpAssociation({ offerMediaObject });
            const answer = { type: "answer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setRemoteDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
            streamId: options.id,
            ordered: options.ordered,
            maxPacketLifeTime: options.maxPacketLifeTime,
            maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
        }
        async receive(optionsList) {
          this.assertRecvDirection();
          const results = [];
          const mapStreamId = /* @__PURE__ */ new Map();
          for (const options of optionsList) {
            const { trackId, kind, rtpParameters } = options;
            logger12.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
            const mid = kind;
            let streamId = options.streamId || rtpParameters.rtcp.cname;
            logger12.debug("receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc");
            streamId += `-hack-${utils.generateRandomNumber()}`;
            mapStreamId.set(trackId, streamId);
            this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId,
              trackId
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          for (const options of optionsList) {
            const { kind, rtpParameters } = options;
            const mid = kind;
            const answerMediaObject = localSdpObject.media.find((m) => String(m.mid) === mid);
            sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
            });
          }
          answer = { type: "answer", sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger12.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          for (const options of optionsList) {
            const { kind, trackId, rtpParameters } = options;
            const localId = trackId;
            const mid = kind;
            const streamId = mapStreamId.get(trackId);
            const stream = this._pc.getRemoteStreams().find((s) => s.id === streamId);
            const track = stream.getTrackById(localId);
            if (!track) {
              throw new Error("remote track not found");
            }
            this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
            results.push({ localId, track });
          }
          return results;
        }
        async stopReceiving(localIds) {
          this.assertRecvDirection();
          for (const localId of localIds) {
            logger12.debug("stopReceiving() [localId:%s]", localId);
            const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
            this._mapRecvLocalIdInfo.delete(localId);
            this._remoteSdp.planBStopReceiving({
              mid,
              offerRtpParameters: rtpParameters
            });
          }
          const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
          logger12.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger12.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
        async pauseReceiving(localIds) {
        }
        async resumeReceiving(localIds) {
        }
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError("not implemented");
        }
        async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this.assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
            negotiated: true,
            id: streamId,
            ordered,
            maxPacketLifeTime,
            maxRetransmitTime: maxPacketLifeTime,
            // NOTE: Old spec.
            maxRetransmits,
            protocol
          };
          logger12.debug("receiveDataChannel() [options:%o]", options);
          const dataChannel = this._pc.createDataChannel(label, options);
          if (!this._hasDataChannelMediaSection) {
            this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
            const offer = { type: "offer", sdp: this._remoteSdp.getSdp() };
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
            await this._pc.setRemoteDescription(offer);
            const answer = await this._pc.createAnswer();
            if (!this._transportReady) {
              const localSdpObject = sdpTransform.parse(answer.sdp);
              await this.setupTransport({
                localDtlsRole: this._forcedLocalDtlsRole ?? "client",
                localSdpObject
              });
            }
            logger12.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
            await this._pc.setLocalDescription(answer);
            this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
        }
        async setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject) {
            localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          }
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
            sdpObject: localSdpObject
          });
          dtlsParameters.role = localDtlsRole;
          this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
          await new Promise((resolve, reject) => {
            this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
          });
          this._transportReady = true;
        }
        assertSendDirection() {
          if (this._direction !== "send") {
            throw new Error('method can just be called for handlers with "send" direction');
          }
        }
        assertRecvDirection() {
          if (this._direction !== "recv") {
            throw new Error('method can just be called for handlers with "recv" direction');
          }
        }
      };
      exports.ReactNative = ReactNative;
    }
  });

  // ../../node_modules/mediasoup-client/lib/Device.js
  var require_Device = __commonJS({
    "../../node_modules/mediasoup-client/lib/Device.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Device = exports.detectDevice = void 0;
      var ua_parser_js_1 = require_ua_parser();
      var Logger_1 = require_Logger();
      var EnhancedEventEmitter_1 = require_EnhancedEventEmitter();
      var errors_1 = require_errors();
      var utils = __importStar(require_utils());
      var ortc = __importStar(require_ortc());
      var Transport_1 = require_Transport();
      var Chrome111_1 = require_Chrome111();
      var Chrome74_1 = require_Chrome74();
      var Chrome70_1 = require_Chrome70();
      var Chrome67_1 = require_Chrome67();
      var Chrome55_1 = require_Chrome55();
      var Firefox60_1 = require_Firefox60();
      var Safari12_1 = require_Safari12();
      var Safari11_1 = require_Safari11();
      var Edge11_1 = require_Edge11();
      var ReactNativeUnifiedPlan_1 = require_ReactNativeUnifiedPlan();
      var ReactNative_1 = require_ReactNative();
      var logger12 = new Logger_1.Logger("Device");
      function detectDevice2() {
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          logger12.debug("detectDevice() | React-Native detected");
          if (typeof RTCPeerConnection === "undefined") {
            logger12.warn("detectDevice() | unsupported react-native-webrtc without RTCPeerConnection, forgot to call registerGlobals()?");
            return void 0;
          }
          if (typeof RTCRtpTransceiver !== "undefined") {
            logger12.debug("detectDevice() | ReactNative UnifiedPlan handler chosen");
            return "ReactNativeUnifiedPlan";
          } else {
            logger12.debug("detectDevice() | ReactNative PlanB handler chosen");
            return "ReactNative";
          }
        } else if (typeof navigator === "object" && typeof navigator.userAgent === "string") {
          const ua = navigator.userAgent;
          const uaParser = new ua_parser_js_1.UAParser(ua);
          logger12.debug("detectDevice() | browser detected [ua:%s, parsed:%o]", ua, uaParser.getResult());
          const browser = uaParser.getBrowser();
          const browserName = browser.name?.toLowerCase();
          const browserVersion = parseInt(browser.major ?? "0");
          const engine = uaParser.getEngine();
          const engineName = engine.name?.toLowerCase();
          const os = uaParser.getOS();
          const osName = os.name?.toLowerCase();
          const osVersion = parseFloat(os.version ?? "0");
          const device = uaParser.getDevice();
          const deviceModel = device.model?.toLowerCase();
          const isIOS = osName === "ios" || deviceModel === "ipad";
          const isChrome = browserName && [
            "chrome",
            "chromium",
            "mobile chrome",
            "chrome webview",
            "chrome headless"
          ].includes(browserName);
          const isFirefox = browserName && ["firefox", "mobile firefox", "mobile focus"].includes(browserName);
          const isSafari = browserName && ["safari", "mobile safari"].includes(browserName);
          const isEdge = browserName && ["edge"].includes(browserName);
          if ((isChrome || isEdge) && !isIOS && browserVersion >= 111) {
            return "Chrome111";
          } else if (isChrome && !isIOS && browserVersion >= 74 || isEdge && !isIOS && browserVersion >= 88) {
            return "Chrome74";
          } else if (isChrome && !isIOS && browserVersion >= 70) {
            return "Chrome70";
          } else if (isChrome && !isIOS && browserVersion >= 67) {
            return "Chrome67";
          } else if (isChrome && !isIOS && browserVersion >= 55) {
            return "Chrome55";
          } else if (isFirefox && !isIOS && browserVersion >= 60) {
            return "Firefox60";
          } else if (isFirefox && isIOS && osVersion >= 14.3) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 12 && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (isSafari && browserVersion >= 11) {
            return "Safari11";
          } else if (isEdge && !isIOS && browserVersion >= 11 && browserVersion <= 18) {
            return "Edge11";
          } else if (engineName === "webkit" && isIOS && typeof RTCRtpTransceiver !== "undefined" && RTCRtpTransceiver.prototype.hasOwnProperty("currentDirection")) {
            return "Safari12";
          } else if (engineName === "blink") {
            const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
            if (match) {
              const version = Number(match[1]);
              if (version >= 111) {
                return "Chrome111";
              } else if (version >= 74) {
                return "Chrome74";
              } else if (version >= 70) {
                return "Chrome70";
              } else if (version >= 67) {
                return "Chrome67";
              } else {
                return "Chrome55";
              }
            } else {
              return "Chrome111";
            }
          } else {
            logger12.warn("detectDevice() | browser not supported [name:%s, version:%s]", browserName, browserVersion);
            return void 0;
          }
        } else {
          logger12.warn("detectDevice() | unknown device");
          return void 0;
        }
      }
      exports.detectDevice = detectDevice2;
      var Device2 = class {
        /**
         * Create a new Device to connect to mediasoup server.
         *
         * @throws {UnsupportedError} if device is not supported.
         */
        constructor({ handlerName, handlerFactory, Handler } = {}) {
          this._loaded = false;
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger12.debug("constructor()");
          if (Handler) {
            logger12.warn("constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead");
            if (typeof Handler === "string") {
              handlerName = Handler;
            } else {
              throw new TypeError("non string Handler option no longer supported, use handlerFactory instead");
            }
          }
          if (handlerName && handlerFactory) {
            throw new TypeError("just one of handlerName or handlerInterface can be given");
          }
          if (handlerFactory) {
            this._handlerFactory = handlerFactory;
          } else {
            if (handlerName) {
              logger12.debug("constructor() | handler given: %s", handlerName);
            } else {
              handlerName = detectDevice2();
              if (handlerName) {
                logger12.debug("constructor() | detected handler: %s", handlerName);
              } else {
                throw new errors_1.UnsupportedError("device not supported");
              }
            }
            switch (handlerName) {
              case "Chrome111": {
                this._handlerFactory = Chrome111_1.Chrome111.createFactory();
                break;
              }
              case "Chrome74": {
                this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                break;
              }
              case "Chrome70": {
                this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                break;
              }
              case "Chrome67": {
                this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                break;
              }
              case "Chrome55": {
                this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                break;
              }
              case "Firefox60": {
                this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                break;
              }
              case "Safari12": {
                this._handlerFactory = Safari12_1.Safari12.createFactory();
                break;
              }
              case "Safari11": {
                this._handlerFactory = Safari11_1.Safari11.createFactory();
                break;
              }
              case "Edge11": {
                this._handlerFactory = Edge11_1.Edge11.createFactory();
                break;
              }
              case "ReactNativeUnifiedPlan": {
                this._handlerFactory = ReactNativeUnifiedPlan_1.ReactNativeUnifiedPlan.createFactory();
                break;
              }
              case "ReactNative": {
                this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                break;
              }
              default: {
                throw new TypeError(`unknown handlerName "${handlerName}"`);
              }
            }
          }
          const handler = this._handlerFactory();
          this._handlerName = handler.name;
          handler.close();
          this._extendedRtpCapabilities = void 0;
          this._recvRtpCapabilities = void 0;
          this._canProduceByKind = {
            audio: false,
            video: false
          };
          this._sctpCapabilities = void 0;
        }
        /**
         * The RTC handler name.
         */
        get handlerName() {
          return this._handlerName;
        }
        /**
         * Whether the Device is loaded.
         */
        get loaded() {
          return this._loaded;
        }
        /**
         * RTP capabilities of the Device for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get rtpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._recvRtpCapabilities;
        }
        /**
         * SCTP capabilities of the Device.
         *
         * @throws {InvalidStateError} if not loaded.
         */
        get sctpCapabilities() {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          }
          return this._sctpCapabilities;
        }
        get observer() {
          return this._observer;
        }
        /**
         * Initialize the Device.
         */
        async load({ routerRtpCapabilities }) {
          logger12.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
          routerRtpCapabilities = utils.clone(routerRtpCapabilities);
          let handler;
          try {
            if (this._loaded) {
              throw new errors_1.InvalidStateError("already loaded");
            }
            ortc.validateRtpCapabilities(routerRtpCapabilities);
            handler = this._handlerFactory();
            const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
            logger12.debug("load() | got native RTP capabilities:%o", nativeRtpCapabilities);
            ortc.validateRtpCapabilities(nativeRtpCapabilities);
            this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
            logger12.debug("load() | got extended RTP capabilities:%o", this._extendedRtpCapabilities);
            this._canProduceByKind.audio = ortc.canSend("audio", this._extendedRtpCapabilities);
            this._canProduceByKind.video = ortc.canSend("video", this._extendedRtpCapabilities);
            this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
            ortc.validateRtpCapabilities(this._recvRtpCapabilities);
            logger12.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
            this._sctpCapabilities = await handler.getNativeSctpCapabilities();
            logger12.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
            ortc.validateSctpCapabilities(this._sctpCapabilities);
            logger12.debug("load() succeeded");
            this._loaded = true;
            handler.close();
          } catch (error) {
            if (handler) {
              handler.close();
            }
            throw error;
          }
        }
        /**
         * Whether we can produce audio/video.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        canProduce(kind) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (kind !== "audio" && kind !== "video") {
            throw new TypeError(`invalid kind "${kind}"`);
          }
          return this._canProduceByKind[kind];
        }
        /**
         * Creates a Transport for sending media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger12.debug("createSendTransport()");
          return this.createTransport({
            direction: "send",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        /**
         * Creates a Transport for receiving media.
         *
         * @throws {InvalidStateError} if not loaded.
         * @throws {TypeError} if wrong arguments.
         */
        createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          logger12.debug("createRecvTransport()");
          return this.createTransport({
            direction: "recv",
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData
          });
        }
        createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData }) {
          if (!this._loaded) {
            throw new errors_1.InvalidStateError("not loaded");
          } else if (typeof id !== "string") {
            throw new TypeError("missing id");
          } else if (typeof iceParameters !== "object") {
            throw new TypeError("missing iceParameters");
          } else if (!Array.isArray(iceCandidates)) {
            throw new TypeError("missing iceCandidates");
          } else if (typeof dtlsParameters !== "object") {
            throw new TypeError("missing dtlsParameters");
          } else if (sctpParameters && typeof sctpParameters !== "object") {
            throw new TypeError("wrong sctpParameters");
          } else if (appData && typeof appData !== "object") {
            throw new TypeError("if given, appData must be an object");
          }
          const transport = new Transport_1.Transport({
            direction,
            id,
            iceParameters,
            iceCandidates,
            dtlsParameters,
            sctpParameters,
            iceServers,
            iceTransportPolicy,
            additionalSettings,
            proprietaryConstraints,
            appData,
            handlerFactory: this._handlerFactory,
            extendedRtpCapabilities: this._extendedRtpCapabilities,
            canProduceByKind: this._canProduceByKind
          });
          this._observer.safeEmit("newtransport", transport);
          return transport;
        }
      };
      exports.Device = Device2;
    }
  });

  // ../../node_modules/mediasoup-client/lib/RtpParameters.js
  var require_RtpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/RtpParameters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/SctpParameters.js
  var require_SctpParameters = __commonJS({
    "../../node_modules/mediasoup-client/lib/SctpParameters.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
    }
  });

  // ../../node_modules/mediasoup-client/lib/types.js
  var require_types = __commonJS({
    "../../node_modules/mediasoup-client/lib/types.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m)
          if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
            __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_Device(), exports);
      __exportStar(require_Transport(), exports);
      __exportStar(require_Producer(), exports);
      __exportStar(require_Consumer(), exports);
      __exportStar(require_DataProducer(), exports);
      __exportStar(require_DataConsumer(), exports);
      __exportStar(require_RtpParameters(), exports);
      __exportStar(require_SctpParameters(), exports);
      __exportStar(require_HandlerInterface(), exports);
      __exportStar(require_errors(), exports);
    }
  });

  // ../../node_modules/mediasoup-client/lib/index.js
  var require_lib4 = __commonJS({
    "../../node_modules/mediasoup-client/lib/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule)
          return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
              __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.debug = exports.parseScalabilityMode = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
      var debug_1 = __importDefault(require_browser());
      exports.debug = debug_1.default;
      var Device_1 = require_Device();
      Object.defineProperty(exports, "Device", { enumerable: true, get: function() {
        return Device_1.Device;
      } });
      Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function() {
        return Device_1.detectDevice;
      } });
      var types = __importStar(require_types());
      exports.types = types;
      exports.version = "3.7.2";
      var scalabilityModes_1 = require_scalabilityModes();
      Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function() {
        return scalabilityModes_1.parse;
      } });
    }
  });

  // ../types/dist/socket.types.js
  var require_socket_types = __commonJS({
    "../types/dist/socket.types.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocketCloseReason = exports.ESocketCloseCode = void 0;
      var ESocketCloseCode3;
      (function(ESocketCloseCode4) {
        ESocketCloseCode4[ESocketCloseCode4["ABNORMAL_CLOSURE"] = 1006] = "ABNORMAL_CLOSURE";
        ESocketCloseCode4[ESocketCloseCode4["NORMAL_CLOSURE"] = 1e3] = "NORMAL_CLOSURE";
        ESocketCloseCode4[ESocketCloseCode4["BROWSER_TAB_CLOSE"] = 1001] = "BROWSER_TAB_CLOSE";
        ESocketCloseCode4[ESocketCloseCode4["GOING_AWAY"] = 4001] = "GOING_AWAY";
        ESocketCloseCode4[ESocketCloseCode4["CONNECTION_EXPIRED"] = 4002] = "CONNECTION_EXPIRED";
        ESocketCloseCode4[ESocketCloseCode4["CONNECTION_ERROR"] = 4006] = "CONNECTION_ERROR";
        ESocketCloseCode4[ESocketCloseCode4["ROOM_CLOSED"] = 4007] = "ROOM_CLOSED";
        ESocketCloseCode4[ESocketCloseCode4["ROOM_ENTRY_DENIED"] = 4008] = "ROOM_ENTRY_DENIED";
        ESocketCloseCode4[ESocketCloseCode4["KICKED"] = 4009] = "KICKED";
      })(ESocketCloseCode3 || (exports.ESocketCloseCode = ESocketCloseCode3 = {}));
      exports.SocketCloseReason = {
        [ESocketCloseCode3.ROOM_CLOSED]: "ROOM_CLOSED",
        [ESocketCloseCode3.ABNORMAL_CLOSURE]: "ABNORMAL_CLOSURE",
        [ESocketCloseCode3.NORMAL_CLOSURE]: "NORMAL_CLOSURE",
        [ESocketCloseCode3.BROWSER_TAB_CLOSE]: "BROWSER_TAB_CLOSE",
        [ESocketCloseCode3.GOING_AWAY]: "GOING_AWAY",
        [ESocketCloseCode3.CONNECTION_ERROR]: "CONNECTION_ERROR",
        [ESocketCloseCode3.CONNECTION_EXPIRED]: "CONNECTION_EXPIRED",
        [ESocketCloseCode3.ROOM_ENTRY_DENIED]: "ROOM_ENTRY_DENIED",
        [ESocketCloseCode3.KICKED]: "KICKED"
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/assert.js
  function assert(condition, msg) {
    if (!condition) {
      throw new Error(msg);
    }
  }
  function assertInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid int 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN)
      throw new Error("invalid int 32: " + arg);
  }
  function assertUInt32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid uint 32: " + typeof arg);
    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0)
      throw new Error("invalid uint 32: " + arg);
  }
  function assertFloat32(arg) {
    if (typeof arg !== "number")
      throw new Error("invalid float 32: " + typeof arg);
    if (!Number.isFinite(arg))
      return;
    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN)
      throw new Error("invalid float 32: " + arg);
  }
  var FLOAT32_MAX, FLOAT32_MIN, UINT32_MAX, INT32_MAX, INT32_MIN;
  var init_assert = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/assert.js"() {
      "use strict";
      FLOAT32_MAX = 34028234663852886e22;
      FLOAT32_MIN = -34028234663852886e22;
      UINT32_MAX = 4294967295;
      INT32_MAX = 2147483647;
      INT32_MIN = -2147483648;
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/enum.js
  function getEnumType(enumObject) {
    const t = enumObject[enumTypeSymbol];
    assert(t, "missing enum type on enum object");
    return t;
  }
  function setEnumType(enumObject, typeName, values, opt) {
    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v) => ({
      no: v.no,
      name: v.name,
      localName: enumObject[v.no]
    })), opt);
  }
  function makeEnumType(typeName, values, _opt) {
    const names = /* @__PURE__ */ Object.create(null);
    const numbers = /* @__PURE__ */ Object.create(null);
    const normalValues = [];
    for (const value of values) {
      const n = normalizeEnumValue(value);
      normalValues.push(n);
      names[value.name] = n;
      numbers[value.no] = n;
    }
    return {
      typeName,
      values: normalValues,
      // We do not surface options at this time
      // options: opt?.options ?? Object.create(null),
      findName(name) {
        return names[name];
      },
      findNumber(no) {
        return numbers[no];
      }
    };
  }
  function makeEnum(typeName, values, opt) {
    const enumObject = {};
    for (const value of values) {
      const n = normalizeEnumValue(value);
      enumObject[n.localName] = n.no;
      enumObject[n.no] = n.localName;
    }
    setEnumType(enumObject, typeName, values, opt);
    return enumObject;
  }
  function normalizeEnumValue(value) {
    if ("localName" in value) {
      return value;
    }
    return Object.assign(Object.assign({}, value), { localName: value.name });
  }
  var enumTypeSymbol;
  var init_enum = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/enum.js"() {
      "use strict";
      init_assert();
      enumTypeSymbol = Symbol("@bufbuild/protobuf/enum-type");
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/message.js
  var Message;
  var init_message = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/message.js"() {
      "use strict";
      Message = class {
        /**
         * Compare with a message of the same type.
         */
        equals(other) {
          return this.getType().runtime.util.equals(this.getType(), this, other);
        }
        /**
         * Create a deep copy.
         */
        clone() {
          return this.getType().runtime.util.clone(this);
        }
        /**
         * Parse from binary data, merging fields.
         *
         * Repeated fields are appended. Map entries are added, overwriting
         * existing keys.
         *
         * If a message field is already present, it will be merged with the
         * new data.
         */
        fromBinary(bytes, options) {
          const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);
          format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);
          return this;
        }
        /**
         * Parse a message from a JSON value.
         */
        fromJson(jsonValue, options) {
          const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);
          format.readMessage(type, jsonValue, opt, this);
          return this;
        }
        /**
         * Parse a message from a JSON string.
         */
        fromJsonString(jsonString, options) {
          let json;
          try {
            json = JSON.parse(jsonString);
          } catch (e) {
            throw new Error(`cannot decode ${this.getType().typeName} from JSON: ${e instanceof Error ? e.message : String(e)}`);
          }
          return this.fromJson(json, options);
        }
        /**
         * Serialize the message to binary data.
         */
        toBinary(options) {
          const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();
          bin.writeMessage(this, writer, opt);
          return writer.finish();
        }
        /**
         * Serialize the message to a JSON value, a JavaScript value that can be
         * passed to JSON.stringify().
         */
        toJson(options) {
          const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);
          return json.writeMessage(this, opt);
        }
        /**
         * Serialize the message to a JSON string.
         */
        toJsonString(options) {
          var _a;
          const value = this.toJson(options);
          return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);
        }
        /**
         * Override for serialization behavior. This will be invoked when calling
         * JSON.stringify on this message (i.e. JSON.stringify(msg)).
         *
         * Note that this will not serialize google.protobuf.Any with a packed
         * message because the protobuf JSON format specifies that it needs to be
         * unpacked, and this is only possible with a type registry to look up the
         * message type.  As a result, attempting to serialize a message with this
         * type will throw an Error.
         *
         * This method is protected because you should not need to invoke it
         * directly -- instead use JSON.stringify or toJsonString for
         * stringified JSON.  Alternatively, if actual JSON is desired, you should
         * use toJson.
         */
        toJSON() {
          return this.toJson({
            emitDefaultValues: true
          });
        }
        /**
         * Retrieve the MessageType of this message - a singleton that represents
         * the protobuf message declaration and provides metadata for reflection-
         * based operations.
         */
        getType() {
          return Object.getPrototypeOf(this).constructor;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js
  function makeMessageType(runtime, typeName, fields, opt) {
    var _a;
    const localName2 = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(".") + 1);
    const type = {
      [localName2]: function(data) {
        runtime.util.initFields(this);
        runtime.util.initPartial(data, this);
      }
    }[localName2];
    Object.setPrototypeOf(type.prototype, new Message());
    Object.assign(type, {
      runtime,
      typeName,
      fields: runtime.util.newFieldList(fields),
      fromBinary(bytes, options) {
        return new type().fromBinary(bytes, options);
      },
      fromJson(jsonValue, options) {
        return new type().fromJson(jsonValue, options);
      },
      fromJsonString(jsonString, options) {
        return new type().fromJsonString(jsonString, options);
      },
      equals(a, b) {
        return runtime.util.equals(type, a, b);
      }
    });
    return type;
  }
  var init_message_type = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/message-type.js"() {
      "use strict";
      init_message();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js
  function makeProtoRuntime(syntax, json, bin, util2) {
    return {
      syntax,
      json,
      bin,
      util: util2,
      makeMessageType(typeName, fields, opt) {
        return makeMessageType(this, typeName, fields, opt);
      },
      makeEnum,
      makeEnumType,
      getEnumType
    };
  }
  var init_proto_runtime = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/proto-runtime.js"() {
      "use strict";
      init_enum();
      init_message_type();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/field.js
  var ScalarType;
  var init_field = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/field.js"() {
      "use strict";
      (function(ScalarType2) {
        ScalarType2[ScalarType2["DOUBLE"] = 1] = "DOUBLE";
        ScalarType2[ScalarType2["FLOAT"] = 2] = "FLOAT";
        ScalarType2[ScalarType2["INT64"] = 3] = "INT64";
        ScalarType2[ScalarType2["UINT64"] = 4] = "UINT64";
        ScalarType2[ScalarType2["INT32"] = 5] = "INT32";
        ScalarType2[ScalarType2["FIXED64"] = 6] = "FIXED64";
        ScalarType2[ScalarType2["FIXED32"] = 7] = "FIXED32";
        ScalarType2[ScalarType2["BOOL"] = 8] = "BOOL";
        ScalarType2[ScalarType2["STRING"] = 9] = "STRING";
        ScalarType2[ScalarType2["BYTES"] = 12] = "BYTES";
        ScalarType2[ScalarType2["UINT32"] = 13] = "UINT32";
        ScalarType2[ScalarType2["SFIXED32"] = 15] = "SFIXED32";
        ScalarType2[ScalarType2["SFIXED64"] = 16] = "SFIXED64";
        ScalarType2[ScalarType2["SINT32"] = 17] = "SINT32";
        ScalarType2[ScalarType2["SINT64"] = 18] = "SINT64";
      })(ScalarType || (ScalarType = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/varint.js
  function varint64read() {
    let lowBits = 0;
    let highBits = 0;
    for (let shift = 0; shift < 28; shift += 7) {
      let b = this.buf[this.pos++];
      lowBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    let middleByte = this.buf[this.pos++];
    lowBits |= (middleByte & 15) << 28;
    highBits = (middleByte & 112) >> 4;
    if ((middleByte & 128) == 0) {
      this.assertBounds();
      return [lowBits, highBits];
    }
    for (let shift = 3; shift <= 31; shift += 7) {
      let b = this.buf[this.pos++];
      highBits |= (b & 127) << shift;
      if ((b & 128) == 0) {
        this.assertBounds();
        return [lowBits, highBits];
      }
    }
    throw new Error("invalid varint");
  }
  function varint64write(lo, hi, bytes) {
    for (let i = 0; i < 28; i = i + 7) {
      const shift = lo >>> i;
      const hasNext = !(shift >>> 7 == 0 && hi == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    const splitBits = lo >>> 28 & 15 | (hi & 7) << 4;
    const hasMoreBits = !(hi >> 3 == 0);
    bytes.push((hasMoreBits ? splitBits | 128 : splitBits) & 255);
    if (!hasMoreBits) {
      return;
    }
    for (let i = 3; i < 31; i = i + 7) {
      const shift = hi >>> i;
      const hasNext = !(shift >>> 7 == 0);
      const byte = (hasNext ? shift | 128 : shift) & 255;
      bytes.push(byte);
      if (!hasNext) {
        return;
      }
    }
    bytes.push(hi >>> 31 & 1);
  }
  function int64FromString(dec) {
    const minus = dec[0] === "-";
    if (minus) {
      dec = dec.slice(1);
    }
    const base = 1e6;
    let lowBits = 0;
    let highBits = 0;
    function add1e6digit(begin, end) {
      const digit1e6 = Number(dec.slice(begin, end));
      highBits *= base;
      lowBits = lowBits * base + digit1e6;
      if (lowBits >= TWO_PWR_32_DBL) {
        highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);
        lowBits = lowBits % TWO_PWR_32_DBL;
      }
    }
    add1e6digit(-24, -18);
    add1e6digit(-18, -12);
    add1e6digit(-12, -6);
    add1e6digit(-6);
    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);
  }
  function int64ToString(lo, hi) {
    let bits = newBits(lo, hi);
    const negative = bits.hi & 2147483648;
    if (negative) {
      bits = negate(bits.lo, bits.hi);
    }
    const result = uInt64ToString(bits.lo, bits.hi);
    return negative ? "-" + result : result;
  }
  function uInt64ToString(lo, hi) {
    ({ lo, hi } = toUnsigned(lo, hi));
    if (hi <= 2097151) {
      return String(TWO_PWR_32_DBL * hi + lo);
    }
    const low = lo & 16777215;
    const mid = (lo >>> 24 | hi << 8) & 16777215;
    const high = hi >> 16 & 65535;
    let digitA = low + mid * 6777216 + high * 6710656;
    let digitB = mid + high * 8147497;
    let digitC = high * 2;
    const base = 1e7;
    if (digitA >= base) {
      digitB += Math.floor(digitA / base);
      digitA %= base;
    }
    if (digitB >= base) {
      digitC += Math.floor(digitB / base);
      digitB %= base;
    }
    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);
  }
  function toUnsigned(lo, hi) {
    return { lo: lo >>> 0, hi: hi >>> 0 };
  }
  function newBits(lo, hi) {
    return { lo: lo | 0, hi: hi | 0 };
  }
  function negate(lowBits, highBits) {
    highBits = ~highBits;
    if (lowBits) {
      lowBits = ~lowBits + 1;
    } else {
      highBits += 1;
    }
    return newBits(lowBits, highBits);
  }
  function varint32write(value, bytes) {
    if (value >= 0) {
      while (value > 127) {
        bytes.push(value & 127 | 128);
        value = value >>> 7;
      }
      bytes.push(value);
    } else {
      for (let i = 0; i < 9; i++) {
        bytes.push(value & 127 | 128);
        value = value >> 7;
      }
      bytes.push(1);
    }
  }
  function varint32read() {
    let b = this.buf[this.pos++];
    let result = b & 127;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 7;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 14;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 127) << 21;
    if ((b & 128) == 0) {
      this.assertBounds();
      return result;
    }
    b = this.buf[this.pos++];
    result |= (b & 15) << 28;
    for (let readBytes = 5; (b & 128) !== 0 && readBytes < 10; readBytes++)
      b = this.buf[this.pos++];
    if ((b & 128) != 0)
      throw new Error("invalid varint");
    this.assertBounds();
    return result >>> 0;
  }
  var TWO_PWR_32_DBL, decimalFrom1e7WithLeadingZeros;
  var init_varint = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/varint.js"() {
      "use strict";
      TWO_PWR_32_DBL = 4294967296;
      decimalFrom1e7WithLeadingZeros = (digit1e7) => {
        const partial = String(digit1e7);
        return "0000000".slice(partial.length) + partial;
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js
  function makeInt64Support() {
    const dv = new DataView(new ArrayBuffer(8));
    const ok = typeof BigInt === "function" && typeof dv.getBigInt64 === "function" && typeof dv.getBigUint64 === "function" && typeof dv.setBigInt64 === "function" && typeof dv.setBigUint64 === "function" && (typeof process != "object" || typeof process.env != "object" || process.env.BUF_BIGINT_DISABLE !== "1");
    if (ok) {
      const MIN = BigInt("-9223372036854775808"), MAX = BigInt("9223372036854775807"), UMIN = BigInt("0"), UMAX = BigInt("18446744073709551615");
      return {
        zero: BigInt(0),
        supported: true,
        parse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > MAX || bi < MIN) {
            throw new Error(`int64 invalid: ${value}`);
          }
          return bi;
        },
        uParse(value) {
          const bi = typeof value == "bigint" ? value : BigInt(value);
          if (bi > UMAX || bi < UMIN) {
            throw new Error(`uint64 invalid: ${value}`);
          }
          return bi;
        },
        enc(value) {
          dv.setBigInt64(0, this.parse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        uEnc(value) {
          dv.setBigInt64(0, this.uParse(value), true);
          return {
            lo: dv.getInt32(0, true),
            hi: dv.getInt32(4, true)
          };
        },
        dec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigInt64(0, true);
        },
        uDec(lo, hi) {
          dv.setInt32(0, lo, true);
          dv.setInt32(4, hi, true);
          return dv.getBigUint64(0, true);
        }
      };
    }
    const assertInt64String = (value) => assert(/^-?[0-9]+$/.test(value), `int64 invalid: ${value}`);
    const assertUInt64String = (value) => assert(/^[0-9]+$/.test(value), `uint64 invalid: ${value}`);
    return {
      zero: "0",
      supported: false,
      parse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return value;
      },
      uParse(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return value;
      },
      enc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertInt64String(value);
        return int64FromString(value);
      },
      uEnc(value) {
        if (typeof value != "string") {
          value = value.toString();
        }
        assertUInt64String(value);
        return int64FromString(value);
      },
      dec(lo, hi) {
        return int64ToString(lo, hi);
      },
      uDec(lo, hi) {
        return uInt64ToString(lo, hi);
      }
    };
  }
  var protoInt64;
  var init_proto_int64 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-int64.js"() {
      "use strict";
      init_assert();
      init_varint();
      protoInt64 = makeInt64Support();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js
  var WireType, BinaryWriter, BinaryReader;
  var init_binary_encoding = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/binary-encoding.js"() {
      "use strict";
      init_varint();
      init_assert();
      init_proto_int64();
      (function(WireType2) {
        WireType2[WireType2["Varint"] = 0] = "Varint";
        WireType2[WireType2["Bit64"] = 1] = "Bit64";
        WireType2[WireType2["LengthDelimited"] = 2] = "LengthDelimited";
        WireType2[WireType2["StartGroup"] = 3] = "StartGroup";
        WireType2[WireType2["EndGroup"] = 4] = "EndGroup";
        WireType2[WireType2["Bit32"] = 5] = "Bit32";
      })(WireType || (WireType = {}));
      BinaryWriter = class {
        constructor(textEncoder) {
          this.stack = [];
          this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();
          this.chunks = [];
          this.buf = [];
        }
        /**
         * Return all bytes written and reset this writer.
         */
        finish() {
          this.chunks.push(new Uint8Array(this.buf));
          let len = 0;
          for (let i = 0; i < this.chunks.length; i++)
            len += this.chunks[i].length;
          let bytes = new Uint8Array(len);
          let offset = 0;
          for (let i = 0; i < this.chunks.length; i++) {
            bytes.set(this.chunks[i], offset);
            offset += this.chunks[i].length;
          }
          this.chunks = [];
          return bytes;
        }
        /**
         * Start a new fork for length-delimited data like a message
         * or a packed repeated field.
         *
         * Must be joined later with `join()`.
         */
        fork() {
          this.stack.push({ chunks: this.chunks, buf: this.buf });
          this.chunks = [];
          this.buf = [];
          return this;
        }
        /**
         * Join the last fork. Write its length and bytes, then
         * return to the previous state.
         */
        join() {
          let chunk = this.finish();
          let prev = this.stack.pop();
          if (!prev)
            throw new Error("invalid state, fork stack empty");
          this.chunks = prev.chunks;
          this.buf = prev.buf;
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
        }
        /**
         * Writes a tag (field number and wire type).
         *
         * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.
         *
         * Generated code should compute the tag ahead of time and call `uint32()`.
         */
        tag(fieldNo, type) {
          return this.uint32((fieldNo << 3 | type) >>> 0);
        }
        /**
         * Write a chunk of raw bytes.
         */
        raw(chunk) {
          if (this.buf.length) {
            this.chunks.push(new Uint8Array(this.buf));
            this.buf = [];
          }
          this.chunks.push(chunk);
          return this;
        }
        /**
         * Write a `uint32` value, an unsigned 32 bit varint.
         */
        uint32(value) {
          assertUInt32(value);
          while (value > 127) {
            this.buf.push(value & 127 | 128);
            value = value >>> 7;
          }
          this.buf.push(value);
          return this;
        }
        /**
         * Write a `int32` value, a signed 32 bit varint.
         */
        int32(value) {
          assertInt32(value);
          varint32write(value, this.buf);
          return this;
        }
        /**
         * Write a `bool` value, a variant.
         */
        bool(value) {
          this.buf.push(value ? 1 : 0);
          return this;
        }
        /**
         * Write a `bytes` value, length-delimited arbitrary data.
         */
        bytes(value) {
          this.uint32(value.byteLength);
          return this.raw(value);
        }
        /**
         * Write a `string` value, length-delimited data converted to UTF-8 text.
         */
        string(value) {
          let chunk = this.textEncoder.encode(value);
          this.uint32(chunk.byteLength);
          return this.raw(chunk);
        }
        /**
         * Write a `float` value, 32-bit floating point number.
         */
        float(value) {
          assertFloat32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setFloat32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `double` value, a 64-bit floating point number.
         */
        double(value) {
          let chunk = new Uint8Array(8);
          new DataView(chunk.buffer).setFloat64(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.
         */
        fixed32(value) {
          assertUInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setUint32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.
         */
        sfixed32(value) {
          assertInt32(value);
          let chunk = new Uint8Array(4);
          new DataView(chunk.buffer).setInt32(0, value, true);
          return this.raw(chunk);
        }
        /**
         * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.
         */
        sint32(value) {
          assertInt32(value);
          value = (value << 1 ^ value >> 31) >>> 0;
          varint32write(value, this.buf);
          return this;
        }
        /**
         * Write a `fixed64` value, a signed, fixed-length 64-bit integer.
         */
        sfixed64(value) {
          let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);
          view.setInt32(0, tc.lo, true);
          view.setInt32(4, tc.hi, true);
          return this.raw(chunk);
        }
        /**
         * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.
         */
        fixed64(value) {
          let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);
          view.setInt32(0, tc.lo, true);
          view.setInt32(4, tc.hi, true);
          return this.raw(chunk);
        }
        /**
         * Write a `int64` value, a signed 64-bit varint.
         */
        int64(value) {
          let tc = protoInt64.enc(value);
          varint64write(tc.lo, tc.hi, this.buf);
          return this;
        }
        /**
         * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.
         */
        sint64(value) {
          let tc = protoInt64.enc(value), sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;
          varint64write(lo, hi, this.buf);
          return this;
        }
        /**
         * Write a `uint64` value, an unsigned 64-bit varint.
         */
        uint64(value) {
          let tc = protoInt64.uEnc(value);
          varint64write(tc.lo, tc.hi, this.buf);
          return this;
        }
      };
      BinaryReader = class {
        constructor(buf, textDecoder) {
          this.varint64 = varint64read;
          this.uint32 = varint32read;
          this.buf = buf;
          this.len = buf.length;
          this.pos = 0;
          this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
          this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();
        }
        /**
         * Reads a tag - field number and wire type.
         */
        tag() {
          let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;
          if (fieldNo <= 0 || wireType < 0 || wireType > 5)
            throw new Error("illegal tag: field no " + fieldNo + " wire type " + wireType);
          return [fieldNo, wireType];
        }
        /**
         * Skip one element on the wire and return the skipped data.
         * Supports WireType.StartGroup since v2.0.0-alpha.23.
         */
        skip(wireType) {
          let start = this.pos;
          switch (wireType) {
            case WireType.Varint:
              while (this.buf[this.pos++] & 128) {
              }
              break;
            case WireType.Bit64:
              this.pos += 4;
            case WireType.Bit32:
              this.pos += 4;
              break;
            case WireType.LengthDelimited:
              let len = this.uint32();
              this.pos += len;
              break;
            case WireType.StartGroup:
              let t;
              while ((t = this.tag()[1]) !== WireType.EndGroup) {
                this.skip(t);
              }
              break;
            default:
              throw new Error("cant skip wire type " + wireType);
          }
          this.assertBounds();
          return this.buf.subarray(start, this.pos);
        }
        /**
         * Throws error if position in byte array is out of range.
         */
        assertBounds() {
          if (this.pos > this.len)
            throw new RangeError("premature EOF");
        }
        /**
         * Read a `int32` field, a signed 32 bit varint.
         */
        int32() {
          return this.uint32() | 0;
        }
        /**
         * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.
         */
        sint32() {
          let zze = this.uint32();
          return zze >>> 1 ^ -(zze & 1);
        }
        /**
         * Read a `int64` field, a signed 64-bit varint.
         */
        int64() {
          return protoInt64.dec(...this.varint64());
        }
        /**
         * Read a `uint64` field, an unsigned 64-bit varint.
         */
        uint64() {
          return protoInt64.uDec(...this.varint64());
        }
        /**
         * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.
         */
        sint64() {
          let [lo, hi] = this.varint64();
          let s = -(lo & 1);
          lo = (lo >>> 1 | (hi & 1) << 31) ^ s;
          hi = hi >>> 1 ^ s;
          return protoInt64.dec(lo, hi);
        }
        /**
         * Read a `bool` field, a variant.
         */
        bool() {
          let [lo, hi] = this.varint64();
          return lo !== 0 || hi !== 0;
        }
        /**
         * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.
         */
        fixed32() {
          return this.view.getUint32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.
         */
        sfixed32() {
          return this.view.getInt32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.
         */
        fixed64() {
          return protoInt64.uDec(this.sfixed32(), this.sfixed32());
        }
        /**
         * Read a `fixed64` field, a signed, fixed-length 64-bit integer.
         */
        sfixed64() {
          return protoInt64.dec(this.sfixed32(), this.sfixed32());
        }
        /**
         * Read a `float` field, 32-bit floating point number.
         */
        float() {
          return this.view.getFloat32((this.pos += 4) - 4, true);
        }
        /**
         * Read a `double` field, a 64-bit floating point number.
         */
        double() {
          return this.view.getFloat64((this.pos += 8) - 8, true);
        }
        /**
         * Read a `bytes` field, length-delimited arbitrary data.
         */
        bytes() {
          let len = this.uint32(), start = this.pos;
          this.pos += len;
          this.assertBounds();
          return this.buf.subarray(start, start + len);
        }
        /**
         * Read a `string` field, length-delimited data converted to UTF-8 text.
         */
        string() {
          return this.textDecoder.decode(this.bytes());
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js
  function wrapField(type, value) {
    if (value instanceof Message || !type.fieldWrapper) {
      return value;
    }
    return type.fieldWrapper.wrapField(value);
  }
  function getUnwrappedFieldType(field) {
    if (field.fieldKind !== "message") {
      return void 0;
    }
    if (field.repeated) {
      return void 0;
    }
    if (field.oneof != void 0) {
      return void 0;
    }
    return wktWrapperToScalarType[field.message.typeName];
  }
  var wktWrapperToScalarType;
  var init_field_wrapper = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field-wrapper.js"() {
      "use strict";
      init_message();
      init_field();
      wktWrapperToScalarType = {
        "google.protobuf.DoubleValue": ScalarType.DOUBLE,
        "google.protobuf.FloatValue": ScalarType.FLOAT,
        "google.protobuf.Int64Value": ScalarType.INT64,
        "google.protobuf.UInt64Value": ScalarType.UINT64,
        "google.protobuf.Int32Value": ScalarType.INT32,
        "google.protobuf.UInt32Value": ScalarType.UINT32,
        "google.protobuf.BoolValue": ScalarType.BOOL,
        "google.protobuf.StringValue": ScalarType.STRING,
        "google.protobuf.BytesValue": ScalarType.BYTES
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js
  function scalarEquals(type, a, b) {
    if (a === b) {
      return true;
    }
    if (type == ScalarType.BYTES) {
      if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      return true;
    }
    switch (type) {
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return a == b;
    }
    return false;
  }
  function scalarDefaultValue(type) {
    switch (type) {
      case ScalarType.BOOL:
        return false;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        return protoInt64.zero;
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        return 0;
      case ScalarType.BYTES:
        return new Uint8Array(0);
      case ScalarType.STRING:
        return "";
      default:
        return 0;
    }
  }
  function scalarTypeInfo(type, value) {
    const isUndefined = value === void 0;
    let wireType = WireType.Varint;
    let isIntrinsicDefault = value === 0;
    switch (type) {
      case ScalarType.STRING:
        isIntrinsicDefault = isUndefined || !value.length;
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.BOOL:
        isIntrinsicDefault = value === false;
        break;
      case ScalarType.DOUBLE:
        wireType = WireType.Bit64;
        break;
      case ScalarType.FLOAT:
        wireType = WireType.Bit32;
        break;
      case ScalarType.INT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
      case ScalarType.UINT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
      case ScalarType.FIXED64:
        isIntrinsicDefault = isUndefined || value == 0;
        wireType = WireType.Bit64;
        break;
      case ScalarType.BYTES:
        isIntrinsicDefault = isUndefined || !value.byteLength;
        wireType = WireType.LengthDelimited;
        break;
      case ScalarType.FIXED32:
        wireType = WireType.Bit32;
        break;
      case ScalarType.SFIXED32:
        wireType = WireType.Bit32;
        break;
      case ScalarType.SFIXED64:
        isIntrinsicDefault = isUndefined || value == 0;
        wireType = WireType.Bit64;
        break;
      case ScalarType.SINT64:
        isIntrinsicDefault = isUndefined || value == 0;
        break;
    }
    const method = ScalarType[type].toLowerCase();
    return [wireType, method, isUndefined || isIntrinsicDefault];
  }
  var init_scalars = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/scalars.js"() {
      "use strict";
      init_field();
      init_binary_encoding();
      init_proto_int64();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js
  function makeReadOptions(options) {
    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;
  }
  function makeWriteOptions(options) {
    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;
  }
  function makeBinaryFormatCommon() {
    return {
      makeReadOptions,
      makeWriteOptions,
      listUnknownFields(message) {
        var _a;
        return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];
      },
      discardUnknownFields(message) {
        delete message[unknownFieldsSymbol];
      },
      writeUnknownFields(message, writer) {
        const m = message;
        const c = m[unknownFieldsSymbol];
        if (c) {
          for (const f of c) {
            writer.tag(f.no, f.wireType).raw(f.data);
          }
        }
      },
      onUnknownField(message, no, wireType, data) {
        const m = message;
        if (!Array.isArray(m[unknownFieldsSymbol])) {
          m[unknownFieldsSymbol] = [];
        }
        m[unknownFieldsSymbol].push({ no, wireType, data });
      },
      readMessage(message, reader, length, options) {
        const type = message.getType();
        const end = length === void 0 ? reader.len : reader.pos + length;
        while (reader.pos < end) {
          const [fieldNo, wireType] = reader.tag(), field = type.fields.find(fieldNo);
          if (!field) {
            const data = reader.skip(wireType);
            if (options.readUnknownFields) {
              this.onUnknownField(message, fieldNo, wireType, data);
            }
            continue;
          }
          let target = message, repeated = field.repeated, localName2 = field.localName;
          if (field.oneof) {
            target = target[field.oneof.localName];
            if (target.case != localName2) {
              delete target.value;
            }
            target.case = localName2;
            localName2 = "value";
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              const scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                let arr = target[localName2];
                if (wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES) {
                  let e = reader.uint32() + reader.pos;
                  while (reader.pos < e) {
                    arr.push(readScalar(reader, scalarType));
                  }
                } else {
                  arr.push(readScalar(reader, scalarType));
                }
              } else {
                target[localName2] = readScalar(reader, scalarType);
              }
              break;
            case "message":
              const messageType = field.T;
              if (repeated) {
                target[localName2].push(readMessageField(reader, new messageType(), options));
              } else {
                if (target[localName2] instanceof Message) {
                  readMessageField(reader, target[localName2], options);
                } else {
                  target[localName2] = readMessageField(reader, new messageType(), options);
                  if (messageType.fieldWrapper && !field.oneof && !field.repeated) {
                    target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
                  }
                }
              }
              break;
            case "map":
              let [mapKey, mapVal] = readMapEntry(field, reader, options);
              target[localName2][mapKey] = mapVal;
              break;
          }
        }
      }
    };
  }
  function readMessageField(reader, message, options) {
    const format = message.getType().runtime.bin;
    format.readMessage(message, reader, reader.uint32(), options);
    return message;
  }
  function readMapEntry(field, reader, options) {
    const length = reader.uint32(), end = reader.pos + length;
    let key, val;
    while (reader.pos < end) {
      let [fieldNo] = reader.tag();
      switch (fieldNo) {
        case 1:
          key = readScalar(reader, field.K);
          break;
        case 2:
          switch (field.V.kind) {
            case "scalar":
              val = readScalar(reader, field.V.T);
              break;
            case "enum":
              val = reader.int32();
              break;
            case "message":
              val = readMessageField(reader, new field.V.T(), options);
              break;
          }
          break;
      }
    }
    if (key === void 0) {
      let keyRaw = scalarDefaultValue(field.K);
      key = field.K == ScalarType.BOOL ? keyRaw.toString() : keyRaw;
    }
    if (typeof key != "string" && typeof key != "number") {
      key = key.toString();
    }
    if (val === void 0) {
      switch (field.V.kind) {
        case "scalar":
          val = scalarDefaultValue(field.V.T);
          break;
        case "enum":
          val = 0;
          break;
        case "message":
          val = new field.V.T();
          break;
      }
    }
    return [key, val];
  }
  function readScalar(reader, type) {
    switch (type) {
      case ScalarType.STRING:
        return reader.string();
      case ScalarType.BOOL:
        return reader.bool();
      case ScalarType.DOUBLE:
        return reader.double();
      case ScalarType.FLOAT:
        return reader.float();
      case ScalarType.INT32:
        return reader.int32();
      case ScalarType.INT64:
        return reader.int64();
      case ScalarType.UINT64:
        return reader.uint64();
      case ScalarType.FIXED64:
        return reader.fixed64();
      case ScalarType.BYTES:
        return reader.bytes();
      case ScalarType.FIXED32:
        return reader.fixed32();
      case ScalarType.SFIXED32:
        return reader.sfixed32();
      case ScalarType.SFIXED64:
        return reader.sfixed64();
      case ScalarType.SINT64:
        return reader.sint64();
      case ScalarType.UINT32:
        return reader.uint32();
      case ScalarType.SINT32:
        return reader.sint32();
    }
  }
  function writeMapEntry(writer, options, field, key, value) {
    writer.tag(field.no, WireType.LengthDelimited);
    writer.fork();
    let keyValue = key;
    switch (field.K) {
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
        keyValue = Number.parseInt(key);
        break;
      case ScalarType.BOOL:
        assert(key == "true" || key == "false");
        keyValue = key == "true";
        break;
    }
    writeScalar(writer, field.K, 1, keyValue, true);
    switch (field.V.kind) {
      case "scalar":
        writeScalar(writer, field.V.T, 2, value, true);
        break;
      case "enum":
        writeScalar(writer, ScalarType.INT32, 2, value, true);
        break;
      case "message":
        writeMessageField(writer, options, field.V.T, 2, value);
        break;
    }
    writer.join();
  }
  function writeMessageField(writer, options, type, fieldNo, value) {
    if (value !== void 0) {
      const message = wrapField(type, value);
      writer.tag(fieldNo, WireType.LengthDelimited).bytes(message.toBinary(options));
    }
  }
  function writeScalar(writer, type, fieldNo, value, emitIntrinsicDefault) {
    let [wireType, method, isIntrinsicDefault] = scalarTypeInfo(type, value);
    if (!isIntrinsicDefault || emitIntrinsicDefault) {
      writer.tag(fieldNo, wireType)[method](value);
    }
  }
  function writePacked(writer, type, fieldNo, value) {
    if (!value.length) {
      return;
    }
    writer.tag(fieldNo, WireType.LengthDelimited).fork();
    let [, method] = scalarTypeInfo(type);
    for (let i = 0; i < value.length; i++) {
      writer[method](value[i]);
    }
    writer.join();
  }
  var unknownFieldsSymbol, readDefaults, writeDefaults;
  var init_binary_format_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-common.js"() {
      "use strict";
      init_binary_encoding();
      init_message();
      init_field();
      init_field_wrapper();
      init_scalars();
      init_assert();
      unknownFieldsSymbol = Symbol("@bufbuild/protobuf/unknown-fields");
      readDefaults = {
        readUnknownFields: true,
        readerFactory: (bytes) => new BinaryReader(bytes)
      };
      writeDefaults = {
        writeUnknownFields: true,
        writerFactory: () => new BinaryWriter()
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto3.js
  function makeBinaryFormatProto3() {
    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), { writeMessage(message, writer, options) {
      const type = message.getType();
      for (const field of type.fields.byNumber()) {
        let value, repeated = field.repeated, localName2 = field.localName;
        if (field.oneof) {
          const oneof = message[field.oneof.localName];
          if (oneof.case !== localName2) {
            continue;
          }
          value = oneof.value;
        } else {
          value = message[localName2];
        }
        switch (field.kind) {
          case "scalar":
          case "enum":
            let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
            if (repeated) {
              if (field.packed) {
                writePacked(writer, scalarType, field.no, value);
              } else {
                for (const item of value) {
                  writeScalar(writer, scalarType, field.no, item, true);
                }
              }
            } else {
              if (value !== void 0) {
                writeScalar(writer, scalarType, field.no, value, !!field.oneof || field.opt);
              }
            }
            break;
          case "message":
            if (repeated) {
              for (const item of value) {
                writeMessageField(writer, options, field.T, field.no, item);
              }
            } else {
              writeMessageField(writer, options, field.T, field.no, value);
            }
            break;
          case "map":
            for (const [key, val] of Object.entries(value)) {
              writeMapEntry(writer, options, field, key, val);
            }
            break;
        }
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    } });
  }
  var init_binary_format_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto3.js"() {
      "use strict";
      init_field();
      init_binary_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js
  var encTable, decTable, protoBase64;
  var init_proto_base64 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-base64.js"() {
      "use strict";
      encTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
      decTable = [];
      for (let i = 0; i < encTable.length; i++)
        decTable[encTable[i].charCodeAt(0)] = i;
      decTable["-".charCodeAt(0)] = encTable.indexOf("+");
      decTable["_".charCodeAt(0)] = encTable.indexOf("/");
      protoBase64 = {
        /**
         * Decodes a base64 string to a byte array.
         *
         * - ignores white-space, including line breaks and tabs
         * - allows inner padding (can decode concatenated base64 strings)
         * - does not require padding
         * - understands base64url encoding:
         *   "-" instead of "+",
         *   "_" instead of "/",
         *   no padding
         */
        dec(base64Str) {
          let es = base64Str.length * 3 / 4;
          if (base64Str[base64Str.length - 2] == "=")
            es -= 2;
          else if (base64Str[base64Str.length - 1] == "=")
            es -= 1;
          let bytes = new Uint8Array(es), bytePos = 0, groupPos = 0, b, p = 0;
          for (let i = 0; i < base64Str.length; i++) {
            b = decTable[base64Str.charCodeAt(i)];
            if (b === void 0) {
              switch (base64Str[i]) {
                case "=":
                  groupPos = 0;
                case "\n":
                case "\r":
                case "	":
                case " ":
                  continue;
                default:
                  throw Error("invalid base64 string.");
              }
            }
            switch (groupPos) {
              case 0:
                p = b;
                groupPos = 1;
                break;
              case 1:
                bytes[bytePos++] = p << 2 | (b & 48) >> 4;
                p = b;
                groupPos = 2;
                break;
              case 2:
                bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;
                p = b;
                groupPos = 3;
                break;
              case 3:
                bytes[bytePos++] = (p & 3) << 6 | b;
                groupPos = 0;
                break;
            }
          }
          if (groupPos == 1)
            throw Error("invalid base64 string.");
          return bytes.subarray(0, bytePos);
        },
        /**
         * Encode a byte array to a base64 string.
         */
        enc(bytes) {
          let base64 = "", groupPos = 0, b, p = 0;
          for (let i = 0; i < bytes.length; i++) {
            b = bytes[i];
            switch (groupPos) {
              case 0:
                base64 += encTable[b >> 2];
                p = (b & 3) << 4;
                groupPos = 1;
                break;
              case 1:
                base64 += encTable[p | b >> 4];
                p = (b & 15) << 2;
                groupPos = 2;
                break;
              case 2:
                base64 += encTable[p | b >> 6];
                base64 += encTable[b & 63];
                groupPos = 0;
                break;
            }
          }
          if (groupPos) {
            base64 += encTable[p];
            base64 += "=";
            if (groupPos == 1)
              base64 += "=";
          }
          return base64;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js
  function makeReadOptions2(options) {
    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;
  }
  function makeWriteOptions2(options) {
    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;
  }
  function makeJsonFormatCommon(makeWriteField) {
    const writeField = makeWriteField(writeEnum, writeScalar2);
    return {
      makeReadOptions: makeReadOptions2,
      makeWriteOptions: makeWriteOptions2,
      readMessage(type, json, options, message) {
        if (json == null || Array.isArray(json) || typeof json != "object") {
          throw new Error(`cannot decode message ${type.typeName} from JSON: ${this.debug(json)}`);
        }
        message = message !== null && message !== void 0 ? message : new type();
        const oneofSeen = {};
        for (const [jsonKey, jsonValue] of Object.entries(json)) {
          const field = type.fields.findJsonName(jsonKey);
          if (!field) {
            if (!options.ignoreUnknownFields) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: key "${jsonKey}" is unknown`);
            }
            continue;
          }
          let localName2 = field.localName;
          let target = message;
          if (field.oneof) {
            if (jsonValue === null && field.kind == "scalar") {
              continue;
            }
            const seen = oneofSeen[field.oneof.localName];
            if (seen) {
              throw new Error(`cannot decode message ${type.typeName} from JSON: multiple keys for oneof "${field.oneof.name}" present: "${seen}", "${jsonKey}"`);
            }
            oneofSeen[field.oneof.localName] = jsonKey;
            target = target[field.oneof.localName] = { case: localName2 };
            localName2 = "value";
          }
          if (field.repeated) {
            if (jsonValue === null) {
              continue;
            }
            if (!Array.isArray(jsonValue)) {
              throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);
            }
            const targetArray = target[localName2];
            for (const jsonItem of jsonValue) {
              if (jsonItem === null) {
                throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`);
              }
              let val;
              switch (field.kind) {
                case "message":
                  val = field.T.fromJson(jsonItem, options);
                  break;
                case "enum":
                  val = readEnum(field.T, jsonItem, options.ignoreUnknownFields);
                  if (val === void 0)
                    continue;
                  break;
                case "scalar":
                  try {
                    val = readScalar2(field.T, jsonItem);
                  } catch (e) {
                    let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonItem)}`;
                    if (e instanceof Error && e.message.length > 0) {
                      m += `: ${e.message}`;
                    }
                    throw new Error(m);
                  }
                  break;
              }
              targetArray.push(val);
            }
          } else if (field.kind == "map") {
            if (jsonValue === null) {
              continue;
            }
            if (Array.isArray(jsonValue) || typeof jsonValue != "object") {
              throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`);
            }
            const targetMap = target[localName2];
            for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)) {
              if (jsonMapValue === null) {
                throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: map value null`);
              }
              let val;
              switch (field.V.kind) {
                case "message":
                  val = field.V.T.fromJson(jsonMapValue, options);
                  break;
                case "enum":
                  val = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields);
                  if (val === void 0)
                    continue;
                  break;
                case "scalar":
                  try {
                    val = readScalar2(field.V.T, jsonMapValue);
                  } catch (e) {
                    let m = `cannot decode map value for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                    if (e instanceof Error && e.message.length > 0) {
                      m += `: ${e.message}`;
                    }
                    throw new Error(m);
                  }
                  break;
              }
              try {
                targetMap[readScalar2(field.K, field.K == ScalarType.BOOL ? jsonMapKey == "true" ? true : jsonMapKey == "false" ? false : jsonMapKey : jsonMapKey).toString()] = val;
              } catch (e) {
                let m = `cannot decode map key for field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                if (e instanceof Error && e.message.length > 0) {
                  m += `: ${e.message}`;
                }
                throw new Error(m);
              }
            }
          } else {
            switch (field.kind) {
              case "message":
                const messageType = field.T;
                if (jsonValue === null && messageType.typeName != "google.protobuf.Value") {
                  if (field.oneof) {
                    throw new Error(`cannot decode field ${type.typeName}.${field.name} from JSON: null is invalid for oneof field "${jsonKey}"`);
                  }
                  continue;
                }
                if (target[localName2] instanceof Message) {
                  target[localName2].fromJson(jsonValue, options);
                } else {
                  target[localName2] = messageType.fromJson(jsonValue, options);
                  if (messageType.fieldWrapper && !field.oneof) {
                    target[localName2] = messageType.fieldWrapper.unwrapField(target[localName2]);
                  }
                }
                break;
              case "enum":
                const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields);
                if (enumValue !== void 0) {
                  target[localName2] = enumValue;
                }
                break;
              case "scalar":
                try {
                  target[localName2] = readScalar2(field.T, jsonValue);
                } catch (e) {
                  let m = `cannot decode field ${type.typeName}.${field.name} from JSON: ${this.debug(jsonValue)}`;
                  if (e instanceof Error && e.message.length > 0) {
                    m += `: ${e.message}`;
                  }
                  throw new Error(m);
                }
                break;
            }
          }
        }
        return message;
      },
      writeMessage(message, options) {
        const type = message.getType();
        const json = {};
        let field;
        try {
          for (const member of type.fields.byMember()) {
            let jsonValue;
            if (member.kind == "oneof") {
              const oneof = message[member.localName];
              if (oneof.value === void 0) {
                continue;
              }
              field = member.findField(oneof.case);
              if (!field) {
                throw "oneof case not found: " + oneof.case;
              }
              jsonValue = writeField(field, oneof.value, options);
            } else {
              field = member;
              jsonValue = writeField(field, message[field.localName], options);
            }
            if (jsonValue !== void 0) {
              json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;
            }
          }
        } catch (e) {
          const m = field ? `cannot encode field ${type.typeName}.${field.name} to JSON` : `cannot encode message ${type.typeName} to JSON`;
          const r = e instanceof Error ? e.message : String(e);
          throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
        }
        return json;
      },
      readScalar: readScalar2,
      writeScalar: writeScalar2,
      debug: debugJsonValue
    };
  }
  function debugJsonValue(json) {
    if (json === null) {
      return "null";
    }
    switch (typeof json) {
      case "object":
        return Array.isArray(json) ? "array" : "object";
      case "string":
        return json.length > 100 ? "string" : `"${json.split('"').join('\\"')}"`;
      default:
        return String(json);
    }
  }
  function readScalar2(type, json) {
    switch (type) {
      case ScalarType.DOUBLE:
      case ScalarType.FLOAT:
        if (json === null)
          return 0;
        if (json === "NaN")
          return Number.NaN;
        if (json === "Infinity")
          return Number.POSITIVE_INFINITY;
        if (json === "-Infinity")
          return Number.NEGATIVE_INFINITY;
        if (json === "") {
          break;
        }
        if (typeof json == "string" && json.trim().length !== json.length) {
          break;
        }
        if (typeof json != "string" && typeof json != "number") {
          break;
        }
        const float = Number(json);
        if (Number.isNaN(float)) {
          break;
        }
        if (!Number.isFinite(float)) {
          break;
        }
        if (type == ScalarType.FLOAT)
          assertFloat32(float);
        return float;
      case ScalarType.INT32:
      case ScalarType.FIXED32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.UINT32:
        if (json === null)
          return 0;
        let int32;
        if (typeof json == "number")
          int32 = json;
        else if (typeof json == "string" && json.length > 0) {
          if (json.trim().length === json.length)
            int32 = Number(json);
        }
        if (int32 === void 0)
          break;
        if (type == ScalarType.UINT32)
          assertUInt32(int32);
        else
          assertInt32(int32);
        return int32;
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        if (json === null)
          return protoInt64.zero;
        if (typeof json != "number" && typeof json != "string")
          break;
        return protoInt64.parse(json);
      case ScalarType.FIXED64:
      case ScalarType.UINT64:
        if (json === null)
          return protoInt64.zero;
        if (typeof json != "number" && typeof json != "string")
          break;
        return protoInt64.uParse(json);
      case ScalarType.BOOL:
        if (json === null)
          return false;
        if (typeof json !== "boolean")
          break;
        return json;
      case ScalarType.STRING:
        if (json === null)
          return "";
        if (typeof json !== "string") {
          break;
        }
        try {
          encodeURIComponent(json);
        } catch (e) {
          throw new Error("invalid UTF8");
        }
        return json;
      case ScalarType.BYTES:
        if (json === null || json === "")
          return new Uint8Array(0);
        if (typeof json !== "string")
          break;
        return protoBase64.dec(json);
    }
    throw new Error();
  }
  function readEnum(type, json, ignoreUnknownFields) {
    if (json === null) {
      return 0;
    }
    switch (typeof json) {
      case "number":
        if (Number.isInteger(json)) {
          return json;
        }
        break;
      case "string":
        const value = type.findName(json);
        if (value || ignoreUnknownFields) {
          return value === null || value === void 0 ? void 0 : value.no;
        }
        break;
    }
    throw new Error(`cannot decode enum ${type.typeName} from JSON: ${debugJsonValue(json)}`);
  }
  function writeEnum(type, value, emitIntrinsicDefault, enumAsInteger) {
    var _a;
    if (value === void 0) {
      return value;
    }
    if (value === 0 && !emitIntrinsicDefault) {
      return void 0;
    }
    if (enumAsInteger) {
      return value;
    }
    if (type.typeName == "google.protobuf.NullValue") {
      return null;
    }
    const val = type.findNumber(value);
    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value;
  }
  function writeScalar2(type, value, emitIntrinsicDefault) {
    if (value === void 0) {
      return void 0;
    }
    switch (type) {
      case ScalarType.INT32:
      case ScalarType.SFIXED32:
      case ScalarType.SINT32:
      case ScalarType.FIXED32:
      case ScalarType.UINT32:
        assert(typeof value == "number");
        return value != 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.FLOAT:
      case ScalarType.DOUBLE:
        assert(typeof value == "number");
        if (Number.isNaN(value))
          return "NaN";
        if (value === Number.POSITIVE_INFINITY)
          return "Infinity";
        if (value === Number.NEGATIVE_INFINITY)
          return "-Infinity";
        return value !== 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.STRING:
        assert(typeof value == "string");
        return value.length > 0 || emitIntrinsicDefault ? value : void 0;
      case ScalarType.BOOL:
        assert(typeof value == "boolean");
        return value || emitIntrinsicDefault ? value : void 0;
      case ScalarType.UINT64:
      case ScalarType.FIXED64:
      case ScalarType.INT64:
      case ScalarType.SFIXED64:
      case ScalarType.SINT64:
        assert(typeof value == "bigint" || typeof value == "string" || typeof value == "number");
        return emitIntrinsicDefault || value != 0 ? value.toString(10) : void 0;
      case ScalarType.BYTES:
        assert(value instanceof Uint8Array);
        return emitIntrinsicDefault || value.byteLength > 0 ? protoBase64.enc(value) : void 0;
    }
  }
  var jsonReadDefaults, jsonWriteDefaults;
  var init_json_format_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-common.js"() {
      "use strict";
      init_message();
      init_field();
      init_assert();
      init_proto_int64();
      init_proto_base64();
      jsonReadDefaults = {
        ignoreUnknownFields: false
      };
      jsonWriteDefaults = {
        emitDefaultValues: false,
        enumAsInteger: false,
        useProtoFieldName: false,
        prettySpaces: 0
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto3.js
  function makeJsonFormatProto3() {
    return makeJsonFormatCommon((writeEnum2, writeScalar3) => {
      return function writeField(field, value, options) {
        if (field.kind == "map") {
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = writeScalar3(field.V.T, entryValue, true);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                jsonObj[entryKey.toString()] = entryValue.toJson(options);
              }
              break;
            case "enum":
              const enumType2 = field.V.T;
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert(entryValue === void 0 || typeof entryValue == "number");
                const val = writeEnum2(enumType2, entryValue, true, options.enumAsInteger);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : void 0;
        } else if (field.repeated) {
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeScalar3(field.T, value[i], true));
              }
              break;
            case "enum":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeEnum2(field.T, value[i], true, options.enumAsInteger));
              }
              break;
            case "message":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(wrapField(field.T, value[i]).toJson(options));
              }
              break;
          }
          return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
        } else {
          switch (field.kind) {
            case "scalar":
              return writeScalar3(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues);
            case "enum":
              return writeEnum2(field.T, value, !!field.oneof || field.opt || options.emitDefaultValues, options.enumAsInteger);
            case "message":
              return value !== void 0 ? wrapField(field.T, value).toJson(options) : void 0;
          }
        }
      };
    });
  }
  var init_json_format_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto3.js"() {
      "use strict";
      init_field_wrapper();
      init_assert();
      init_json_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js
  function makeUtilCommon() {
    return {
      setEnumType,
      initPartial(source, target) {
        if (source === void 0) {
          return;
        }
        const type = target.getType();
        for (const member of type.fields.byMember()) {
          const localName2 = member.localName, t = target, s = source;
          if (s[localName2] === void 0) {
            continue;
          }
          switch (member.kind) {
            case "oneof":
              const sk = s[localName2].case;
              if (sk === void 0) {
                continue;
              }
              const sourceField = member.findField(sk);
              let val = s[localName2].value;
              if (sourceField && sourceField.kind == "message" && !(val instanceof sourceField.T)) {
                val = new sourceField.T(val);
              } else if (sourceField && sourceField.kind === "scalar" && sourceField.T === ScalarType.BYTES) {
                val = toU8Arr(val);
              }
              t[localName2] = { case: sk, value: val };
              break;
            case "scalar":
            case "enum":
              let copy = s[localName2];
              if (member.T === ScalarType.BYTES) {
                copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);
              }
              t[localName2] = copy;
              break;
            case "map":
              switch (member.V.kind) {
                case "scalar":
                case "enum":
                  if (member.V.T === ScalarType.BYTES) {
                    for (const [k, v] of Object.entries(s[localName2])) {
                      t[localName2][k] = toU8Arr(v);
                    }
                  } else {
                    Object.assign(t[localName2], s[localName2]);
                  }
                  break;
                case "message":
                  const messageType = member.V.T;
                  for (const k of Object.keys(s[localName2])) {
                    let val2 = s[localName2][k];
                    if (!messageType.fieldWrapper) {
                      val2 = new messageType(val2);
                    }
                    t[localName2][k] = val2;
                  }
                  break;
              }
              break;
            case "message":
              const mt = member.T;
              if (member.repeated) {
                t[localName2] = s[localName2].map((val2) => val2 instanceof mt ? val2 : new mt(val2));
              } else if (s[localName2] !== void 0) {
                const val2 = s[localName2];
                if (mt.fieldWrapper) {
                  if (
                    // We can't use BytesValue.typeName as that will create a circular import
                    mt.typeName === "google.protobuf.BytesValue"
                  ) {
                    t[localName2] = toU8Arr(val2);
                  } else {
                    t[localName2] = val2;
                  }
                } else {
                  t[localName2] = val2 instanceof mt ? val2 : new mt(val2);
                }
              }
              break;
          }
        }
      },
      equals(type, a, b) {
        if (a === b) {
          return true;
        }
        if (!a || !b) {
          return false;
        }
        return type.fields.byMember().every((m) => {
          const va = a[m.localName];
          const vb = b[m.localName];
          if (m.repeated) {
            if (va.length !== vb.length) {
              return false;
            }
            switch (m.kind) {
              case "message":
                return va.every((a2, i) => m.T.equals(a2, vb[i]));
              case "scalar":
                return va.every((a2, i) => scalarEquals(m.T, a2, vb[i]));
              case "enum":
                return va.every((a2, i) => scalarEquals(ScalarType.INT32, a2, vb[i]));
            }
            throw new Error(`repeated cannot contain ${m.kind}`);
          }
          switch (m.kind) {
            case "message":
              return m.T.equals(va, vb);
            case "enum":
              return scalarEquals(ScalarType.INT32, va, vb);
            case "scalar":
              return scalarEquals(m.T, va, vb);
            case "oneof":
              if (va.case !== vb.case) {
                return false;
              }
              const s = m.findField(va.case);
              if (s === void 0) {
                return true;
              }
              switch (s.kind) {
                case "message":
                  return s.T.equals(va.value, vb.value);
                case "enum":
                  return scalarEquals(ScalarType.INT32, va.value, vb.value);
                case "scalar":
                  return scalarEquals(s.T, va.value, vb.value);
              }
              throw new Error(`oneof cannot contain ${s.kind}`);
            case "map":
              const keys = Object.keys(va).concat(Object.keys(vb));
              switch (m.V.kind) {
                case "message":
                  const messageType = m.V.T;
                  return keys.every((k) => messageType.equals(va[k], vb[k]));
                case "enum":
                  return keys.every((k) => scalarEquals(ScalarType.INT32, va[k], vb[k]));
                case "scalar":
                  const scalarType = m.V.T;
                  return keys.every((k) => scalarEquals(scalarType, va[k], vb[k]));
              }
              break;
          }
        });
      },
      clone(message) {
        const type = message.getType(), target = new type(), any = target;
        for (const member of type.fields.byMember()) {
          const source = message[member.localName];
          let copy;
          if (member.repeated) {
            copy = source.map(cloneSingularField);
          } else if (member.kind == "map") {
            copy = any[member.localName];
            for (const [key, v] of Object.entries(source)) {
              copy[key] = cloneSingularField(v);
            }
          } else if (member.kind == "oneof") {
            const f = member.findField(source.case);
            copy = f ? { case: source.case, value: cloneSingularField(source.value) } : { case: void 0 };
          } else {
            copy = cloneSingularField(source);
          }
          any[member.localName] = copy;
        }
        return target;
      }
    };
  }
  function cloneSingularField(value) {
    if (value === void 0) {
      return value;
    }
    if (value instanceof Message) {
      return value.clone();
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  function toU8Arr(input) {
    return input instanceof Uint8Array ? input : new Uint8Array(input);
  }
  var init_util_common = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/util-common.js"() {
      "use strict";
      init_enum();
      init_message();
      init_field();
      init_scalars();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js
  var InternalFieldList;
  var init_field_list = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field-list.js"() {
      "use strict";
      InternalFieldList = class {
        constructor(fields, normalizer) {
          this._fields = fields;
          this._normalizer = normalizer;
        }
        findJsonName(jsonName) {
          if (!this.jsonNames) {
            const t = {};
            for (const f of this.list()) {
              t[f.jsonName] = t[f.name] = f;
            }
            this.jsonNames = t;
          }
          return this.jsonNames[jsonName];
        }
        find(fieldNo) {
          if (!this.numbers) {
            const t = {};
            for (const f of this.list()) {
              t[f.no] = f;
            }
            this.numbers = t;
          }
          return this.numbers[fieldNo];
        }
        list() {
          if (!this.all) {
            this.all = this._normalizer(this._fields);
          }
          return this.all;
        }
        byNumber() {
          if (!this.numbersAsc) {
            this.numbersAsc = this.list().concat().sort((a, b) => a.no - b.no);
          }
          return this.numbersAsc;
        }
        byMember() {
          if (!this.members) {
            this.members = [];
            const a = this.members;
            let o;
            for (const f of this.list()) {
              if (f.oneof) {
                if (f.oneof !== o) {
                  o = f.oneof;
                  a.push(o);
                }
              } else {
                a.push(f);
              }
            }
          }
          return this.members;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/names.js
  function localName(desc) {
    switch (desc.kind) {
      case "field":
        return localFieldName(desc.name, desc.oneof !== void 0);
      case "oneof":
        return localOneofName(desc.name);
      case "enum":
      case "message":
      case "service": {
        const pkg = desc.file.proto.package;
        const offset = pkg === void 0 ? 0 : pkg.length + 1;
        const name = desc.typeName.substring(offset).replace(/\./g, "_");
        return safeObjectProperty(safeIdentifier(name));
      }
      case "enum_value": {
        const sharedPrefix = desc.parent.sharedPrefix;
        if (sharedPrefix === void 0) {
          return desc.name;
        }
        const name = desc.name.substring(sharedPrefix.length);
        return safeObjectProperty(name);
      }
      case "rpc": {
        let name = desc.name;
        if (name.length == 0) {
          return name;
        }
        name = name[0].toLowerCase() + name.substring(1);
        return safeObjectProperty(name);
      }
    }
  }
  function localFieldName(protoName, inOneof) {
    const name = protoCamelCase(protoName);
    if (inOneof) {
      return name;
    }
    return safeObjectProperty(safeMessageProperty(name));
  }
  function localOneofName(protoName) {
    return localFieldName(protoName, false);
  }
  function findEnumSharedPrefix(enumName, valueNames) {
    const prefix = camelToSnakeCase(enumName) + "_";
    for (const name of valueNames) {
      if (!name.toLowerCase().startsWith(prefix)) {
        return void 0;
      }
      const shortName = name.substring(prefix.length);
      if (shortName.length == 0) {
        return void 0;
      }
      if (/^\d/.test(shortName)) {
        return void 0;
      }
    }
    return prefix;
  }
  function camelToSnakeCase(camel) {
    return (camel.substring(0, 1) + camel.substring(1).replace(/[A-Z]/g, (c) => "_" + c)).toLowerCase();
  }
  function protoCamelCase(snakeCase) {
    let capNext = false;
    const b = [];
    for (let i = 0; i < snakeCase.length; i++) {
      let c = snakeCase.charAt(i);
      switch (c) {
        case "_":
          capNext = true;
          break;
        case "0":
        case "1":
        case "2":
        case "3":
        case "4":
        case "5":
        case "6":
        case "7":
        case "8":
        case "9":
          b.push(c);
          capNext = false;
          break;
        default:
          if (capNext) {
            capNext = false;
            c = c.toUpperCase();
          }
          b.push(c);
          break;
      }
    }
    return b.join("");
  }
  var fieldJsonName, reservedIdentifiers, reservedObjectProperties, reservedMessageProperties, fallback, safeMessageProperty, safeObjectProperty, safeIdentifier;
  var init_names = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/names.js"() {
      "use strict";
      fieldJsonName = protoCamelCase;
      reservedIdentifiers = /* @__PURE__ */ new Set([
        // ECMAScript 2015 keywords
        "break",
        "case",
        "catch",
        "class",
        "const",
        "continue",
        "debugger",
        "default",
        "delete",
        "do",
        "else",
        "export",
        "extends",
        "false",
        "finally",
        "for",
        "function",
        "if",
        "import",
        "in",
        "instanceof",
        "new",
        "null",
        "return",
        "super",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "var",
        "void",
        "while",
        "with",
        "yield",
        // ECMAScript 2015 future reserved keywords
        "enum",
        "implements",
        "interface",
        "let",
        "package",
        "private",
        "protected",
        "public",
        "static",
        // Class name cannot be 'Object' when targeting ES5 with module CommonJS
        "Object",
        // TypeScript keywords that cannot be used for types (as opposed to variables)
        "bigint",
        "number",
        "boolean",
        "string",
        "object",
        // Identifiers reserved for the runtime, so we can generate legible code
        "globalThis",
        "Uint8Array",
        "Partial"
      ]);
      reservedObjectProperties = /* @__PURE__ */ new Set([
        // names reserved by JavaScript
        "constructor",
        "toString",
        "toJSON",
        "valueOf"
      ]);
      reservedMessageProperties = /* @__PURE__ */ new Set([
        // names reserved by the runtime
        "getType",
        "clone",
        "equals",
        "fromBinary",
        "fromJson",
        "fromJsonString",
        "toBinary",
        "toJson",
        "toJsonString",
        // names reserved by the runtime for the future
        "toObject"
      ]);
      fallback = (name) => `${name}$`;
      safeMessageProperty = (name) => {
        if (reservedMessageProperties.has(name)) {
          return fallback(name);
        }
        return name;
      };
      safeObjectProperty = (name) => {
        if (reservedObjectProperties.has(name)) {
          return fallback(name);
        }
        return name;
      };
      safeIdentifier = (name) => {
        if (reservedIdentifiers.has(name)) {
          return fallback(name);
        }
        return name;
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/field.js
  var InternalOneofInfo;
  var init_field2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/field.js"() {
      "use strict";
      init_names();
      init_assert();
      InternalOneofInfo = class {
        constructor(name) {
          this.kind = "oneof";
          this.repeated = false;
          this.packed = false;
          this.opt = false;
          this.default = void 0;
          this.fields = [];
          this.name = name;
          this.localName = localOneofName(name);
        }
        addField(field) {
          assert(field.oneof === this, `field ${field.name} not one of ${this.name}`);
          this.fields.push(field);
        }
        findField(localName2) {
          if (!this._lookup) {
            this._lookup = /* @__PURE__ */ Object.create(null);
            for (let i = 0; i < this.fields.length; i++) {
              this._lookup[this.fields[i].localName] = this.fields[i];
            }
          }
          return this._lookup[localName2];
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto3.js
  function normalizeFieldInfosProto3(fieldInfos) {
    var _a, _b, _c;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      f.packed = (_c = field.packed) !== null && _c !== void 0 ? _c : field.kind == "enum" || field.kind == "scalar" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }
  var proto3;
  var init_proto3 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto3.js"() {
      "use strict";
      init_proto_runtime();
      init_binary_format_proto3();
      init_json_format_proto3();
      init_util_common();
      init_field_list();
      init_scalars();
      init_field();
      init_field2();
      init_names();
      proto3 = makeProtoRuntime("proto3", makeJsonFormatProto3(), makeBinaryFormatProto3(), Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList(fields) {
          return new InternalFieldList(fields, normalizeFieldInfosProto3);
        },
        initFields(target) {
          for (const member of target.getType().fields.byMember()) {
            if (member.opt) {
              continue;
            }
            const name = member.localName, t = target;
            if (member.repeated) {
              t[name] = [];
              continue;
            }
            switch (member.kind) {
              case "oneof":
                t[name] = { case: void 0 };
                break;
              case "enum":
                t[name] = 0;
                break;
              case "map":
                t[name] = {};
                break;
              case "scalar":
                t[name] = scalarDefaultValue(member.T);
                break;
              case "message":
                break;
            }
          }
        }
      }));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto2.js
  function makeBinaryFormatProto2() {
    return Object.assign(Object.assign({}, makeBinaryFormatCommon()), { writeMessage(message, writer, options) {
      const type = message.getType();
      let field;
      try {
        for (field of type.fields.byNumber()) {
          let value, repeated = field.repeated, localName2 = field.localName;
          if (field.oneof) {
            const oneof = message[field.oneof.localName];
            if (oneof.case !== localName2) {
              continue;
            }
            value = oneof.value;
          } else {
            value = message[localName2];
            if (value === void 0 && !field.oneof && !field.opt) {
              throw new Error(`cannot encode field ${type.typeName}.${field.name} to binary: required field not set`);
            }
          }
          switch (field.kind) {
            case "scalar":
            case "enum":
              let scalarType = field.kind == "enum" ? ScalarType.INT32 : field.T;
              if (repeated) {
                if (field.packed) {
                  writePacked(writer, scalarType, field.no, value);
                } else {
                  for (const item of value) {
                    writeScalar(writer, scalarType, field.no, item, true);
                  }
                }
              } else {
                if (value !== void 0) {
                  writeScalar(writer, scalarType, field.no, value, true);
                }
              }
              break;
            case "message":
              if (repeated) {
                for (const item of value) {
                  writeMessageField(writer, options, field.T, field.no, item);
                }
              } else {
                writeMessageField(writer, options, field.T, field.no, value);
              }
              break;
            case "map":
              for (const [key, val] of Object.entries(value)) {
                writeMapEntry(writer, options, field, key, val);
              }
              break;
          }
        }
      } catch (e) {
        let m = field ? `cannot encode field ${type.typeName}.${field === null || field === void 0 ? void 0 : field.name} to binary` : `cannot encode message ${type.typeName} to binary`;
        let r = e instanceof Error ? e.message : String(e);
        throw new Error(m + (r.length > 0 ? `: ${r}` : ""));
      }
      if (options.writeUnknownFields) {
        this.writeUnknownFields(message, writer);
      }
      return writer;
    } });
  }
  var init_binary_format_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/binary-format-proto2.js"() {
      "use strict";
      init_field();
      init_binary_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto2.js
  function makeJsonFormatProto2() {
    return makeJsonFormatCommon((writeEnum2, writeScalar3) => {
      return function writeField(field, value, options) {
        if (field.kind == "map") {
          const jsonObj = {};
          switch (field.V.kind) {
            case "scalar":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                const val = writeScalar3(field.V.T, entryValue, true);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
            case "message":
              for (const [entryKey, entryValue] of Object.entries(value)) {
                jsonObj[entryKey.toString()] = entryValue.toJson(options);
              }
              break;
            case "enum":
              const enumType2 = field.V.T;
              for (const [entryKey, entryValue] of Object.entries(value)) {
                assert(entryValue === void 0 || typeof entryValue == "number");
                const val = writeEnum2(enumType2, entryValue, true, options.enumAsInteger);
                assert(val !== void 0);
                jsonObj[entryKey.toString()] = val;
              }
              break;
          }
          return options.emitDefaultValues || Object.keys(jsonObj).length > 0 ? jsonObj : void 0;
        } else if (field.repeated) {
          const jsonArr = [];
          switch (field.kind) {
            case "scalar":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeScalar3(field.T, value[i], true));
              }
              break;
            case "enum":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(writeEnum2(field.T, value[i], true, options.enumAsInteger));
              }
              break;
            case "message":
              for (let i = 0; i < value.length; i++) {
                jsonArr.push(value[i].toJson(options));
              }
              break;
          }
          return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : void 0;
        } else {
          if (value === void 0) {
            if (!field.oneof && !field.opt) {
              throw `required field not set`;
            }
            return void 0;
          }
          switch (field.kind) {
            case "scalar":
              return writeScalar3(field.T, value, true);
            case "enum":
              return writeEnum2(field.T, value, true, options.enumAsInteger);
            case "message":
              return wrapField(field.T, value).toJson(options);
          }
        }
      };
    });
  }
  var init_json_format_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/json-format-proto2.js"() {
      "use strict";
      init_field_wrapper();
      init_assert();
      init_json_format_common();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto2.js
  function normalizeFieldInfosProto2(fieldInfos) {
    var _a, _b, _c;
    const r = [];
    let o;
    for (const field of typeof fieldInfos == "function" ? fieldInfos() : fieldInfos) {
      const f = field;
      f.localName = localFieldName(field.name, field.oneof !== void 0);
      f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);
      f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;
      f.packed = (_c = field.packed) !== null && _c !== void 0 ? _c : false;
      if (field.oneof !== void 0) {
        const ooname = typeof field.oneof == "string" ? field.oneof : field.oneof.name;
        if (!o || o.name != ooname) {
          o = new InternalOneofInfo(ooname);
        }
        f.oneof = o;
        o.addField(f);
      }
      r.push(f);
    }
    return r;
  }
  var proto2;
  var init_proto2 = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto2.js"() {
      "use strict";
      init_proto_runtime();
      init_binary_format_proto2();
      init_util_common();
      init_field_list();
      init_field2();
      init_names();
      init_json_format_proto2();
      proto2 = makeProtoRuntime("proto2", makeJsonFormatProto2(), makeBinaryFormatProto2(), Object.assign(Object.assign({}, makeUtilCommon()), {
        newFieldList(fields) {
          return new InternalFieldList(fields, normalizeFieldInfosProto2);
        },
        initFields(target) {
          for (const member of target.getType().fields.byMember()) {
            const name = member.localName, t = target;
            if (member.repeated) {
              t[name] = [];
              continue;
            }
            switch (member.kind) {
              case "oneof":
                t[name] = { case: void 0 };
                break;
              case "map":
                t[name] = {};
                break;
              case "scalar":
              case "enum":
              case "message":
                break;
            }
          }
        }
      }));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-double.js
  var protoDouble;
  var init_proto_double = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-double.js"() {
      "use strict";
      protoDouble = {
        NaN: Number.NaN,
        POSITIVE_INFINITY: Number.POSITIVE_INFINITY,
        NEGATIVE_INFINITY: Number.NEGATIVE_INFINITY
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/proto-delimited.js
  var __asyncValues, __await, __asyncGenerator, protoDelimited;
  var init_proto_delimited = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/proto-delimited.js"() {
      "use strict";
      init_binary_format_common();
      init_binary_encoding();
      __asyncValues = function(o) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i);
        function verb(n) {
          i[n] = o[n] && function(v) {
            return new Promise(function(resolve, reject) {
              v = o[n](v), settle(resolve, reject, v.done, v.value);
            });
          };
        }
        function settle(resolve, reject, d, v) {
          Promise.resolve(v).then(function(v2) {
            resolve({ value: v2, done: d });
          }, reject);
        }
      };
      __await = function(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
      };
      __asyncGenerator = function(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
          throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
          return this;
        }, i;
        function verb(n) {
          if (g[n])
            i[n] = function(v) {
              return new Promise(function(a, b) {
                q.push([n, v, a, b]) > 1 || resume(n, v);
              });
            };
        }
        function resume(n, v) {
          try {
            step(g[n](v));
          } catch (e) {
            settle(q[0][3], e);
          }
        }
        function step(r) {
          r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
        }
        function fulfill(value) {
          resume("next", value);
        }
        function reject(value) {
          resume("throw", value);
        }
        function settle(f, v) {
          if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]);
        }
      };
      protoDelimited = {
        /**
         * Serialize a message, prefixing it with its size.
         */
        enc(message, options) {
          const opt = makeBinaryFormatCommon().makeWriteOptions(options);
          return opt.writerFactory().bytes(message.toBinary(opt)).finish();
        },
        /**
         * Parse a size-delimited message, ignoring extra bytes.
         */
        dec(type, bytes, options) {
          const opt = makeBinaryFormatCommon().makeReadOptions(options);
          return type.fromBinary(opt.readerFactory(bytes).bytes(), opt);
        },
        /**
         * Parse a stream of size-delimited messages.
         */
        decStream(type, iterable) {
          return __asyncGenerator(this, arguments, function* decStream_1() {
            var _a, e_1, _b, _c;
            function append(buffer2, chunk) {
              const n = new Uint8Array(buffer2.byteLength + chunk.byteLength);
              n.set(buffer2);
              n.set(chunk, buffer2.length);
              return n;
            }
            let buffer = new Uint8Array(0);
            try {
              for (var _d = true, iterable_1 = __asyncValues(iterable), iterable_1_1; iterable_1_1 = yield __await(iterable_1.next()), _a = iterable_1_1.done, !_a; _d = true) {
                _c = iterable_1_1.value;
                _d = false;
                const chunk = _c;
                buffer = append(buffer, chunk);
                for (; ; ) {
                  const size = protoDelimited.peekSize(buffer);
                  if (size.eof) {
                    break;
                  }
                  if (size.offset + size.size > buffer.byteLength) {
                    break;
                  }
                  yield yield __await(protoDelimited.dec(type, buffer));
                  buffer = buffer.subarray(size.offset + size.size);
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (!_d && !_a && (_b = iterable_1.return))
                  yield __await(_b.call(iterable_1));
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
            if (buffer.byteLength > 0) {
              throw new Error("incomplete data");
            }
          });
        },
        /**
         * Decodes the size from the given size-delimited message, which may be
         * incomplete.
         *
         * Returns an object with the following properties:
         * - size: The size of the delimited message in bytes
         * - offset: The offset in the given byte array where the message starts
         * - eof: true
         *
         * If the size-delimited data does not include all bytes of the varint size,
         * the following object is returned:
         * - size: null
         * - offset: null
         * - eof: false
         *
         * This function can be used to implement parsing of size-delimited messages
         * from a stream.
         */
        peekSize(data) {
          const sizeEof = { eof: true, size: null, offset: null };
          for (let i = 0; i < 10; i++) {
            if (i > data.byteLength) {
              return sizeEof;
            }
            if ((data[i] & 128) == 0) {
              const reader = new BinaryReader(data);
              let size;
              try {
                size = reader.uint32();
              } catch (e) {
                if (e instanceof RangeError) {
                  return sizeEof;
                }
                throw e;
              }
              return {
                eof: false,
                size,
                offset: reader.pos
              };
            }
          }
          throw new Error("invalid varint");
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/private/reify-wkt.js
  function reifyWkt(message) {
    switch (message.typeName) {
      case "google.protobuf.Any": {
        const typeUrl = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING);
        const value = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.BYTES);
        if (typeUrl && value) {
          return {
            typeName: message.typeName,
            typeUrl,
            value
          };
        }
        break;
      }
      case "google.protobuf.Timestamp": {
        const seconds = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT64);
        const nanos = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT32);
        if (seconds && nanos) {
          return {
            typeName: message.typeName,
            seconds,
            nanos
          };
        }
        break;
      }
      case "google.protobuf.Duration": {
        const seconds = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT64);
        const nanos = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.INT32);
        if (seconds && nanos) {
          return {
            typeName: message.typeName,
            seconds,
            nanos
          };
        }
        break;
      }
      case "google.protobuf.Struct": {
        const fields = message.fields.find((f) => f.number == 1 && !f.repeated);
        if ((fields === null || fields === void 0 ? void 0 : fields.fieldKind) !== "map" || fields.mapValue.kind !== "message" || fields.mapValue.message.typeName !== "google.protobuf.Value") {
          break;
        }
        return { typeName: message.typeName, fields };
      }
      case "google.protobuf.Value": {
        const kind = message.oneofs.find((o) => o.name === "kind");
        const nullValue = message.fields.find((f) => f.number == 1 && f.oneof === kind);
        if ((nullValue === null || nullValue === void 0 ? void 0 : nullValue.fieldKind) !== "enum" || nullValue.enum.typeName !== "google.protobuf.NullValue") {
          return void 0;
        }
        const numberValue = message.fields.find((f) => f.number == 2 && f.fieldKind == "scalar" && f.scalar === ScalarType.DOUBLE && f.oneof === kind);
        const stringValue = message.fields.find((f) => f.number == 3 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING && f.oneof === kind);
        const boolValue = message.fields.find((f) => f.number == 4 && f.fieldKind == "scalar" && f.scalar === ScalarType.BOOL && f.oneof === kind);
        const structValue = message.fields.find((f) => f.number == 5 && f.oneof === kind);
        if ((structValue === null || structValue === void 0 ? void 0 : structValue.fieldKind) !== "message" || structValue.message.typeName !== "google.protobuf.Struct") {
          return void 0;
        }
        const listValue = message.fields.find((f) => f.number == 6 && f.oneof === kind);
        if ((listValue === null || listValue === void 0 ? void 0 : listValue.fieldKind) !== "message" || listValue.message.typeName !== "google.protobuf.ListValue") {
          return void 0;
        }
        if (kind && numberValue && stringValue && boolValue) {
          return {
            typeName: message.typeName,
            kind,
            nullValue,
            numberValue,
            stringValue,
            boolValue,
            structValue,
            listValue
          };
        }
        break;
      }
      case "google.protobuf.ListValue": {
        const values = message.fields.find((f) => f.number == 1 && f.repeated);
        if ((values === null || values === void 0 ? void 0 : values.fieldKind) != "message" || values.message.typeName !== "google.protobuf.Value") {
          break;
        }
        return { typeName: message.typeName, values };
      }
      case "google.protobuf.FieldMask": {
        const paths = message.fields.find((f) => f.number == 1 && f.fieldKind == "scalar" && f.scalar === ScalarType.STRING && f.repeated);
        if (paths) {
          return { typeName: message.typeName, paths };
        }
        break;
      }
      case "google.protobuf.DoubleValue":
      case "google.protobuf.FloatValue":
      case "google.protobuf.Int64Value":
      case "google.protobuf.UInt64Value":
      case "google.protobuf.Int32Value":
      case "google.protobuf.UInt32Value":
      case "google.protobuf.BoolValue":
      case "google.protobuf.StringValue":
      case "google.protobuf.BytesValue": {
        const value = message.fields.find((f) => f.number == 1 && f.name == "value");
        if (!value) {
          break;
        }
        if (value.fieldKind !== "scalar") {
          break;
        }
        return { typeName: message.typeName, value };
      }
    }
    return void 0;
  }
  var init_reify_wkt = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/private/reify-wkt.js"() {
      "use strict";
      init_field();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/codegen-info.js
  var packageName, codegenInfo;
  var init_codegen_info = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/codegen-info.js"() {
      "use strict";
      init_names();
      init_field_wrapper();
      init_scalars();
      init_reify_wkt();
      packageName = "@bufbuild/protobuf";
      codegenInfo = {
        packageName,
        localName,
        reifyWkt,
        getUnwrappedFieldType,
        scalarDefaultValue,
        safeIdentifier,
        safeObjectProperty,
        // prettier-ignore
        symbols: {
          proto2: { typeOnly: false, privateImportPath: "./proto2.js", publicImportPath: packageName },
          proto3: { typeOnly: false, privateImportPath: "./proto3.js", publicImportPath: packageName },
          Message: { typeOnly: false, privateImportPath: "./message.js", publicImportPath: packageName },
          PartialMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
          PlainMessage: { typeOnly: true, privateImportPath: "./message.js", publicImportPath: packageName },
          FieldList: { typeOnly: true, privateImportPath: "./field-list.js", publicImportPath: packageName },
          MessageType: { typeOnly: true, privateImportPath: "./message-type.js", publicImportPath: packageName },
          BinaryReadOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
          BinaryWriteOptions: { typeOnly: true, privateImportPath: "./binary-format.js", publicImportPath: packageName },
          JsonReadOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonWriteOptions: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonValue: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          JsonObject: { typeOnly: true, privateImportPath: "./json-format.js", publicImportPath: packageName },
          protoDouble: { typeOnly: false, privateImportPath: "./proto-double.js", publicImportPath: packageName },
          protoInt64: { typeOnly: false, privateImportPath: "./proto-int64.js", publicImportPath: packageName },
          ScalarType: { typeOnly: false, privateImportPath: "./field.js", publicImportPath: packageName },
          MethodKind: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
          MethodIdempotency: { typeOnly: false, privateImportPath: "./service-type.js", publicImportPath: packageName },
          IMessageTypeRegistry: { typeOnly: true, privateImportPath: "./type-registry.js", publicImportPath: packageName }
        },
        wktSourceFiles: [
          "google/protobuf/compiler/plugin.proto",
          "google/protobuf/any.proto",
          "google/protobuf/api.proto",
          "google/protobuf/descriptor.proto",
          "google/protobuf/duration.proto",
          "google/protobuf/empty.proto",
          "google/protobuf/field_mask.proto",
          "google/protobuf/source_context.proto",
          "google/protobuf/struct.proto",
          "google/protobuf/timestamp.proto",
          "google/protobuf/type.proto",
          "google/protobuf/wrappers.proto"
        ]
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/service-type.js
  var MethodKind, MethodIdempotency;
  var init_service_type = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/service-type.js"() {
      "use strict";
      (function(MethodKind2) {
        MethodKind2[MethodKind2["Unary"] = 0] = "Unary";
        MethodKind2[MethodKind2["ServerStreaming"] = 1] = "ServerStreaming";
        MethodKind2[MethodKind2["ClientStreaming"] = 2] = "ClientStreaming";
        MethodKind2[MethodKind2["BiDiStreaming"] = 3] = "BiDiStreaming";
      })(MethodKind || (MethodKind = {}));
      (function(MethodIdempotency2) {
        MethodIdempotency2[MethodIdempotency2["NoSideEffects"] = 1] = "NoSideEffects";
        MethodIdempotency2[MethodIdempotency2["Idempotent"] = 2] = "Idempotent";
      })(MethodIdempotency || (MethodIdempotency = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js
  var FileDescriptorSet, FileDescriptorProto, DescriptorProto, DescriptorProto_ExtensionRange, DescriptorProto_ReservedRange, ExtensionRangeOptions, ExtensionRangeOptions_VerificationState, ExtensionRangeOptions_Declaration, FieldDescriptorProto, FieldDescriptorProto_Type, FieldDescriptorProto_Label, OneofDescriptorProto, EnumDescriptorProto, EnumDescriptorProto_EnumReservedRange, EnumValueDescriptorProto, ServiceDescriptorProto, MethodDescriptorProto, FileOptions, FileOptions_OptimizeMode, MessageOptions, FieldOptions, FieldOptions_CType, FieldOptions_JSType, FieldOptions_OptionRetention, FieldOptions_OptionTargetType, OneofOptions, EnumOptions, EnumValueOptions, ServiceOptions, MethodOptions, MethodOptions_IdempotencyLevel, UninterpretedOption, UninterpretedOption_NamePart, SourceCodeInfo, SourceCodeInfo_Location, GeneratedCodeInfo, GeneratedCodeInfo_Annotation, GeneratedCodeInfo_Annotation_Semantic;
  var init_descriptor_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/descriptor_pb.js"() {
      "use strict";
      init_message();
      init_proto2();
      FileDescriptorSet = class _FileDescriptorSet extends Message {
        constructor(data) {
          super();
          this.file = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileDescriptorSet().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileDescriptorSet().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileDescriptorSet().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileDescriptorSet, a, b);
        }
      };
      FileDescriptorSet.runtime = proto2;
      FileDescriptorSet.typeName = "google.protobuf.FileDescriptorSet";
      FileDescriptorSet.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "file", kind: "message", T: FileDescriptorProto, repeated: true }
      ]);
      FileDescriptorProto = class _FileDescriptorProto extends Message {
        constructor(data) {
          super();
          this.dependency = [];
          this.publicDependency = [];
          this.weakDependency = [];
          this.messageType = [];
          this.enumType = [];
          this.service = [];
          this.extension = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileDescriptorProto, a, b);
        }
      };
      FileDescriptorProto.runtime = proto2;
      FileDescriptorProto.typeName = "google.protobuf.FileDescriptorProto";
      FileDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "package", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "dependency", kind: "scalar", T: 9, repeated: true },
        { no: 10, name: "public_dependency", kind: "scalar", T: 5, repeated: true },
        { no: 11, name: "weak_dependency", kind: "scalar", T: 5, repeated: true },
        { no: 4, name: "message_type", kind: "message", T: DescriptorProto, repeated: true },
        { no: 5, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
        { no: 6, name: "service", kind: "message", T: ServiceDescriptorProto, repeated: true },
        { no: 7, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 8, name: "options", kind: "message", T: FileOptions, opt: true },
        { no: 9, name: "source_code_info", kind: "message", T: SourceCodeInfo, opt: true },
        { no: 12, name: "syntax", kind: "scalar", T: 9, opt: true },
        { no: 13, name: "edition", kind: "scalar", T: 9, opt: true }
      ]);
      DescriptorProto = class _DescriptorProto extends Message {
        constructor(data) {
          super();
          this.field = [];
          this.extension = [];
          this.nestedType = [];
          this.enumType = [];
          this.extensionRange = [];
          this.oneofDecl = [];
          this.reservedRange = [];
          this.reservedName = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto, a, b);
        }
      };
      DescriptorProto.runtime = proto2;
      DescriptorProto.typeName = "google.protobuf.DescriptorProto";
      DescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "field", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 6, name: "extension", kind: "message", T: FieldDescriptorProto, repeated: true },
        { no: 3, name: "nested_type", kind: "message", T: DescriptorProto, repeated: true },
        { no: 4, name: "enum_type", kind: "message", T: EnumDescriptorProto, repeated: true },
        { no: 5, name: "extension_range", kind: "message", T: DescriptorProto_ExtensionRange, repeated: true },
        { no: 8, name: "oneof_decl", kind: "message", T: OneofDescriptorProto, repeated: true },
        { no: 7, name: "options", kind: "message", T: MessageOptions, opt: true },
        { no: 9, name: "reserved_range", kind: "message", T: DescriptorProto_ReservedRange, repeated: true },
        { no: 10, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
      ]);
      DescriptorProto_ExtensionRange = class _DescriptorProto_ExtensionRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto_ExtensionRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto_ExtensionRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto_ExtensionRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto_ExtensionRange, a, b);
        }
      };
      DescriptorProto_ExtensionRange.runtime = proto2;
      DescriptorProto_ExtensionRange.typeName = "google.protobuf.DescriptorProto.ExtensionRange";
      DescriptorProto_ExtensionRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "options", kind: "message", T: ExtensionRangeOptions, opt: true }
      ]);
      DescriptorProto_ReservedRange = class _DescriptorProto_ReservedRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DescriptorProto_ReservedRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DescriptorProto_ReservedRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DescriptorProto_ReservedRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_DescriptorProto_ReservedRange, a, b);
        }
      };
      DescriptorProto_ReservedRange.runtime = proto2;
      DescriptorProto_ReservedRange.typeName = "google.protobuf.DescriptorProto.ReservedRange";
      DescriptorProto_ReservedRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
      ]);
      ExtensionRangeOptions = class _ExtensionRangeOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          this.declaration = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ExtensionRangeOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ExtensionRangeOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ExtensionRangeOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ExtensionRangeOptions, a, b);
        }
      };
      ExtensionRangeOptions.runtime = proto2;
      ExtensionRangeOptions.typeName = "google.protobuf.ExtensionRangeOptions";
      ExtensionRangeOptions.fields = proto2.util.newFieldList(() => [
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true },
        { no: 2, name: "declaration", kind: "message", T: ExtensionRangeOptions_Declaration, repeated: true },
        { no: 3, name: "verification", kind: "enum", T: proto2.getEnumType(ExtensionRangeOptions_VerificationState), opt: true, default: ExtensionRangeOptions_VerificationState.UNVERIFIED }
      ]);
      (function(ExtensionRangeOptions_VerificationState2) {
        ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["DECLARATION"] = 0] = "DECLARATION";
        ExtensionRangeOptions_VerificationState2[ExtensionRangeOptions_VerificationState2["UNVERIFIED"] = 1] = "UNVERIFIED";
      })(ExtensionRangeOptions_VerificationState || (ExtensionRangeOptions_VerificationState = {}));
      proto2.util.setEnumType(ExtensionRangeOptions_VerificationState, "google.protobuf.ExtensionRangeOptions.VerificationState", [
        { no: 0, name: "DECLARATION" },
        { no: 1, name: "UNVERIFIED" }
      ]);
      ExtensionRangeOptions_Declaration = class _ExtensionRangeOptions_Declaration extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ExtensionRangeOptions_Declaration().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ExtensionRangeOptions_Declaration().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ExtensionRangeOptions_Declaration().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ExtensionRangeOptions_Declaration, a, b);
        }
      };
      ExtensionRangeOptions_Declaration.runtime = proto2;
      ExtensionRangeOptions_Declaration.typeName = "google.protobuf.ExtensionRangeOptions.Declaration";
      ExtensionRangeOptions_Declaration.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "full_name", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "type", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "is_repeated", kind: "scalar", T: 8, opt: true },
        { no: 5, name: "reserved", kind: "scalar", T: 8, opt: true },
        { no: 6, name: "repeated", kind: "scalar", T: 8, opt: true }
      ]);
      FieldDescriptorProto = class _FieldDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FieldDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FieldDescriptorProto, a, b);
        }
      };
      FieldDescriptorProto.runtime = proto2;
      FieldDescriptorProto.typeName = "google.protobuf.FieldDescriptorProto";
      FieldDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "label", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Label), opt: true },
        { no: 5, name: "type", kind: "enum", T: proto2.getEnumType(FieldDescriptorProto_Type), opt: true },
        { no: 6, name: "type_name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "extendee", kind: "scalar", T: 9, opt: true },
        { no: 7, name: "default_value", kind: "scalar", T: 9, opt: true },
        { no: 9, name: "oneof_index", kind: "scalar", T: 5, opt: true },
        { no: 10, name: "json_name", kind: "scalar", T: 9, opt: true },
        { no: 8, name: "options", kind: "message", T: FieldOptions, opt: true },
        { no: 17, name: "proto3_optional", kind: "scalar", T: 8, opt: true }
      ]);
      (function(FieldDescriptorProto_Type2) {
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["DOUBLE"] = 1] = "DOUBLE";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FLOAT"] = 2] = "FLOAT";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT64"] = 3] = "INT64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT64"] = 4] = "UINT64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["INT32"] = 5] = "INT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED64"] = 6] = "FIXED64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["FIXED32"] = 7] = "FIXED32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BOOL"] = 8] = "BOOL";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["STRING"] = 9] = "STRING";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["GROUP"] = 10] = "GROUP";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["MESSAGE"] = 11] = "MESSAGE";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["BYTES"] = 12] = "BYTES";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["UINT32"] = 13] = "UINT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["ENUM"] = 14] = "ENUM";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED32"] = 15] = "SFIXED32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SFIXED64"] = 16] = "SFIXED64";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT32"] = 17] = "SINT32";
        FieldDescriptorProto_Type2[FieldDescriptorProto_Type2["SINT64"] = 18] = "SINT64";
      })(FieldDescriptorProto_Type || (FieldDescriptorProto_Type = {}));
      proto2.util.setEnumType(FieldDescriptorProto_Type, "google.protobuf.FieldDescriptorProto.Type", [
        { no: 1, name: "TYPE_DOUBLE" },
        { no: 2, name: "TYPE_FLOAT" },
        { no: 3, name: "TYPE_INT64" },
        { no: 4, name: "TYPE_UINT64" },
        { no: 5, name: "TYPE_INT32" },
        { no: 6, name: "TYPE_FIXED64" },
        { no: 7, name: "TYPE_FIXED32" },
        { no: 8, name: "TYPE_BOOL" },
        { no: 9, name: "TYPE_STRING" },
        { no: 10, name: "TYPE_GROUP" },
        { no: 11, name: "TYPE_MESSAGE" },
        { no: 12, name: "TYPE_BYTES" },
        { no: 13, name: "TYPE_UINT32" },
        { no: 14, name: "TYPE_ENUM" },
        { no: 15, name: "TYPE_SFIXED32" },
        { no: 16, name: "TYPE_SFIXED64" },
        { no: 17, name: "TYPE_SINT32" },
        { no: 18, name: "TYPE_SINT64" }
      ]);
      (function(FieldDescriptorProto_Label2) {
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["OPTIONAL"] = 1] = "OPTIONAL";
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REQUIRED"] = 2] = "REQUIRED";
        FieldDescriptorProto_Label2[FieldDescriptorProto_Label2["REPEATED"] = 3] = "REPEATED";
      })(FieldDescriptorProto_Label || (FieldDescriptorProto_Label = {}));
      proto2.util.setEnumType(FieldDescriptorProto_Label, "google.protobuf.FieldDescriptorProto.Label", [
        { no: 1, name: "LABEL_OPTIONAL" },
        { no: 2, name: "LABEL_REQUIRED" },
        { no: 3, name: "LABEL_REPEATED" }
      ]);
      OneofDescriptorProto = class _OneofDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _OneofDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _OneofDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _OneofDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_OneofDescriptorProto, a, b);
        }
      };
      OneofDescriptorProto.runtime = proto2;
      OneofDescriptorProto.typeName = "google.protobuf.OneofDescriptorProto";
      OneofDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "options", kind: "message", T: OneofOptions, opt: true }
      ]);
      EnumDescriptorProto = class _EnumDescriptorProto extends Message {
        constructor(data) {
          super();
          this.value = [];
          this.reservedRange = [];
          this.reservedName = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumDescriptorProto, a, b);
        }
      };
      EnumDescriptorProto.runtime = proto2;
      EnumDescriptorProto.typeName = "google.protobuf.EnumDescriptorProto";
      EnumDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "value", kind: "message", T: EnumValueDescriptorProto, repeated: true },
        { no: 3, name: "options", kind: "message", T: EnumOptions, opt: true },
        { no: 4, name: "reserved_range", kind: "message", T: EnumDescriptorProto_EnumReservedRange, repeated: true },
        { no: 5, name: "reserved_name", kind: "scalar", T: 9, repeated: true }
      ]);
      EnumDescriptorProto_EnumReservedRange = class _EnumDescriptorProto_EnumReservedRange extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumDescriptorProto_EnumReservedRange().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumDescriptorProto_EnumReservedRange, a, b);
        }
      };
      EnumDescriptorProto_EnumReservedRange.runtime = proto2;
      EnumDescriptorProto_EnumReservedRange.typeName = "google.protobuf.EnumDescriptorProto.EnumReservedRange";
      EnumDescriptorProto_EnumReservedRange.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "start", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "end", kind: "scalar", T: 5, opt: true }
      ]);
      EnumValueDescriptorProto = class _EnumValueDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValueDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValueDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValueDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumValueDescriptorProto, a, b);
        }
      };
      EnumValueDescriptorProto.runtime = proto2;
      EnumValueDescriptorProto.typeName = "google.protobuf.EnumValueDescriptorProto";
      EnumValueDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "number", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "options", kind: "message", T: EnumValueOptions, opt: true }
      ]);
      ServiceDescriptorProto = class _ServiceDescriptorProto extends Message {
        constructor(data) {
          super();
          this.method = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ServiceDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ServiceDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ServiceDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ServiceDescriptorProto, a, b);
        }
      };
      ServiceDescriptorProto.runtime = proto2;
      ServiceDescriptorProto.typeName = "google.protobuf.ServiceDescriptorProto";
      ServiceDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "method", kind: "message", T: MethodDescriptorProto, repeated: true },
        { no: 3, name: "options", kind: "message", T: ServiceOptions, opt: true }
      ]);
      MethodDescriptorProto = class _MethodDescriptorProto extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MethodDescriptorProto().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MethodDescriptorProto().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MethodDescriptorProto().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MethodDescriptorProto, a, b);
        }
      };
      MethodDescriptorProto.runtime = proto2;
      MethodDescriptorProto.typeName = "google.protobuf.MethodDescriptorProto";
      MethodDescriptorProto.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "input_type", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "output_type", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "options", kind: "message", T: MethodOptions, opt: true },
        { no: 5, name: "client_streaming", kind: "scalar", T: 8, opt: true, default: false },
        { no: 6, name: "server_streaming", kind: "scalar", T: 8, opt: true, default: false }
      ]);
      FileOptions = class _FileOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FileOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FileOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FileOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FileOptions, a, b);
        }
      };
      FileOptions.runtime = proto2;
      FileOptions.typeName = "google.protobuf.FileOptions";
      FileOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "java_package", kind: "scalar", T: 9, opt: true },
        { no: 8, name: "java_outer_classname", kind: "scalar", T: 9, opt: true },
        { no: 10, name: "java_multiple_files", kind: "scalar", T: 8, opt: true, default: false },
        { no: 20, name: "java_generate_equals_and_hash", kind: "scalar", T: 8, opt: true },
        { no: 27, name: "java_string_check_utf8", kind: "scalar", T: 8, opt: true, default: false },
        { no: 9, name: "optimize_for", kind: "enum", T: proto2.getEnumType(FileOptions_OptimizeMode), opt: true, default: FileOptions_OptimizeMode.SPEED },
        { no: 11, name: "go_package", kind: "scalar", T: 9, opt: true },
        { no: 16, name: "cc_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 17, name: "java_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 18, name: "py_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 42, name: "php_generic_services", kind: "scalar", T: 8, opt: true, default: false },
        { no: 23, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 31, name: "cc_enable_arenas", kind: "scalar", T: 8, opt: true, default: true },
        { no: 36, name: "objc_class_prefix", kind: "scalar", T: 9, opt: true },
        { no: 37, name: "csharp_namespace", kind: "scalar", T: 9, opt: true },
        { no: 39, name: "swift_prefix", kind: "scalar", T: 9, opt: true },
        { no: 40, name: "php_class_prefix", kind: "scalar", T: 9, opt: true },
        { no: 41, name: "php_namespace", kind: "scalar", T: 9, opt: true },
        { no: 44, name: "php_metadata_namespace", kind: "scalar", T: 9, opt: true },
        { no: 45, name: "ruby_package", kind: "scalar", T: 9, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(FileOptions_OptimizeMode2) {
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["SPEED"] = 1] = "SPEED";
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["CODE_SIZE"] = 2] = "CODE_SIZE";
        FileOptions_OptimizeMode2[FileOptions_OptimizeMode2["LITE_RUNTIME"] = 3] = "LITE_RUNTIME";
      })(FileOptions_OptimizeMode || (FileOptions_OptimizeMode = {}));
      proto2.util.setEnumType(FileOptions_OptimizeMode, "google.protobuf.FileOptions.OptimizeMode", [
        { no: 1, name: "SPEED" },
        { no: 2, name: "CODE_SIZE" },
        { no: 3, name: "LITE_RUNTIME" }
      ]);
      MessageOptions = class _MessageOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MessageOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MessageOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MessageOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MessageOptions, a, b);
        }
      };
      MessageOptions.runtime = proto2;
      MessageOptions.typeName = "google.protobuf.MessageOptions";
      MessageOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "message_set_wire_format", kind: "scalar", T: 8, opt: true, default: false },
        { no: 2, name: "no_standard_descriptor_accessor", kind: "scalar", T: 8, opt: true, default: false },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 7, name: "map_entry", kind: "scalar", T: 8, opt: true },
        { no: 11, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      FieldOptions = class _FieldOptions extends Message {
        constructor(data) {
          super();
          this.targets = [];
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _FieldOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_FieldOptions, a, b);
        }
      };
      FieldOptions.runtime = proto2;
      FieldOptions.typeName = "google.protobuf.FieldOptions";
      FieldOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "ctype", kind: "enum", T: proto2.getEnumType(FieldOptions_CType), opt: true, default: FieldOptions_CType.STRING },
        { no: 2, name: "packed", kind: "scalar", T: 8, opt: true },
        { no: 6, name: "jstype", kind: "enum", T: proto2.getEnumType(FieldOptions_JSType), opt: true, default: FieldOptions_JSType.JS_NORMAL },
        { no: 5, name: "lazy", kind: "scalar", T: 8, opt: true, default: false },
        { no: 15, name: "unverified_lazy", kind: "scalar", T: 8, opt: true, default: false },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 10, name: "weak", kind: "scalar", T: 8, opt: true, default: false },
        { no: 16, name: "debug_redact", kind: "scalar", T: 8, opt: true, default: false },
        { no: 17, name: "retention", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionRetention), opt: true },
        { no: 18, name: "target", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), opt: true },
        { no: 19, name: "targets", kind: "enum", T: proto2.getEnumType(FieldOptions_OptionTargetType), repeated: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(FieldOptions_CType2) {
        FieldOptions_CType2[FieldOptions_CType2["STRING"] = 0] = "STRING";
        FieldOptions_CType2[FieldOptions_CType2["CORD"] = 1] = "CORD";
        FieldOptions_CType2[FieldOptions_CType2["STRING_PIECE"] = 2] = "STRING_PIECE";
      })(FieldOptions_CType || (FieldOptions_CType = {}));
      proto2.util.setEnumType(FieldOptions_CType, "google.protobuf.FieldOptions.CType", [
        { no: 0, name: "STRING" },
        { no: 1, name: "CORD" },
        { no: 2, name: "STRING_PIECE" }
      ]);
      (function(FieldOptions_JSType2) {
        FieldOptions_JSType2[FieldOptions_JSType2["JS_NORMAL"] = 0] = "JS_NORMAL";
        FieldOptions_JSType2[FieldOptions_JSType2["JS_STRING"] = 1] = "JS_STRING";
        FieldOptions_JSType2[FieldOptions_JSType2["JS_NUMBER"] = 2] = "JS_NUMBER";
      })(FieldOptions_JSType || (FieldOptions_JSType = {}));
      proto2.util.setEnumType(FieldOptions_JSType, "google.protobuf.FieldOptions.JSType", [
        { no: 0, name: "JS_NORMAL" },
        { no: 1, name: "JS_STRING" },
        { no: 2, name: "JS_NUMBER" }
      ]);
      (function(FieldOptions_OptionRetention2) {
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_UNKNOWN"] = 0] = "RETENTION_UNKNOWN";
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_RUNTIME"] = 1] = "RETENTION_RUNTIME";
        FieldOptions_OptionRetention2[FieldOptions_OptionRetention2["RETENTION_SOURCE"] = 2] = "RETENTION_SOURCE";
      })(FieldOptions_OptionRetention || (FieldOptions_OptionRetention = {}));
      proto2.util.setEnumType(FieldOptions_OptionRetention, "google.protobuf.FieldOptions.OptionRetention", [
        { no: 0, name: "RETENTION_UNKNOWN" },
        { no: 1, name: "RETENTION_RUNTIME" },
        { no: 2, name: "RETENTION_SOURCE" }
      ]);
      (function(FieldOptions_OptionTargetType2) {
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_UNKNOWN"] = 0] = "TARGET_TYPE_UNKNOWN";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FILE"] = 1] = "TARGET_TYPE_FILE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_EXTENSION_RANGE"] = 2] = "TARGET_TYPE_EXTENSION_RANGE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_MESSAGE"] = 3] = "TARGET_TYPE_MESSAGE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_FIELD"] = 4] = "TARGET_TYPE_FIELD";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ONEOF"] = 5] = "TARGET_TYPE_ONEOF";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM"] = 6] = "TARGET_TYPE_ENUM";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_ENUM_ENTRY"] = 7] = "TARGET_TYPE_ENUM_ENTRY";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_SERVICE"] = 8] = "TARGET_TYPE_SERVICE";
        FieldOptions_OptionTargetType2[FieldOptions_OptionTargetType2["TARGET_TYPE_METHOD"] = 9] = "TARGET_TYPE_METHOD";
      })(FieldOptions_OptionTargetType || (FieldOptions_OptionTargetType = {}));
      proto2.util.setEnumType(FieldOptions_OptionTargetType, "google.protobuf.FieldOptions.OptionTargetType", [
        { no: 0, name: "TARGET_TYPE_UNKNOWN" },
        { no: 1, name: "TARGET_TYPE_FILE" },
        { no: 2, name: "TARGET_TYPE_EXTENSION_RANGE" },
        { no: 3, name: "TARGET_TYPE_MESSAGE" },
        { no: 4, name: "TARGET_TYPE_FIELD" },
        { no: 5, name: "TARGET_TYPE_ONEOF" },
        { no: 6, name: "TARGET_TYPE_ENUM" },
        { no: 7, name: "TARGET_TYPE_ENUM_ENTRY" },
        { no: 8, name: "TARGET_TYPE_SERVICE" },
        { no: 9, name: "TARGET_TYPE_METHOD" }
      ]);
      OneofOptions = class _OneofOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _OneofOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _OneofOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _OneofOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_OneofOptions, a, b);
        }
      };
      OneofOptions.runtime = proto2;
      OneofOptions.typeName = "google.protobuf.OneofOptions";
      OneofOptions.fields = proto2.util.newFieldList(() => [
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      EnumOptions = class _EnumOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumOptions, a, b);
        }
      };
      EnumOptions.runtime = proto2;
      EnumOptions.typeName = "google.protobuf.EnumOptions";
      EnumOptions.fields = proto2.util.newFieldList(() => [
        { no: 2, name: "allow_alias", kind: "scalar", T: 8, opt: true },
        { no: 3, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 6, name: "deprecated_legacy_json_field_conflicts", kind: "scalar", T: 8, opt: true },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      EnumValueOptions = class _EnumValueOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValueOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValueOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValueOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_EnumValueOptions, a, b);
        }
      };
      EnumValueOptions.runtime = proto2;
      EnumValueOptions.typeName = "google.protobuf.EnumValueOptions";
      EnumValueOptions.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      ServiceOptions = class _ServiceOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ServiceOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ServiceOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ServiceOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_ServiceOptions, a, b);
        }
      };
      ServiceOptions.runtime = proto2;
      ServiceOptions.typeName = "google.protobuf.ServiceOptions";
      ServiceOptions.fields = proto2.util.newFieldList(() => [
        { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      MethodOptions = class _MethodOptions extends Message {
        constructor(data) {
          super();
          this.uninterpretedOption = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _MethodOptions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _MethodOptions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _MethodOptions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_MethodOptions, a, b);
        }
      };
      MethodOptions.runtime = proto2;
      MethodOptions.typeName = "google.protobuf.MethodOptions";
      MethodOptions.fields = proto2.util.newFieldList(() => [
        { no: 33, name: "deprecated", kind: "scalar", T: 8, opt: true, default: false },
        { no: 34, name: "idempotency_level", kind: "enum", T: proto2.getEnumType(MethodOptions_IdempotencyLevel), opt: true, default: MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN },
        { no: 999, name: "uninterpreted_option", kind: "message", T: UninterpretedOption, repeated: true }
      ]);
      (function(MethodOptions_IdempotencyLevel2) {
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = 0] = "IDEMPOTENCY_UNKNOWN";
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["NO_SIDE_EFFECTS"] = 1] = "NO_SIDE_EFFECTS";
        MethodOptions_IdempotencyLevel2[MethodOptions_IdempotencyLevel2["IDEMPOTENT"] = 2] = "IDEMPOTENT";
      })(MethodOptions_IdempotencyLevel || (MethodOptions_IdempotencyLevel = {}));
      proto2.util.setEnumType(MethodOptions_IdempotencyLevel, "google.protobuf.MethodOptions.IdempotencyLevel", [
        { no: 0, name: "IDEMPOTENCY_UNKNOWN" },
        { no: 1, name: "NO_SIDE_EFFECTS" },
        { no: 2, name: "IDEMPOTENT" }
      ]);
      UninterpretedOption = class _UninterpretedOption extends Message {
        constructor(data) {
          super();
          this.name = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UninterpretedOption().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UninterpretedOption().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UninterpretedOption().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_UninterpretedOption, a, b);
        }
      };
      UninterpretedOption.runtime = proto2;
      UninterpretedOption.typeName = "google.protobuf.UninterpretedOption";
      UninterpretedOption.fields = proto2.util.newFieldList(() => [
        { no: 2, name: "name", kind: "message", T: UninterpretedOption_NamePart, repeated: true },
        { no: 3, name: "identifier_value", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "positive_int_value", kind: "scalar", T: 4, opt: true },
        { no: 5, name: "negative_int_value", kind: "scalar", T: 3, opt: true },
        { no: 6, name: "double_value", kind: "scalar", T: 1, opt: true },
        { no: 7, name: "string_value", kind: "scalar", T: 12, opt: true },
        { no: 8, name: "aggregate_value", kind: "scalar", T: 9, opt: true }
      ]);
      UninterpretedOption_NamePart = class _UninterpretedOption_NamePart extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UninterpretedOption_NamePart().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UninterpretedOption_NamePart().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UninterpretedOption_NamePart().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_UninterpretedOption_NamePart, a, b);
        }
      };
      UninterpretedOption_NamePart.runtime = proto2;
      UninterpretedOption_NamePart.typeName = "google.protobuf.UninterpretedOption.NamePart";
      UninterpretedOption_NamePart.fields = proto2.util.newFieldList(() => [
        {
          no: 1,
          name: "name_part",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "is_extension",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
      SourceCodeInfo = class _SourceCodeInfo extends Message {
        constructor(data) {
          super();
          this.location = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceCodeInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceCodeInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceCodeInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_SourceCodeInfo, a, b);
        }
      };
      SourceCodeInfo.runtime = proto2;
      SourceCodeInfo.typeName = "google.protobuf.SourceCodeInfo";
      SourceCodeInfo.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "location", kind: "message", T: SourceCodeInfo_Location, repeated: true }
      ]);
      SourceCodeInfo_Location = class _SourceCodeInfo_Location extends Message {
        constructor(data) {
          super();
          this.path = [];
          this.span = [];
          this.leadingDetachedComments = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceCodeInfo_Location().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceCodeInfo_Location().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceCodeInfo_Location().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_SourceCodeInfo_Location, a, b);
        }
      };
      SourceCodeInfo_Location.runtime = proto2;
      SourceCodeInfo_Location.typeName = "google.protobuf.SourceCodeInfo.Location";
      SourceCodeInfo_Location.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 2, name: "span", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 3, name: "leading_comments", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "trailing_comments", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "leading_detached_comments", kind: "scalar", T: 9, repeated: true }
      ]);
      GeneratedCodeInfo = class _GeneratedCodeInfo extends Message {
        constructor(data) {
          super();
          this.annotation = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _GeneratedCodeInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _GeneratedCodeInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _GeneratedCodeInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_GeneratedCodeInfo, a, b);
        }
      };
      GeneratedCodeInfo.runtime = proto2;
      GeneratedCodeInfo.typeName = "google.protobuf.GeneratedCodeInfo";
      GeneratedCodeInfo.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "annotation", kind: "message", T: GeneratedCodeInfo_Annotation, repeated: true }
      ]);
      GeneratedCodeInfo_Annotation = class _GeneratedCodeInfo_Annotation extends Message {
        constructor(data) {
          super();
          this.path = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _GeneratedCodeInfo_Annotation().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _GeneratedCodeInfo_Annotation().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _GeneratedCodeInfo_Annotation().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_GeneratedCodeInfo_Annotation, a, b);
        }
      };
      GeneratedCodeInfo_Annotation.runtime = proto2;
      GeneratedCodeInfo_Annotation.typeName = "google.protobuf.GeneratedCodeInfo.Annotation";
      GeneratedCodeInfo_Annotation.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "path", kind: "scalar", T: 5, repeated: true, packed: true },
        { no: 2, name: "source_file", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "begin", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "end", kind: "scalar", T: 5, opt: true },
        { no: 5, name: "semantic", kind: "enum", T: proto2.getEnumType(GeneratedCodeInfo_Annotation_Semantic), opt: true }
      ]);
      (function(GeneratedCodeInfo_Annotation_Semantic2) {
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["NONE"] = 0] = "NONE";
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["SET"] = 1] = "SET";
        GeneratedCodeInfo_Annotation_Semantic2[GeneratedCodeInfo_Annotation_Semantic2["ALIAS"] = 2] = "ALIAS";
      })(GeneratedCodeInfo_Annotation_Semantic || (GeneratedCodeInfo_Annotation_Semantic = {}));
      proto2.util.setEnumType(GeneratedCodeInfo_Annotation_Semantic, "google.protobuf.GeneratedCodeInfo.Annotation.Semantic", [
        { no: 0, name: "NONE" },
        { no: 1, name: "SET" },
        { no: 2, name: "ALIAS" }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js
  function createDescriptorSet(input) {
    const cart = {
      enums: /* @__PURE__ */ new Map(),
      messages: /* @__PURE__ */ new Map(),
      services: /* @__PURE__ */ new Map(),
      extensions: /* @__PURE__ */ new Map(),
      mapEntries: /* @__PURE__ */ new Map()
    };
    const fileDescriptors = input instanceof FileDescriptorSet ? input.file : input instanceof Uint8Array ? FileDescriptorSet.fromBinary(input).file : input;
    const files = fileDescriptors.map((proto) => newFile(proto, cart));
    return Object.assign({ files }, cart);
  }
  function newFile(proto, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid FileDescriptorProto: missing name`);
    assert(proto.syntax === void 0 || proto.syntax === "proto3", `invalid FileDescriptorProto: unsupported syntax: ${(_a = proto.syntax) !== null && _a !== void 0 ? _a : "undefined"}`);
    const file = {
      kind: "file",
      proto,
      deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,
      syntax: proto.syntax === "proto3" ? "proto3" : "proto2",
      name: proto.name.replace(/\.proto/, ""),
      enums: [],
      messages: [],
      extensions: [],
      services: [],
      toString() {
        return `file ${this.proto.name}`;
      },
      getSyntaxComments() {
        return findComments(this.proto.sourceCodeInfo, [
          FieldNumber.FileDescriptorProto_Syntax
        ]);
      },
      getPackageComments() {
        return findComments(this.proto.sourceCodeInfo, [
          FieldNumber.FileDescriptorProto_Package
        ]);
      }
    };
    cart.mapEntries.clear();
    for (const enumProto of proto.enumType) {
      addEnum(enumProto, file, void 0, cart);
    }
    for (const messageProto of proto.messageType) {
      addMessage(messageProto, file, void 0, cart);
    }
    for (const serviceProto of proto.service) {
      addService(serviceProto, file, cart);
    }
    addExtensions(file, cart);
    for (const mapEntry of cart.mapEntries.values()) {
      addFields(mapEntry, cart);
    }
    for (const message of file.messages) {
      addFields(message, cart);
      addExtensions(message, cart);
    }
    cart.mapEntries.clear();
    return file;
  }
  function addExtensions(desc, cart) {
    switch (desc.kind) {
      case "file":
        for (const proto of desc.proto.extension) {
          const ext = newExtension(proto, desc, void 0, cart);
          desc.extensions.push(ext);
          cart.extensions.set(ext.typeName, ext);
        }
        break;
      case "message":
        for (const proto of desc.proto.extension) {
          const ext = newExtension(proto, desc.file, desc, cart);
          desc.nestedExtensions.push(ext);
          cart.extensions.set(ext.typeName, ext);
        }
        for (const message of desc.nestedMessages) {
          addExtensions(message, cart);
        }
        break;
    }
  }
  function addFields(message, cart) {
    const allOneofs = message.proto.oneofDecl.map((proto) => newOneof(proto, message));
    const oneofsSeen = /* @__PURE__ */ new Set();
    for (const proto of message.proto.field) {
      const oneof = findOneof(proto, allOneofs);
      const field = newField(proto, message.file, message, oneof, cart);
      message.fields.push(field);
      if (oneof === void 0) {
        message.members.push(field);
      } else {
        oneof.fields.push(field);
        if (!oneofsSeen.has(oneof)) {
          oneofsSeen.add(oneof);
          message.members.push(oneof);
        }
      }
    }
    for (const oneof of allOneofs.filter((o) => oneofsSeen.has(o))) {
      message.oneofs.push(oneof);
    }
    for (const child of message.nestedMessages) {
      addFields(child, cart);
    }
  }
  function addEnum(proto, file, parent, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid EnumDescriptorProto: missing name`);
    const desc = {
      kind: "enum",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      parent,
      name: proto.name,
      typeName: makeTypeName(proto, parent, file),
      values: [],
      sharedPrefix: findEnumSharedPrefix(proto.name, proto.value.map((v) => {
        var _a2;
        return (_a2 = v.name) !== null && _a2 !== void 0 ? _a2 : "";
      })),
      toString() {
        return `enum ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_EnumType,
          this.parent.proto.enumType.indexOf(this.proto)
        ] : [
          FieldNumber.FileDescriptorProto_EnumType,
          this.file.proto.enumType.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    cart.enums.set(desc.typeName, desc);
    proto.value.forEach((proto4) => {
      var _a2, _b2;
      assert(proto4.name, `invalid EnumValueDescriptorProto: missing name`);
      assert(proto4.number !== void 0, `invalid EnumValueDescriptorProto: missing number`);
      desc.values.push({
        kind: "enum_value",
        proto: proto4,
        deprecated: (_b2 = (_a2 = proto4.options) === null || _a2 === void 0 ? void 0 : _a2.deprecated) !== null && _b2 !== void 0 ? _b2 : false,
        parent: desc,
        name: proto4.name,
        number: proto4.number,
        toString() {
          return `enum value ${desc.typeName}.${this.name}`;
        },
        declarationString() {
          var _a3;
          let str = `${this.name} = ${this.number}`;
          if (((_a3 = this.proto.options) === null || _a3 === void 0 ? void 0 : _a3.deprecated) === true) {
            str += " [deprecated = true]";
          }
          return str;
        },
        getComments() {
          const path = [
            ...this.parent.getComments().sourcePath,
            FieldNumber.EnumDescriptorProto_Value,
            this.parent.proto.value.indexOf(this.proto)
          ];
          return findComments(file.proto.sourceCodeInfo, path);
        }
      });
    });
    ((_c = parent === null || parent === void 0 ? void 0 : parent.nestedEnums) !== null && _c !== void 0 ? _c : file.enums).push(desc);
  }
  function addMessage(proto, file, parent, cart) {
    var _a, _b, _c, _d;
    assert(proto.name, `invalid DescriptorProto: missing name`);
    const desc = {
      kind: "message",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      parent,
      name: proto.name,
      typeName: makeTypeName(proto, parent, file),
      fields: [],
      oneofs: [],
      members: [],
      nestedEnums: [],
      nestedMessages: [],
      nestedExtensions: [],
      toString() {
        return `message ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_NestedType,
          this.parent.proto.nestedType.indexOf(this.proto)
        ] : [
          FieldNumber.FileDescriptorProto_MessageType,
          this.file.proto.messageType.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    if (((_c = proto.options) === null || _c === void 0 ? void 0 : _c.mapEntry) === true) {
      cart.mapEntries.set(desc.typeName, desc);
    } else {
      ((_d = parent === null || parent === void 0 ? void 0 : parent.nestedMessages) !== null && _d !== void 0 ? _d : file.messages).push(desc);
      cart.messages.set(desc.typeName, desc);
    }
    for (const enumProto of proto.enumType) {
      addEnum(enumProto, file, desc, cart);
    }
    for (const messageProto of proto.nestedType) {
      addMessage(messageProto, file, desc, cart);
    }
  }
  function addService(proto, file, cart) {
    var _a, _b;
    assert(proto.name, `invalid ServiceDescriptorProto: missing name`);
    const desc = {
      kind: "service",
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      file,
      name: proto.name,
      typeName: makeTypeName(proto, void 0, file),
      methods: [],
      toString() {
        return `service ${this.typeName}`;
      },
      getComments() {
        const path = [
          FieldNumber.FileDescriptorProto_Service,
          this.file.proto.service.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    file.services.push(desc);
    cart.services.set(desc.typeName, desc);
    for (const methodProto of proto.method) {
      desc.methods.push(newMethod(methodProto, desc, cart));
    }
  }
  function newMethod(proto, parent, cart) {
    var _a, _b, _c;
    assert(proto.name, `invalid MethodDescriptorProto: missing name`);
    assert(proto.inputType, `invalid MethodDescriptorProto: missing input_type`);
    assert(proto.outputType, `invalid MethodDescriptorProto: missing output_type`);
    let methodKind;
    if (proto.clientStreaming === true && proto.serverStreaming === true) {
      methodKind = MethodKind.BiDiStreaming;
    } else if (proto.clientStreaming === true) {
      methodKind = MethodKind.ClientStreaming;
    } else if (proto.serverStreaming === true) {
      methodKind = MethodKind.ServerStreaming;
    } else {
      methodKind = MethodKind.Unary;
    }
    let idempotency;
    switch ((_a = proto.options) === null || _a === void 0 ? void 0 : _a.idempotencyLevel) {
      case MethodOptions_IdempotencyLevel.IDEMPOTENT:
        idempotency = MethodIdempotency.Idempotent;
        break;
      case MethodOptions_IdempotencyLevel.NO_SIDE_EFFECTS:
        idempotency = MethodIdempotency.NoSideEffects;
        break;
      case MethodOptions_IdempotencyLevel.IDEMPOTENCY_UNKNOWN:
      case void 0:
        idempotency = void 0;
        break;
    }
    const input = cart.messages.get(trimLeadingDot(proto.inputType));
    const output = cart.messages.get(trimLeadingDot(proto.outputType));
    assert(input, `invalid MethodDescriptorProto: input_type ${proto.inputType} not found`);
    assert(output, `invalid MethodDescriptorProto: output_type ${proto.inputType} not found`);
    const name = proto.name;
    return {
      kind: "rpc",
      proto,
      deprecated: (_c = (_b = proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) !== null && _c !== void 0 ? _c : false,
      parent,
      name,
      methodKind,
      input,
      output,
      idempotency,
      toString() {
        return `rpc ${parent.typeName}.${name}`;
      },
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.ServiceDescriptorProto_Method,
          this.parent.proto.method.indexOf(this.proto)
        ];
        return findComments(parent.file.proto.sourceCodeInfo, path);
      }
    };
  }
  function newOneof(proto, parent) {
    assert(proto.name, `invalid OneofDescriptorProto: missing name`);
    return {
      kind: "oneof",
      proto,
      deprecated: false,
      parent,
      fields: [],
      name: proto.name,
      toString() {
        return `oneof ${parent.typeName}.${this.name}`;
      },
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_OneofDecl,
          this.parent.proto.oneofDecl.indexOf(this.proto)
        ];
        return findComments(parent.file.proto.sourceCodeInfo, path);
      }
    };
  }
  function newField(proto, file, parent, oneof, cart) {
    var _a, _b, _c, _d;
    assert(proto.name, `invalid FieldDescriptorProto: missing name`);
    assert(proto.number, `invalid FieldDescriptorProto: missing number`);
    assert(proto.type, `invalid FieldDescriptorProto: missing type`);
    const packedByDefault = isPackedFieldByDefault(proto, file.syntax);
    const common = {
      proto,
      deprecated: (_b = (_a = proto.options) === null || _a === void 0 ? void 0 : _a.deprecated) !== null && _b !== void 0 ? _b : false,
      name: proto.name,
      number: proto.number,
      parent,
      oneof,
      optional: isOptionalField(proto, file.syntax),
      packed: (_d = (_c = proto.options) === null || _c === void 0 ? void 0 : _c.packed) !== null && _d !== void 0 ? _d : packedByDefault,
      packedByDefault,
      jsonName: proto.jsonName === fieldJsonName(proto.name) ? void 0 : proto.jsonName,
      scalar: void 0,
      message: void 0,
      enum: void 0,
      mapKey: void 0,
      mapValue: void 0,
      toString() {
        return `field ${this.parent.typeName}.${this.name}`;
      },
      declarationString,
      getComments() {
        const path = [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_Field,
          this.parent.proto.field.indexOf(this.proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    };
    const repeated = proto.label === FieldDescriptorProto_Label.REPEATED;
    switch (proto.type) {
      case FieldDescriptorProto_Type.MESSAGE:
      case FieldDescriptorProto_Type.GROUP: {
        assert(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
        const mapEntry = cart.mapEntries.get(trimLeadingDot(proto.typeName));
        if (mapEntry !== void 0) {
          assert(repeated, `invalid FieldDescriptorProto: expected map entry to be repeated`);
          return Object.assign(Object.assign(Object.assign({}, common), { kind: "field", fieldKind: "map", repeated: false }), getMapFieldTypes(mapEntry));
        }
        const message = cart.messages.get(trimLeadingDot(proto.typeName));
        assert(message !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "message",
          repeated,
          message
        });
      }
      case FieldDescriptorProto_Type.ENUM: {
        assert(proto.typeName, `invalid FieldDescriptorProto: missing type_name`);
        const e = cart.enums.get(trimLeadingDot(proto.typeName));
        assert(e !== void 0, `invalid FieldDescriptorProto: type_name ${proto.typeName} not found`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "enum",
          getDefaultValue,
          repeated,
          enum: e
        });
      }
      default: {
        const scalar = fieldTypeToScalarType[proto.type];
        assert(scalar, `invalid FieldDescriptorProto: unknown type ${proto.type}`);
        return Object.assign(Object.assign({}, common), {
          kind: "field",
          fieldKind: "scalar",
          getDefaultValue,
          repeated,
          scalar
        });
      }
    }
  }
  function newExtension(proto, file, parent, cart) {
    assert(proto.extendee, `invalid FieldDescriptorProto: missing extendee`);
    const field = newField(
      proto,
      file,
      null,
      // to safe us many lines of duplicated code, we trick the type system
      void 0,
      cart
    );
    const extendee = cart.messages.get(trimLeadingDot(proto.extendee));
    assert(extendee, `invalid FieldDescriptorProto: extendee ${proto.extendee} not found`);
    return Object.assign(Object.assign({}, field), {
      kind: "extension",
      typeName: makeTypeName(proto, parent, file),
      parent,
      file,
      extendee,
      toString() {
        return `extension ${this.typeName}`;
      },
      getComments() {
        const path = this.parent ? [
          ...this.parent.getComments().sourcePath,
          FieldNumber.DescriptorProto_Extension,
          this.parent.proto.extension.indexOf(proto)
        ] : [
          FieldNumber.FileDescriptorProto_Extension,
          this.file.proto.extension.indexOf(proto)
        ];
        return findComments(file.proto.sourceCodeInfo, path);
      }
    });
  }
  function makeTypeName(proto, parent, file) {
    assert(proto.name, `invalid ${proto.getType().typeName}: missing name`);
    let typeName;
    if (parent) {
      typeName = `${parent.typeName}.${proto.name}`;
    } else if (file.proto.package !== void 0) {
      typeName = `${file.proto.package}.${proto.name}`;
    } else {
      typeName = `${proto.name}`;
    }
    return typeName;
  }
  function trimLeadingDot(typeName) {
    return typeName.startsWith(".") ? typeName.substring(1) : typeName;
  }
  function getMapFieldTypes(mapEntry) {
    var _a, _b;
    assert((_a = mapEntry.proto.options) === null || _a === void 0 ? void 0 : _a.mapEntry, `invalid DescriptorProto: expected ${mapEntry.toString()} to be a map entry`);
    assert(mapEntry.fields.length === 2, `invalid DescriptorProto: map entry ${mapEntry.toString()} has ${mapEntry.fields.length} fields`);
    const keyField = mapEntry.fields.find((f) => f.proto.number === 1);
    assert(keyField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing key field`);
    const mapKey = keyField.scalar;
    assert(mapKey !== void 0 && mapKey !== ScalarType.BYTES && mapKey !== ScalarType.FLOAT && mapKey !== ScalarType.DOUBLE, `invalid DescriptorProto: map entry ${mapEntry.toString()} has unexpected key type ${(_b = keyField.proto.type) !== null && _b !== void 0 ? _b : -1}`);
    const valueField = mapEntry.fields.find((f) => f.proto.number === 2);
    assert(valueField, `invalid DescriptorProto: map entry ${mapEntry.toString()} is missing value field`);
    switch (valueField.fieldKind) {
      case "scalar":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "scalar" })
        };
      case "message":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "message" })
        };
      case "enum":
        return {
          mapKey,
          mapValue: Object.assign(Object.assign({}, valueField), { kind: "enum" })
        };
      default:
        throw new Error("invalid DescriptorProto: unsupported map entry value field");
    }
  }
  function findOneof(proto, allOneofs) {
    var _a;
    const oneofIndex = proto.oneofIndex;
    if (oneofIndex === void 0) {
      return void 0;
    }
    let oneof;
    if (proto.proto3Optional !== true) {
      oneof = allOneofs[oneofIndex];
      assert(oneof, `invalid FieldDescriptorProto: oneof #${oneofIndex} for field #${(_a = proto.number) !== null && _a !== void 0 ? _a : -1} not found`);
    }
    return oneof;
  }
  function isOptionalField(proto, syntax) {
    switch (syntax) {
      case "proto2":
        return proto.oneofIndex === void 0 && proto.label === FieldDescriptorProto_Label.OPTIONAL;
      case "proto3":
        return proto.proto3Optional === true;
    }
  }
  function isPackedFieldByDefault(proto, syntax) {
    assert(proto.type, `invalid FieldDescriptorProto: missing type`);
    if (syntax === "proto3") {
      switch (proto.type) {
        case FieldDescriptorProto_Type.DOUBLE:
        case FieldDescriptorProto_Type.FLOAT:
        case FieldDescriptorProto_Type.INT64:
        case FieldDescriptorProto_Type.UINT64:
        case FieldDescriptorProto_Type.INT32:
        case FieldDescriptorProto_Type.FIXED64:
        case FieldDescriptorProto_Type.FIXED32:
        case FieldDescriptorProto_Type.UINT32:
        case FieldDescriptorProto_Type.SFIXED32:
        case FieldDescriptorProto_Type.SFIXED64:
        case FieldDescriptorProto_Type.SINT32:
        case FieldDescriptorProto_Type.SINT64:
        case FieldDescriptorProto_Type.BOOL:
        case FieldDescriptorProto_Type.ENUM:
          return true;
        default:
          return false;
      }
    }
    return false;
  }
  function findComments(sourceCodeInfo, sourcePath) {
    if (!sourceCodeInfo) {
      return {
        leadingDetached: [],
        sourcePath
      };
    }
    for (const location of sourceCodeInfo.location) {
      if (location.path.length !== sourcePath.length) {
        continue;
      }
      if (location.path.some((value, index) => sourcePath[index] !== value)) {
        continue;
      }
      return {
        leadingDetached: location.leadingDetachedComments,
        leading: location.leadingComments,
        trailing: location.trailingComments,
        sourcePath
      };
    }
    return {
      leadingDetached: [],
      sourcePath
    };
  }
  function declarationString() {
    var _a, _b;
    const parts = [];
    if (this.repeated) {
      parts.push("repeated");
    }
    if (this.optional) {
      parts.push("optional");
    }
    const file = this.kind === "extension" ? this.file : this.parent.file;
    if (file.syntax == "proto2" && this.proto.label === FieldDescriptorProto_Label.REQUIRED) {
      parts.push("required");
    }
    let type;
    switch (this.fieldKind) {
      case "scalar":
        type = ScalarType[this.scalar].toLowerCase();
        break;
      case "enum":
        type = this.enum.typeName;
        break;
      case "message":
        type = this.message.typeName;
        break;
      case "map": {
        const k = ScalarType[this.mapKey].toLowerCase();
        let v;
        switch (this.mapValue.kind) {
          case "scalar":
            v = ScalarType[this.mapValue.scalar].toLowerCase();
            break;
          case "enum":
            v = this.mapValue.enum.typeName;
            break;
          case "message":
            v = this.mapValue.message.typeName;
            break;
        }
        type = `map<${k}, ${v}>`;
        break;
      }
    }
    parts.push(`${type} ${this.name} = ${this.number}`);
    const options = [];
    if (((_a = this.proto.options) === null || _a === void 0 ? void 0 : _a.packed) !== void 0) {
      options.push(`packed = ${this.proto.options.packed.toString()}`);
    }
    let defaultValue = this.proto.defaultValue;
    if (defaultValue !== void 0) {
      if (this.proto.type == FieldDescriptorProto_Type.BYTES || this.proto.type == FieldDescriptorProto_Type.STRING) {
        defaultValue = '"' + defaultValue.replace('"', '\\"') + '"';
      }
      options.push(`default = ${defaultValue}`);
    }
    if (this.jsonName !== void 0) {
      options.push(`json_name = "${this.jsonName}"`);
    }
    if (((_b = this.proto.options) === null || _b === void 0 ? void 0 : _b.deprecated) === true) {
      options.push(`deprecated = true`);
    }
    if (options.length > 0) {
      parts.push("[" + options.join(", ") + "]");
    }
    return parts.join(" ");
  }
  function getDefaultValue() {
    const d = this.proto.defaultValue;
    if (d === void 0) {
      return void 0;
    }
    switch (this.fieldKind) {
      case "enum": {
        const enumValue = this.enum.values.find((v) => v.name === d);
        assert(enumValue, `cannot parse ${this.toString()} default value: ${d}`);
        return enumValue.number;
      }
      case "scalar":
        switch (this.scalar) {
          case ScalarType.STRING:
            return d;
          case ScalarType.BYTES: {
            const u = unescapeBytesDefaultValue(d);
            if (u === false) {
              throw new Error(`cannot parse ${this.toString()} default value: ${d}`);
            }
            return u;
          }
          case ScalarType.INT64:
          case ScalarType.SFIXED64:
          case ScalarType.SINT64:
            return protoInt64.parse(d);
          case ScalarType.UINT64:
          case ScalarType.FIXED64:
            return protoInt64.uParse(d);
          case ScalarType.DOUBLE:
          case ScalarType.FLOAT:
            switch (d) {
              case "inf":
                return Number.POSITIVE_INFINITY;
              case "-inf":
                return Number.NEGATIVE_INFINITY;
              case "nan":
                return Number.NaN;
              default:
                return parseFloat(d);
            }
          case ScalarType.BOOL:
            return d === "true";
          case ScalarType.INT32:
          case ScalarType.UINT32:
          case ScalarType.SINT32:
          case ScalarType.FIXED32:
          case ScalarType.SFIXED32:
            return parseInt(d, 10);
        }
        break;
      default:
        return void 0;
    }
  }
  function unescapeBytesDefaultValue(str) {
    const b = [];
    const input = {
      tail: str,
      c: "",
      next() {
        if (this.tail.length == 0) {
          return false;
        }
        this.c = this.tail[0];
        this.tail = this.tail.substring(1);
        return true;
      },
      take(n) {
        if (this.tail.length >= n) {
          const r = this.tail.substring(0, n);
          this.tail = this.tail.substring(n);
          return r;
        }
        return false;
      }
    };
    while (input.next()) {
      switch (input.c) {
        case "\\":
          if (input.next()) {
            switch (input.c) {
              case "\\":
                b.push(input.c.charCodeAt(0));
                break;
              case "b":
                b.push(8);
                break;
              case "f":
                b.push(12);
                break;
              case "n":
                b.push(10);
                break;
              case "r":
                b.push(13);
                break;
              case "t":
                b.push(9);
                break;
              case "v":
                b.push(11);
                break;
              case "0":
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7": {
                const s = input.c;
                const t = input.take(2);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 8);
                if (isNaN(n)) {
                  return false;
                }
                b.push(n);
                break;
              }
              case "x": {
                const s = input.c;
                const t = input.take(2);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 16);
                if (isNaN(n)) {
                  return false;
                }
                b.push(n);
                break;
              }
              case "u": {
                const s = input.c;
                const t = input.take(4);
                if (t === false) {
                  return false;
                }
                const n = parseInt(s + t, 16);
                if (isNaN(n)) {
                  return false;
                }
                const chunk = new Uint8Array(4);
                const view = new DataView(chunk.buffer);
                view.setInt32(0, n, true);
                b.push(chunk[0], chunk[1], chunk[2], chunk[3]);
                break;
              }
              case "U": {
                const s = input.c;
                const t = input.take(8);
                if (t === false) {
                  return false;
                }
                const tc = protoInt64.uEnc(s + t);
                const chunk = new Uint8Array(8);
                const view = new DataView(chunk.buffer);
                view.setInt32(0, tc.lo, true);
                view.setInt32(4, tc.hi, true);
                b.push(chunk[0], chunk[1], chunk[2], chunk[3], chunk[4], chunk[5], chunk[6], chunk[7]);
                break;
              }
            }
          }
          break;
        default:
          b.push(input.c.charCodeAt(0));
      }
    }
    return new Uint8Array(b);
  }
  var fieldTypeToScalarType, FieldNumber;
  var init_create_descriptor_set = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-descriptor-set.js"() {
      "use strict";
      init_descriptor_pb();
      init_assert();
      init_field();
      init_service_type();
      init_names();
      init_proto_int64();
      fieldTypeToScalarType = {
        [FieldDescriptorProto_Type.DOUBLE]: ScalarType.DOUBLE,
        [FieldDescriptorProto_Type.FLOAT]: ScalarType.FLOAT,
        [FieldDescriptorProto_Type.INT64]: ScalarType.INT64,
        [FieldDescriptorProto_Type.UINT64]: ScalarType.UINT64,
        [FieldDescriptorProto_Type.INT32]: ScalarType.INT32,
        [FieldDescriptorProto_Type.FIXED64]: ScalarType.FIXED64,
        [FieldDescriptorProto_Type.FIXED32]: ScalarType.FIXED32,
        [FieldDescriptorProto_Type.BOOL]: ScalarType.BOOL,
        [FieldDescriptorProto_Type.STRING]: ScalarType.STRING,
        [FieldDescriptorProto_Type.GROUP]: void 0,
        [FieldDescriptorProto_Type.MESSAGE]: void 0,
        [FieldDescriptorProto_Type.BYTES]: ScalarType.BYTES,
        [FieldDescriptorProto_Type.UINT32]: ScalarType.UINT32,
        [FieldDescriptorProto_Type.ENUM]: void 0,
        [FieldDescriptorProto_Type.SFIXED32]: ScalarType.SFIXED32,
        [FieldDescriptorProto_Type.SFIXED64]: ScalarType.SFIXED64,
        [FieldDescriptorProto_Type.SINT32]: ScalarType.SINT32,
        [FieldDescriptorProto_Type.SINT64]: ScalarType.SINT64
      };
      (function(FieldNumber2) {
        FieldNumber2[FieldNumber2["FileDescriptorProto_Package"] = 2] = "FileDescriptorProto_Package";
        FieldNumber2[FieldNumber2["FileDescriptorProto_MessageType"] = 4] = "FileDescriptorProto_MessageType";
        FieldNumber2[FieldNumber2["FileDescriptorProto_EnumType"] = 5] = "FileDescriptorProto_EnumType";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Service"] = 6] = "FileDescriptorProto_Service";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Extension"] = 7] = "FileDescriptorProto_Extension";
        FieldNumber2[FieldNumber2["FileDescriptorProto_Syntax"] = 12] = "FileDescriptorProto_Syntax";
        FieldNumber2[FieldNumber2["DescriptorProto_Field"] = 2] = "DescriptorProto_Field";
        FieldNumber2[FieldNumber2["DescriptorProto_NestedType"] = 3] = "DescriptorProto_NestedType";
        FieldNumber2[FieldNumber2["DescriptorProto_EnumType"] = 4] = "DescriptorProto_EnumType";
        FieldNumber2[FieldNumber2["DescriptorProto_Extension"] = 6] = "DescriptorProto_Extension";
        FieldNumber2[FieldNumber2["DescriptorProto_OneofDecl"] = 8] = "DescriptorProto_OneofDecl";
        FieldNumber2[FieldNumber2["EnumDescriptorProto_Value"] = 2] = "EnumDescriptorProto_Value";
        FieldNumber2[FieldNumber2["ServiceDescriptorProto_Method"] = 2] = "ServiceDescriptorProto_Method";
      })(FieldNumber || (FieldNumber = {}));
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-registry.js
  function createRegistry(...types) {
    const messages = {};
    const enums = {};
    const services = {};
    const registry = {
      /**
       * Add a type to the registry. For messages, the types used in message
       * fields are added recursively. For services, the message types used
       * for requests and responses are added recursively.
       */
      add(type) {
        if ("fields" in type) {
          if (!this.findMessage(type.typeName)) {
            messages[type.typeName] = type;
            for (const field of type.fields.list()) {
              if (field.kind == "message") {
                this.add(field.T);
              } else if (field.kind == "map" && field.V.kind == "message") {
                this.add(field.V.T);
              } else if (field.kind == "enum") {
                this.add(field.T);
              }
            }
          }
        } else if ("methods" in type) {
          if (!this.findService(type.typeName)) {
            services[type.typeName] = type;
            for (const method of Object.values(type.methods)) {
              this.add(method.I);
              this.add(method.O);
            }
          }
        } else {
          enums[type.typeName] = type;
        }
      },
      findMessage(typeName) {
        return messages[typeName];
      },
      findEnum(typeName) {
        return enums[typeName];
      },
      findService(typeName) {
        return services[typeName];
      }
    };
    for (const type of types) {
      registry.add(type);
    }
    return registry;
  }
  var init_create_registry = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-registry.js"() {
      "use strict";
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js
  var Timestamp;
  var init_timestamp_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/timestamp_pb.js"() {
      "use strict";
      init_message();
      init_proto_int64();
      init_proto3();
      Timestamp = class _Timestamp extends Message {
        constructor(data) {
          super();
          this.seconds = protoInt64.zero;
          this.nanos = 0;
          proto3.util.initPartial(data, this);
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: ${proto3.json.debug(json)}`);
          }
          const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);
          if (!matches) {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
          }
          const ms = Date.parse(matches[1] + "-" + matches[2] + "-" + matches[3] + "T" + matches[4] + ":" + matches[5] + ":" + matches[6] + (matches[8] ? matches[8] : "Z"));
          if (Number.isNaN(ms)) {
            throw new Error(`cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string`);
          }
          if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
            throw new Error(`cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
          }
          this.seconds = protoInt64.parse(ms / 1e3);
          this.nanos = 0;
          if (matches[7]) {
            this.nanos = parseInt("1" + matches[7] + "0".repeat(9 - matches[7].length)) - 1e9;
          }
          return this;
        }
        toJson(options) {
          const ms = Number(this.seconds) * 1e3;
          if (ms < Date.parse("0001-01-01T00:00:00Z") || ms > Date.parse("9999-12-31T23:59:59Z")) {
            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive`);
          }
          if (this.nanos < 0) {
            throw new Error(`cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative`);
          }
          let z2 = "Z";
          if (this.nanos > 0) {
            const nanosStr = (this.nanos + 1e9).toString().substring(1);
            if (nanosStr.substring(3) === "000000") {
              z2 = "." + nanosStr.substring(0, 3) + "Z";
            } else if (nanosStr.substring(6) === "000") {
              z2 = "." + nanosStr.substring(0, 6) + "Z";
            } else {
              z2 = "." + nanosStr + "Z";
            }
          }
          return new Date(ms).toISOString().replace(".000Z", z2);
        }
        toDate() {
          return new Date(Number(this.seconds) * 1e3 + Math.ceil(this.nanos / 1e6));
        }
        static now() {
          return _Timestamp.fromDate(/* @__PURE__ */ new Date());
        }
        static fromDate(date) {
          const ms = date.getTime();
          return new _Timestamp({
            seconds: protoInt64.parse(Math.floor(ms / 1e3)),
            nanos: ms % 1e3 * 1e6
          });
        }
        static fromBinary(bytes, options) {
          return new _Timestamp().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Timestamp().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Timestamp().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Timestamp, a, b);
        }
      };
      Timestamp.runtime = proto3;
      Timestamp.typeName = "google.protobuf.Timestamp";
      Timestamp.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js
  var Duration;
  var init_duration_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/duration_pb.js"() {
      "use strict";
      init_message();
      init_proto_int64();
      init_proto3();
      Duration = class _Duration extends Message {
        constructor(data) {
          super();
          this.seconds = protoInt64.zero;
          this.nanos = 0;
          proto3.util.initPartial(data, this);
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          const match = json.match(/^(-?[0-9]+)(?:\.([0-9]+))?s/);
          if (match === null) {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          const longSeconds = Number(match[1]);
          if (longSeconds > 315576e6 || longSeconds < -315576e6) {
            throw new Error(`cannot decode google.protobuf.Duration from JSON: ${proto3.json.debug(json)}`);
          }
          this.seconds = protoInt64.parse(longSeconds);
          if (typeof match[2] == "string") {
            const nanosStr = match[2] + "0".repeat(9 - match[2].length);
            this.nanos = parseInt(nanosStr);
            if (longSeconds < 0 || Object.is(longSeconds, -0)) {
              this.nanos = -this.nanos;
            }
          }
          return this;
        }
        toJson(options) {
          if (Number(this.seconds) > 315576e6 || Number(this.seconds) < -315576e6) {
            throw new Error(`cannot encode google.protobuf.Duration to JSON: value out of range`);
          }
          let text = this.seconds.toString();
          if (this.nanos !== 0) {
            let nanosStr = Math.abs(this.nanos).toString();
            nanosStr = "0".repeat(9 - nanosStr.length) + nanosStr;
            if (nanosStr.substring(3) === "000000") {
              nanosStr = nanosStr.substring(0, 3);
            } else if (nanosStr.substring(6) === "000") {
              nanosStr = nanosStr.substring(0, 6);
            }
            text += "." + nanosStr;
            if (this.nanos < 0 && this.seconds === protoInt64.zero) {
              text = "-" + text;
            }
          }
          return text + "s";
        }
        static fromBinary(bytes, options) {
          return new _Duration().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Duration().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Duration().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Duration, a, b);
        }
      };
      Duration.runtime = proto3;
      Duration.typeName = "google.protobuf.Duration";
      Duration.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "seconds",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        },
        {
          no: 2,
          name: "nanos",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js
  var Any;
  var init_any_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/any_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      Any = class _Any extends Message {
        constructor(data) {
          super();
          this.typeUrl = "";
          this.value = new Uint8Array(0);
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          var _a;
          if (this.typeUrl === "") {
            return {};
          }
          const typeName = this.typeUrlToName(this.typeUrl);
          const messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
          if (!messageType) {
            throw new Error(`cannot encode message google.protobuf.Any to JSON: "${this.typeUrl}" is not in the type registry`);
          }
          const message = messageType.fromBinary(this.value);
          let json = message.toJson(options);
          if (typeName.startsWith("google.protobuf.") || (json === null || Array.isArray(json) || typeof json !== "object")) {
            json = { value: json };
          }
          json["@type"] = this.typeUrl;
          return json;
        }
        fromJson(json, options) {
          var _a;
          if (json === null || Array.isArray(json) || typeof json != "object") {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: expected object but got ${json === null ? "null" : Array.isArray(json) ? "array" : typeof json}`);
          }
          if (Object.keys(json).length == 0) {
            return this;
          }
          const typeUrl = json["@type"];
          if (typeof typeUrl != "string" || typeUrl == "") {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: "@type" is empty`);
          }
          const typeName = this.typeUrlToName(typeUrl), messageType = (_a = options === null || options === void 0 ? void 0 : options.typeRegistry) === null || _a === void 0 ? void 0 : _a.findMessage(typeName);
          if (!messageType) {
            throw new Error(`cannot decode message google.protobuf.Any from JSON: ${typeUrl} is not in the type registry`);
          }
          let message;
          if (typeName.startsWith("google.protobuf.") && Object.prototype.hasOwnProperty.call(json, "value")) {
            message = messageType.fromJson(json["value"], options);
          } else {
            const copy = Object.assign({}, json);
            delete copy["@type"];
            message = messageType.fromJson(copy, options);
          }
          this.packFrom(message);
          return this;
        }
        packFrom(message) {
          this.value = message.toBinary();
          this.typeUrl = this.typeNameToUrl(message.getType().typeName);
        }
        unpackTo(target) {
          if (!this.is(target.getType())) {
            return false;
          }
          target.fromBinary(this.value);
          return true;
        }
        unpack(registry) {
          if (this.typeUrl === "") {
            return void 0;
          }
          const messageType = registry.findMessage(this.typeUrlToName(this.typeUrl));
          if (!messageType) {
            return void 0;
          }
          return messageType.fromBinary(this.value);
        }
        is(type) {
          if (this.typeUrl === "") {
            return false;
          }
          const name = this.typeUrlToName(this.typeUrl);
          let typeName = "";
          if (typeof type === "string") {
            typeName = type;
          } else {
            typeName = type.typeName;
          }
          return name === typeName;
        }
        typeNameToUrl(name) {
          return `type.googleapis.com/${name}`;
        }
        typeUrlToName(url) {
          if (!url.length) {
            throw new Error(`invalid type url: ${url}`);
          }
          const slash = url.lastIndexOf("/");
          const name = slash > 0 ? url.substring(slash + 1) : url;
          if (!name.length) {
            throw new Error(`invalid type url: ${url}`);
          }
          return name;
        }
        static pack(message) {
          const any = new _Any();
          any.packFrom(message);
          return any;
        }
        static fromBinary(bytes, options) {
          return new _Any().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Any().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Any().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Any, a, b);
        }
      };
      Any.runtime = proto3;
      Any.typeName = "google.protobuf.Any";
      Any.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "value",
          kind: "scalar",
          T: 12
          /* ScalarType.BYTES */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js
  var Empty;
  var init_empty_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/empty_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      Empty = class _Empty extends Message {
        constructor(data) {
          super();
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Empty().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Empty().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Empty().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Empty, a, b);
        }
      };
      Empty.runtime = proto3;
      Empty.typeName = "google.protobuf.Empty";
      Empty.fields = proto3.util.newFieldList(() => []);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js
  var FieldMask;
  var init_field_mask_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/field_mask_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      FieldMask = class _FieldMask extends Message {
        constructor(data) {
          super();
          this.paths = [];
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          function protoCamelCase2(snakeCase) {
            let capNext = false;
            const b = [];
            for (let i = 0; i < snakeCase.length; i++) {
              let c = snakeCase.charAt(i);
              switch (c) {
                case "_":
                  capNext = true;
                  break;
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                  b.push(c);
                  capNext = false;
                  break;
                default:
                  if (capNext) {
                    capNext = false;
                    c = c.toUpperCase();
                  }
                  b.push(c);
                  break;
              }
            }
            return b.join("");
          }
          return this.paths.map((p) => {
            if (p.match(/_[0-9]?_/g) || p.match(/[A-Z]/g)) {
              throw new Error('cannot encode google.protobuf.FieldMask to JSON: lowerCamelCase of path name "' + p + '" is irreversible');
            }
            return protoCamelCase2(p);
          }).join(",");
        }
        fromJson(json, options) {
          if (typeof json !== "string") {
            throw new Error("cannot decode google.protobuf.FieldMask from JSON: " + proto3.json.debug(json));
          }
          if (json === "") {
            return this;
          }
          function camelToSnake(str) {
            if (str.includes("_")) {
              throw new Error("cannot decode google.protobuf.FieldMask from JSON: path names must be lowerCamelCase");
            }
            const sc = str.replace(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
            return sc[0] === "_" ? sc.substring(1) : sc;
          }
          this.paths = json.split(",").map(camelToSnake);
          return this;
        }
        static fromBinary(bytes, options) {
          return new _FieldMask().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FieldMask().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FieldMask().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_FieldMask, a, b);
        }
      };
      FieldMask.runtime = proto3;
      FieldMask.typeName = "google.protobuf.FieldMask";
      FieldMask.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "paths", kind: "scalar", T: 9, repeated: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js
  var NullValue, Struct, Value, ListValue;
  var init_struct_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/struct_pb.js"() {
      "use strict";
      init_proto3();
      init_message();
      (function(NullValue2) {
        NullValue2[NullValue2["NULL_VALUE"] = 0] = "NULL_VALUE";
      })(NullValue || (NullValue = {}));
      proto3.util.setEnumType(NullValue, "google.protobuf.NullValue", [
        { no: 0, name: "NULL_VALUE" }
      ]);
      Struct = class _Struct extends Message {
        constructor(data) {
          super();
          this.fields = {};
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          const json = {};
          for (const [k, v] of Object.entries(this.fields)) {
            json[k] = v.toJson(options);
          }
          return json;
        }
        fromJson(json, options) {
          if (typeof json != "object" || json == null || Array.isArray(json)) {
            throw new Error("cannot decode google.protobuf.Struct from JSON " + proto3.json.debug(json));
          }
          for (const [k, v] of Object.entries(json)) {
            this.fields[k] = Value.fromJson(v);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Struct().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Struct().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Struct().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Struct, a, b);
        }
      };
      Struct.runtime = proto3;
      Struct.typeName = "google.protobuf.Struct";
      Struct.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "fields", kind: "map", K: 9, V: { kind: "message", T: Value } }
      ]);
      Value = class _Value extends Message {
        constructor(data) {
          super();
          this.kind = { case: void 0 };
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          switch (this.kind.case) {
            case "nullValue":
              return null;
            case "numberValue":
              if (!Number.isFinite(this.kind.value)) {
                throw new Error("google.protobuf.Value cannot be NaN or Infinity");
              }
              return this.kind.value;
            case "boolValue":
              return this.kind.value;
            case "stringValue":
              return this.kind.value;
            case "structValue":
            case "listValue":
              return this.kind.value.toJson(Object.assign(Object.assign({}, options), { emitDefaultValues: true }));
          }
          throw new Error("google.protobuf.Value must have a value");
        }
        fromJson(json, options) {
          switch (typeof json) {
            case "number":
              this.kind = { case: "numberValue", value: json };
              break;
            case "string":
              this.kind = { case: "stringValue", value: json };
              break;
            case "boolean":
              this.kind = { case: "boolValue", value: json };
              break;
            case "object":
              if (json === null) {
                this.kind = { case: "nullValue", value: NullValue.NULL_VALUE };
              } else if (Array.isArray(json)) {
                this.kind = { case: "listValue", value: ListValue.fromJson(json) };
              } else {
                this.kind = { case: "structValue", value: Struct.fromJson(json) };
              }
              break;
            default:
              throw new Error("cannot decode google.protobuf.Value from JSON " + proto3.json.debug(json));
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Value, a, b);
        }
      };
      Value.runtime = proto3;
      Value.typeName = "google.protobuf.Value";
      Value.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "null_value", kind: "enum", T: proto3.getEnumType(NullValue), oneof: "kind" },
        { no: 2, name: "number_value", kind: "scalar", T: 1, oneof: "kind" },
        { no: 3, name: "string_value", kind: "scalar", T: 9, oneof: "kind" },
        { no: 4, name: "bool_value", kind: "scalar", T: 8, oneof: "kind" },
        { no: 5, name: "struct_value", kind: "message", T: Struct, oneof: "kind" },
        { no: 6, name: "list_value", kind: "message", T: ListValue, oneof: "kind" }
      ]);
      ListValue = class _ListValue extends Message {
        constructor(data) {
          super();
          this.values = [];
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return this.values.map((v) => v.toJson());
        }
        fromJson(json, options) {
          if (!Array.isArray(json)) {
            throw new Error("cannot decode google.protobuf.ListValue from JSON " + proto3.json.debug(json));
          }
          for (let e of json) {
            this.values.push(Value.fromJson(e));
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _ListValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ListValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ListValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_ListValue, a, b);
        }
      };
      ListValue.runtime = proto3;
      ListValue.typeName = "google.protobuf.ListValue";
      ListValue.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "values", kind: "message", T: Value, repeated: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js
  var DoubleValue, FloatValue, Int64Value, UInt64Value, Int32Value, UInt32Value, BoolValue, StringValue, BytesValue;
  var init_wrappers_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/wrappers_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      init_field();
      init_proto_int64();
      DoubleValue = class _DoubleValue extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.DOUBLE, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.DOUBLE, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.DoubleValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _DoubleValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DoubleValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DoubleValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_DoubleValue, a, b);
        }
      };
      DoubleValue.runtime = proto3;
      DoubleValue.typeName = "google.protobuf.DoubleValue";
      DoubleValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 1
          /* ScalarType.DOUBLE */
        }
      ]);
      DoubleValue.fieldWrapper = {
        wrapField(value) {
          return new DoubleValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      FloatValue = class _FloatValue extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.FLOAT, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.FLOAT, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.FloatValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _FloatValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _FloatValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _FloatValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_FloatValue, a, b);
        }
      };
      FloatValue.runtime = proto3;
      FloatValue.typeName = "google.protobuf.FloatValue";
      FloatValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 2
          /* ScalarType.FLOAT */
        }
      ]);
      FloatValue.fieldWrapper = {
        wrapField(value) {
          return new FloatValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      Int64Value = class _Int64Value extends Message {
        constructor(data) {
          super();
          this.value = protoInt64.zero;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.INT64, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.INT64, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.Int64Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Int64Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Int64Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Int64Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Int64Value, a, b);
        }
      };
      Int64Value.runtime = proto3;
      Int64Value.typeName = "google.protobuf.Int64Value";
      Int64Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 3
          /* ScalarType.INT64 */
        }
      ]);
      Int64Value.fieldWrapper = {
        wrapField(value) {
          return new Int64Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      UInt64Value = class _UInt64Value extends Message {
        constructor(data) {
          super();
          this.value = protoInt64.zero;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.UINT64, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.UINT64, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.UInt64Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _UInt64Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UInt64Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UInt64Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_UInt64Value, a, b);
        }
      };
      UInt64Value.runtime = proto3;
      UInt64Value.typeName = "google.protobuf.UInt64Value";
      UInt64Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 4
          /* ScalarType.UINT64 */
        }
      ]);
      UInt64Value.fieldWrapper = {
        wrapField(value) {
          return new UInt64Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      Int32Value = class _Int32Value extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.INT32, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.INT32, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.Int32Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _Int32Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Int32Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Int32Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Int32Value, a, b);
        }
      };
      Int32Value.runtime = proto3;
      Int32Value.typeName = "google.protobuf.Int32Value";
      Int32Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        }
      ]);
      Int32Value.fieldWrapper = {
        wrapField(value) {
          return new Int32Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      UInt32Value = class _UInt32Value extends Message {
        constructor(data) {
          super();
          this.value = 0;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.UINT32, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.UINT32, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.UInt32Value from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _UInt32Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UInt32Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UInt32Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_UInt32Value, a, b);
        }
      };
      UInt32Value.runtime = proto3;
      UInt32Value.typeName = "google.protobuf.UInt32Value";
      UInt32Value.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 13
          /* ScalarType.UINT32 */
        }
      ]);
      UInt32Value.fieldWrapper = {
        wrapField(value) {
          return new UInt32Value({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      BoolValue = class _BoolValue extends Message {
        constructor(data) {
          super();
          this.value = false;
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.BOOL, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.BOOL, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.BoolValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _BoolValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _BoolValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _BoolValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_BoolValue, a, b);
        }
      };
      BoolValue.runtime = proto3;
      BoolValue.typeName = "google.protobuf.BoolValue";
      BoolValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        }
      ]);
      BoolValue.fieldWrapper = {
        wrapField(value) {
          return new BoolValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      StringValue = class _StringValue extends Message {
        constructor(data) {
          super();
          this.value = "";
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.STRING, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.STRING, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.StringValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _StringValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _StringValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _StringValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_StringValue, a, b);
        }
      };
      StringValue.runtime = proto3;
      StringValue.typeName = "google.protobuf.StringValue";
      StringValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      StringValue.fieldWrapper = {
        wrapField(value) {
          return new StringValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
      BytesValue = class _BytesValue extends Message {
        constructor(data) {
          super();
          this.value = new Uint8Array(0);
          proto3.util.initPartial(data, this);
        }
        toJson(options) {
          return proto3.json.writeScalar(ScalarType.BYTES, this.value, true);
        }
        fromJson(json, options) {
          try {
            this.value = proto3.json.readScalar(ScalarType.BYTES, json);
          } catch (e) {
            let m = `cannot decode message google.protobuf.BytesValue from JSON"`;
            if (e instanceof Error && e.message.length > 0) {
              m += `: ${e.message}`;
            }
            throw new Error(m);
          }
          return this;
        }
        static fromBinary(bytes, options) {
          return new _BytesValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _BytesValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _BytesValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_BytesValue, a, b);
        }
      };
      BytesValue.runtime = proto3;
      BytesValue.typeName = "google.protobuf.BytesValue";
      BytesValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "value",
          kind: "scalar",
          T: 12
          /* ScalarType.BYTES */
        }
      ]);
      BytesValue.fieldWrapper = {
        wrapField(value) {
          return new BytesValue({ value });
        },
        unwrapField(value) {
          return value.value;
        }
      };
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js
  function createRegistryFromDescriptors(input, replaceWkt = true) {
    const set = input instanceof Uint8Array || input instanceof FileDescriptorSet ? createDescriptorSet(input) : input;
    const enums = {};
    const messages = {};
    const services = {};
    if (replaceWkt) {
      for (const mt of wkMessages) {
        messages[mt.typeName] = mt;
      }
      for (const et of wkEnums) {
        enums[et.typeName] = et;
      }
    }
    return {
      /**
       * May raise an error on invalid descriptors.
       */
      findEnum(typeName) {
        const existing = enums[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.enums.get(typeName);
        if (!desc) {
          return void 0;
        }
        const runtime = desc.file.syntax == "proto3" ? proto3 : proto2;
        const type = runtime.makeEnumType(typeName, desc.values.map((u) => ({
          no: u.number,
          name: u.name,
          localName: localName(u)
        })), {});
        enums[typeName] = type;
        return type;
      },
      /**
       * May raise an error on invalid descriptors.
       */
      findMessage(typeName) {
        const existing = messages[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.messages.get(typeName);
        if (!desc) {
          return void 0;
        }
        const runtime = desc.file.syntax == "proto3" ? proto3 : proto2;
        const fields = [];
        const type = runtime.makeMessageType(typeName, () => fields, {
          localName: localName(desc)
        });
        messages[typeName] = type;
        for (const field of desc.fields) {
          const fieldInfo = makeFieldInfo(field, this);
          fields.push(fieldInfo);
        }
        return type;
      },
      /**
       * May raise an error on invalid descriptors.
       */
      findService(typeName) {
        const existing = services[typeName];
        if (existing) {
          return existing;
        }
        const desc = set.services.get(typeName);
        if (!desc) {
          return void 0;
        }
        const methods = {};
        for (const method of desc.methods) {
          const I = this.findMessage(method.input.typeName);
          const O = this.findMessage(method.output.typeName);
          assert(I, `message "${method.input.typeName}" for ${method.toString()} not found`);
          assert(O, `output message "${method.output.typeName}" for ${method.toString()} not found`);
          methods[localName(method)] = {
            name: method.name,
            I,
            O,
            kind: method.methodKind,
            idempotency: method.idempotency
            // We do not surface options at this time
            // options: {},
          };
        }
        return services[typeName] = {
          typeName: desc.typeName,
          methods
        };
      }
    };
  }
  function makeFieldInfo(desc, resolver) {
    switch (desc.fieldKind) {
      case "map":
        return makeMapFieldInfo(desc, resolver);
      case "message":
        return makeMessageFieldInfo(desc, resolver);
      case "enum": {
        const fi = makeEnumFieldInfo(desc, resolver);
        fi.default = desc.getDefaultValue();
        return fi;
      }
      case "scalar": {
        const fi = makeScalarFieldInfo(desc);
        fi.default = desc.getDefaultValue();
        return fi;
      }
    }
  }
  function makeMapFieldInfo(field, resolver) {
    const base = {
      kind: "map",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      K: field.mapKey
    };
    if (field.mapValue.message) {
      const messageType = resolver.findMessage(field.mapValue.message.typeName);
      assert(messageType, `message "${field.mapValue.message.typeName}" for ${field.toString()} not found`);
      return Object.assign(Object.assign({}, base), { V: {
        kind: "message",
        T: messageType
      } });
    }
    if (field.mapValue.enum) {
      const enumType2 = resolver.findEnum(field.mapValue.enum.typeName);
      assert(enumType2, `enum "${field.mapValue.enum.typeName}" for ${field.toString()} not found`);
      return Object.assign(Object.assign({}, base), { V: {
        kind: "enum",
        T: enumType2
      } });
    }
    return Object.assign(Object.assign({}, base), { V: {
      kind: "scalar",
      T: field.mapValue.scalar
    } });
  }
  function makeScalarFieldInfo(field) {
    const base = {
      kind: "scalar",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: field.scalar
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0, T: field.scalar });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  function makeMessageFieldInfo(field, resolver) {
    const messageType = resolver.findMessage(field.message.typeName);
    assert(messageType, `message "${field.message.typeName}" for ${field.toString()} not found`);
    const base = {
      kind: "message",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: messageType
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0 });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  function makeEnumFieldInfo(field, resolver) {
    const enumType2 = resolver.findEnum(field.enum.typeName);
    assert(enumType2, `enum "${field.enum.typeName}" for ${field.toString()} not found`);
    const base = {
      kind: "enum",
      no: field.number,
      name: field.name,
      jsonName: field.jsonName,
      T: enumType2
    };
    if (field.repeated) {
      return Object.assign(Object.assign({}, base), { repeated: true, packed: field.packed, oneof: void 0 });
    }
    if (field.oneof) {
      return Object.assign(Object.assign({}, base), { oneof: field.oneof.name });
    }
    if (field.optional) {
      return Object.assign(Object.assign({}, base), { opt: true });
    }
    return base;
  }
  var wkMessages, wkEnums;
  var init_create_registry_from_desc = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/create-registry-from-desc.js"() {
      "use strict";
      init_assert();
      init_proto3();
      init_proto2();
      init_names();
      init_timestamp_pb();
      init_duration_pb();
      init_any_pb();
      init_empty_pb();
      init_field_mask_pb();
      init_struct_pb();
      init_enum();
      init_wrappers_pb();
      init_descriptor_pb();
      init_create_descriptor_set();
      wkMessages = [
        Any,
        Duration,
        Empty,
        FieldMask,
        Struct,
        Value,
        ListValue,
        Timestamp,
        Duration,
        DoubleValue,
        FloatValue,
        Int64Value,
        Int32Value,
        UInt32Value,
        UInt64Value,
        BoolValue,
        StringValue,
        BytesValue
      ];
      wkEnums = [getEnumType(NullValue)];
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/to-plain-message.js
  function toPlainMessage(message) {
    const type = message.getType();
    const target = {};
    for (const member of type.fields.byMember()) {
      const source = message[member.localName];
      let copy;
      if (member.repeated) {
        copy = source.map((e) => toPlainValue(e));
      } else if (member.kind == "map") {
        copy = {};
        for (const [key, v] of Object.entries(source)) {
          copy[key] = toPlainValue(v);
        }
      } else if (member.kind == "oneof") {
        const f = member.findField(source.case);
        copy = f ? { case: source.case, value: toPlainValue(source.value) } : { case: void 0 };
      } else {
        copy = toPlainValue(source);
      }
      target[member.localName] = copy;
    }
    return target;
  }
  function toPlainValue(value) {
    if (value === void 0) {
      return value;
    }
    if (value instanceof Message) {
      return toPlainMessage(value);
    }
    if (value instanceof Uint8Array) {
      const c = new Uint8Array(value.byteLength);
      c.set(value);
      return c;
    }
    return value;
  }
  var init_to_plain_message = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/to-plain-message.js"() {
      "use strict";
      init_message();
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js
  var Version, CodeGeneratorRequest, CodeGeneratorResponse, CodeGeneratorResponse_Feature, CodeGeneratorResponse_File;
  var init_plugin_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/compiler/plugin_pb.js"() {
      "use strict";
      init_message();
      init_proto2();
      init_descriptor_pb();
      Version = class _Version extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Version().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Version().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Version().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_Version, a, b);
        }
      };
      Version.runtime = proto2;
      Version.typeName = "google.protobuf.compiler.Version";
      Version.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "major", kind: "scalar", T: 5, opt: true },
        { no: 2, name: "minor", kind: "scalar", T: 5, opt: true },
        { no: 3, name: "patch", kind: "scalar", T: 5, opt: true },
        { no: 4, name: "suffix", kind: "scalar", T: 9, opt: true }
      ]);
      CodeGeneratorRequest = class _CodeGeneratorRequest extends Message {
        constructor(data) {
          super();
          this.fileToGenerate = [];
          this.protoFile = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorRequest().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorRequest().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorRequest().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorRequest, a, b);
        }
      };
      CodeGeneratorRequest.runtime = proto2;
      CodeGeneratorRequest.typeName = "google.protobuf.compiler.CodeGeneratorRequest";
      CodeGeneratorRequest.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "file_to_generate", kind: "scalar", T: 9, repeated: true },
        { no: 2, name: "parameter", kind: "scalar", T: 9, opt: true },
        { no: 15, name: "proto_file", kind: "message", T: FileDescriptorProto, repeated: true },
        { no: 3, name: "compiler_version", kind: "message", T: Version, opt: true }
      ]);
      CodeGeneratorResponse = class _CodeGeneratorResponse extends Message {
        constructor(data) {
          super();
          this.file = [];
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorResponse, a, b);
        }
      };
      CodeGeneratorResponse.runtime = proto2;
      CodeGeneratorResponse.typeName = "google.protobuf.compiler.CodeGeneratorResponse";
      CodeGeneratorResponse.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "error", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "supported_features", kind: "scalar", T: 4, opt: true },
        { no: 15, name: "file", kind: "message", T: CodeGeneratorResponse_File, repeated: true }
      ]);
      (function(CodeGeneratorResponse_Feature2) {
        CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["NONE"] = 0] = "NONE";
        CodeGeneratorResponse_Feature2[CodeGeneratorResponse_Feature2["PROTO3_OPTIONAL"] = 1] = "PROTO3_OPTIONAL";
      })(CodeGeneratorResponse_Feature || (CodeGeneratorResponse_Feature = {}));
      proto2.util.setEnumType(CodeGeneratorResponse_Feature, "google.protobuf.compiler.CodeGeneratorResponse.Feature", [
        { no: 0, name: "FEATURE_NONE" },
        { no: 1, name: "FEATURE_PROTO3_OPTIONAL" }
      ]);
      CodeGeneratorResponse_File = class _CodeGeneratorResponse_File extends Message {
        constructor(data) {
          super();
          proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CodeGeneratorResponse_File().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CodeGeneratorResponse_File().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CodeGeneratorResponse_File().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto2.util.equals(_CodeGeneratorResponse_File, a, b);
        }
      };
      CodeGeneratorResponse_File.runtime = proto2;
      CodeGeneratorResponse_File.typeName = "google.protobuf.compiler.CodeGeneratorResponse.File";
      CodeGeneratorResponse_File.fields = proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9, opt: true },
        { no: 2, name: "insertion_point", kind: "scalar", T: 9, opt: true },
        { no: 15, name: "content", kind: "scalar", T: 9, opt: true },
        { no: 16, name: "generated_code_info", kind: "message", T: GeneratedCodeInfo, opt: true }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js
  var SourceContext;
  var init_source_context_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/source_context_pb.js"() {
      "use strict";
      init_message();
      init_proto3();
      SourceContext = class _SourceContext extends Message {
        constructor(data) {
          super();
          this.fileName = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SourceContext().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SourceContext().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SourceContext().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_SourceContext, a, b);
        }
      };
      SourceContext.runtime = proto3;
      SourceContext.typeName = "google.protobuf.SourceContext";
      SourceContext.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "file_name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js
  var Syntax, Type, Field, Field_Kind, Field_Cardinality, Enum, EnumValue, Option;
  var init_type_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/type_pb.js"() {
      "use strict";
      init_proto3();
      init_message();
      init_source_context_pb();
      init_any_pb();
      (function(Syntax2) {
        Syntax2[Syntax2["PROTO2"] = 0] = "PROTO2";
        Syntax2[Syntax2["PROTO3"] = 1] = "PROTO3";
        Syntax2[Syntax2["EDITIONS"] = 2] = "EDITIONS";
      })(Syntax || (Syntax = {}));
      proto3.util.setEnumType(Syntax, "google.protobuf.Syntax", [
        { no: 0, name: "SYNTAX_PROTO2" },
        { no: 1, name: "SYNTAX_PROTO3" },
        { no: 2, name: "SYNTAX_EDITIONS" }
      ]);
      Type = class _Type extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.fields = [];
          this.oneofs = [];
          this.options = [];
          this.syntax = Syntax.PROTO2;
          this.edition = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Type().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Type().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Type().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Type, a, b);
        }
      };
      Type.runtime = proto3;
      Type.typeName = "google.protobuf.Type";
      Type.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "fields", kind: "message", T: Field, repeated: true },
        { no: 3, name: "oneofs", kind: "scalar", T: 9, repeated: true },
        { no: 4, name: "options", kind: "message", T: Option, repeated: true },
        { no: 5, name: "source_context", kind: "message", T: SourceContext },
        { no: 6, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
        {
          no: 7,
          name: "edition",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      Field = class _Field extends Message {
        constructor(data) {
          super();
          this.kind = Field_Kind.TYPE_UNKNOWN;
          this.cardinality = Field_Cardinality.UNKNOWN;
          this.number = 0;
          this.name = "";
          this.typeUrl = "";
          this.oneofIndex = 0;
          this.packed = false;
          this.options = [];
          this.jsonName = "";
          this.defaultValue = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Field().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Field().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Field().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Field, a, b);
        }
      };
      Field.runtime = proto3;
      Field.typeName = "google.protobuf.Field";
      Field.fields = proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "enum", T: proto3.getEnumType(Field_Kind) },
        { no: 2, name: "cardinality", kind: "enum", T: proto3.getEnumType(Field_Cardinality) },
        {
          no: 3,
          name: "number",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 4,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 6,
          name: "type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 7,
          name: "oneof_index",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        {
          no: 8,
          name: "packed",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        { no: 9, name: "options", kind: "message", T: Option, repeated: true },
        {
          no: 10,
          name: "json_name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 11,
          name: "default_value",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      (function(Field_Kind2) {
        Field_Kind2[Field_Kind2["TYPE_UNKNOWN"] = 0] = "TYPE_UNKNOWN";
        Field_Kind2[Field_Kind2["TYPE_DOUBLE"] = 1] = "TYPE_DOUBLE";
        Field_Kind2[Field_Kind2["TYPE_FLOAT"] = 2] = "TYPE_FLOAT";
        Field_Kind2[Field_Kind2["TYPE_INT64"] = 3] = "TYPE_INT64";
        Field_Kind2[Field_Kind2["TYPE_UINT64"] = 4] = "TYPE_UINT64";
        Field_Kind2[Field_Kind2["TYPE_INT32"] = 5] = "TYPE_INT32";
        Field_Kind2[Field_Kind2["TYPE_FIXED64"] = 6] = "TYPE_FIXED64";
        Field_Kind2[Field_Kind2["TYPE_FIXED32"] = 7] = "TYPE_FIXED32";
        Field_Kind2[Field_Kind2["TYPE_BOOL"] = 8] = "TYPE_BOOL";
        Field_Kind2[Field_Kind2["TYPE_STRING"] = 9] = "TYPE_STRING";
        Field_Kind2[Field_Kind2["TYPE_GROUP"] = 10] = "TYPE_GROUP";
        Field_Kind2[Field_Kind2["TYPE_MESSAGE"] = 11] = "TYPE_MESSAGE";
        Field_Kind2[Field_Kind2["TYPE_BYTES"] = 12] = "TYPE_BYTES";
        Field_Kind2[Field_Kind2["TYPE_UINT32"] = 13] = "TYPE_UINT32";
        Field_Kind2[Field_Kind2["TYPE_ENUM"] = 14] = "TYPE_ENUM";
        Field_Kind2[Field_Kind2["TYPE_SFIXED32"] = 15] = "TYPE_SFIXED32";
        Field_Kind2[Field_Kind2["TYPE_SFIXED64"] = 16] = "TYPE_SFIXED64";
        Field_Kind2[Field_Kind2["TYPE_SINT32"] = 17] = "TYPE_SINT32";
        Field_Kind2[Field_Kind2["TYPE_SINT64"] = 18] = "TYPE_SINT64";
      })(Field_Kind || (Field_Kind = {}));
      proto3.util.setEnumType(Field_Kind, "google.protobuf.Field.Kind", [
        { no: 0, name: "TYPE_UNKNOWN" },
        { no: 1, name: "TYPE_DOUBLE" },
        { no: 2, name: "TYPE_FLOAT" },
        { no: 3, name: "TYPE_INT64" },
        { no: 4, name: "TYPE_UINT64" },
        { no: 5, name: "TYPE_INT32" },
        { no: 6, name: "TYPE_FIXED64" },
        { no: 7, name: "TYPE_FIXED32" },
        { no: 8, name: "TYPE_BOOL" },
        { no: 9, name: "TYPE_STRING" },
        { no: 10, name: "TYPE_GROUP" },
        { no: 11, name: "TYPE_MESSAGE" },
        { no: 12, name: "TYPE_BYTES" },
        { no: 13, name: "TYPE_UINT32" },
        { no: 14, name: "TYPE_ENUM" },
        { no: 15, name: "TYPE_SFIXED32" },
        { no: 16, name: "TYPE_SFIXED64" },
        { no: 17, name: "TYPE_SINT32" },
        { no: 18, name: "TYPE_SINT64" }
      ]);
      (function(Field_Cardinality2) {
        Field_Cardinality2[Field_Cardinality2["UNKNOWN"] = 0] = "UNKNOWN";
        Field_Cardinality2[Field_Cardinality2["OPTIONAL"] = 1] = "OPTIONAL";
        Field_Cardinality2[Field_Cardinality2["REQUIRED"] = 2] = "REQUIRED";
        Field_Cardinality2[Field_Cardinality2["REPEATED"] = 3] = "REPEATED";
      })(Field_Cardinality || (Field_Cardinality = {}));
      proto3.util.setEnumType(Field_Cardinality, "google.protobuf.Field.Cardinality", [
        { no: 0, name: "CARDINALITY_UNKNOWN" },
        { no: 1, name: "CARDINALITY_OPTIONAL" },
        { no: 2, name: "CARDINALITY_REQUIRED" },
        { no: 3, name: "CARDINALITY_REPEATED" }
      ]);
      Enum = class _Enum extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.enumvalue = [];
          this.options = [];
          this.syntax = Syntax.PROTO2;
          this.edition = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Enum().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Enum().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Enum().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Enum, a, b);
        }
      };
      Enum.runtime = proto3;
      Enum.typeName = "google.protobuf.Enum";
      Enum.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "enumvalue", kind: "message", T: EnumValue, repeated: true },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true },
        { no: 4, name: "source_context", kind: "message", T: SourceContext },
        { no: 5, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) },
        {
          no: 6,
          name: "edition",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
      EnumValue = class _EnumValue extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.number = 0;
          this.options = [];
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _EnumValue().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _EnumValue().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _EnumValue().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_EnumValue, a, b);
        }
      };
      EnumValue.runtime = proto3;
      EnumValue.typeName = "google.protobuf.EnumValue";
      EnumValue.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "number",
          kind: "scalar",
          T: 5
          /* ScalarType.INT32 */
        },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true }
      ]);
      Option = class _Option extends Message {
        constructor(data) {
          super();
          this.name = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Option().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Option().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Option().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Option, a, b);
        }
      };
      Option.runtime = proto3;
      Option.typeName = "google.protobuf.Option";
      Option.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "value", kind: "message", T: Any }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js
  var Api, Method, Mixin;
  var init_api_pb = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/google/protobuf/api_pb.js"() {
      "use strict";
      init_message();
      init_type_pb();
      init_source_context_pb();
      init_proto3();
      Api = class _Api extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.methods = [];
          this.options = [];
          this.version = "";
          this.mixins = [];
          this.syntax = Syntax.PROTO2;
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Api().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Api().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Api().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Api, a, b);
        }
      };
      Api.runtime = proto3;
      Api.typeName = "google.protobuf.Api";
      Api.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 2, name: "methods", kind: "message", T: Method, repeated: true },
        { no: 3, name: "options", kind: "message", T: Option, repeated: true },
        {
          no: 4,
          name: "version",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        { no: 5, name: "source_context", kind: "message", T: SourceContext },
        { no: 6, name: "mixins", kind: "message", T: Mixin, repeated: true },
        { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
      ]);
      Method = class _Method extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.requestTypeUrl = "";
          this.requestStreaming = false;
          this.responseTypeUrl = "";
          this.responseStreaming = false;
          this.options = [];
          this.syntax = Syntax.PROTO2;
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Method().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Method().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Method().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Method, a, b);
        }
      };
      Method.runtime = proto3;
      Method.typeName = "google.protobuf.Method";
      Method.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "request_type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 3,
          name: "request_streaming",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        {
          no: 4,
          name: "response_type_url",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 5,
          name: "response_streaming",
          kind: "scalar",
          T: 8
          /* ScalarType.BOOL */
        },
        { no: 6, name: "options", kind: "message", T: Option, repeated: true },
        { no: 7, name: "syntax", kind: "enum", T: proto3.getEnumType(Syntax) }
      ]);
      Mixin = class _Mixin extends Message {
        constructor(data) {
          super();
          this.name = "";
          this.root = "";
          proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Mixin().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Mixin().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Mixin().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return proto3.util.equals(_Mixin, a, b);
        }
      };
      Mixin.runtime = proto3;
      Mixin.typeName = "google.protobuf.Mixin";
      Mixin.fields = proto3.util.newFieldList(() => [
        {
          no: 1,
          name: "name",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        },
        {
          no: 2,
          name: "root",
          kind: "scalar",
          T: 9
          /* ScalarType.STRING */
        }
      ]);
    }
  });

  // ../../node_modules/@bufbuild/protobuf/dist/esm/index.js
  var esm_exports = {};
  __export(esm_exports, {
    Any: () => Any,
    Api: () => Api,
    BinaryReader: () => BinaryReader,
    BinaryWriter: () => BinaryWriter,
    BoolValue: () => BoolValue,
    BytesValue: () => BytesValue,
    CodeGeneratorRequest: () => CodeGeneratorRequest,
    CodeGeneratorResponse: () => CodeGeneratorResponse,
    CodeGeneratorResponse_Feature: () => CodeGeneratorResponse_Feature,
    CodeGeneratorResponse_File: () => CodeGeneratorResponse_File,
    DescriptorProto: () => DescriptorProto,
    DescriptorProto_ExtensionRange: () => DescriptorProto_ExtensionRange,
    DescriptorProto_ReservedRange: () => DescriptorProto_ReservedRange,
    DoubleValue: () => DoubleValue,
    Duration: () => Duration,
    Empty: () => Empty,
    Enum: () => Enum,
    EnumDescriptorProto: () => EnumDescriptorProto,
    EnumDescriptorProto_EnumReservedRange: () => EnumDescriptorProto_EnumReservedRange,
    EnumOptions: () => EnumOptions,
    EnumValue: () => EnumValue,
    EnumValueDescriptorProto: () => EnumValueDescriptorProto,
    EnumValueOptions: () => EnumValueOptions,
    ExtensionRangeOptions: () => ExtensionRangeOptions,
    ExtensionRangeOptions_Declaration: () => ExtensionRangeOptions_Declaration,
    ExtensionRangeOptions_VerificationState: () => ExtensionRangeOptions_VerificationState,
    Field: () => Field,
    FieldDescriptorProto: () => FieldDescriptorProto,
    FieldDescriptorProto_Label: () => FieldDescriptorProto_Label,
    FieldDescriptorProto_Type: () => FieldDescriptorProto_Type,
    FieldMask: () => FieldMask,
    FieldOptions: () => FieldOptions,
    FieldOptions_CType: () => FieldOptions_CType,
    FieldOptions_JSType: () => FieldOptions_JSType,
    FieldOptions_OptionRetention: () => FieldOptions_OptionRetention,
    FieldOptions_OptionTargetType: () => FieldOptions_OptionTargetType,
    Field_Cardinality: () => Field_Cardinality,
    Field_Kind: () => Field_Kind,
    FileDescriptorProto: () => FileDescriptorProto,
    FileDescriptorSet: () => FileDescriptorSet,
    FileOptions: () => FileOptions,
    FileOptions_OptimizeMode: () => FileOptions_OptimizeMode,
    FloatValue: () => FloatValue,
    GeneratedCodeInfo: () => GeneratedCodeInfo,
    GeneratedCodeInfo_Annotation: () => GeneratedCodeInfo_Annotation,
    GeneratedCodeInfo_Annotation_Semantic: () => GeneratedCodeInfo_Annotation_Semantic,
    Int32Value: () => Int32Value,
    Int64Value: () => Int64Value,
    ListValue: () => ListValue,
    Message: () => Message,
    MessageOptions: () => MessageOptions,
    Method: () => Method,
    MethodDescriptorProto: () => MethodDescriptorProto,
    MethodIdempotency: () => MethodIdempotency,
    MethodKind: () => MethodKind,
    MethodOptions: () => MethodOptions,
    MethodOptions_IdempotencyLevel: () => MethodOptions_IdempotencyLevel,
    Mixin: () => Mixin,
    NullValue: () => NullValue,
    OneofDescriptorProto: () => OneofDescriptorProto,
    OneofOptions: () => OneofOptions,
    Option: () => Option,
    ScalarType: () => ScalarType,
    ServiceDescriptorProto: () => ServiceDescriptorProto,
    ServiceOptions: () => ServiceOptions,
    SourceCodeInfo: () => SourceCodeInfo,
    SourceCodeInfo_Location: () => SourceCodeInfo_Location,
    SourceContext: () => SourceContext,
    StringValue: () => StringValue,
    Struct: () => Struct,
    Syntax: () => Syntax,
    Timestamp: () => Timestamp,
    Type: () => Type,
    UInt32Value: () => UInt32Value,
    UInt64Value: () => UInt64Value,
    UninterpretedOption: () => UninterpretedOption,
    UninterpretedOption_NamePart: () => UninterpretedOption_NamePart,
    Value: () => Value,
    Version: () => Version,
    WireType: () => WireType,
    codegenInfo: () => codegenInfo,
    createDescriptorSet: () => createDescriptorSet,
    createRegistry: () => createRegistry,
    createRegistryFromDescriptors: () => createRegistryFromDescriptors,
    proto2: () => proto2,
    proto3: () => proto3,
    protoBase64: () => protoBase64,
    protoDelimited: () => protoDelimited,
    protoDouble: () => protoDouble,
    protoInt64: () => protoInt64,
    toPlainMessage: () => toPlainMessage
  });
  var init_esm = __esm({
    "../../node_modules/@bufbuild/protobuf/dist/esm/index.js"() {
      "use strict";
      init_proto3();
      init_proto2();
      init_proto_double();
      init_proto_int64();
      init_proto_base64();
      init_proto_delimited();
      init_codegen_info();
      init_message();
      init_field();
      init_service_type();
      init_binary_encoding();
      init_create_descriptor_set();
      init_create_registry();
      init_create_registry_from_desc();
      init_to_plain_message();
      init_plugin_pb();
      init_api_pb();
      init_any_pb();
      init_descriptor_pb();
      init_duration_pb();
      init_empty_pb();
      init_field_mask_pb();
      init_source_context_pb();
      init_struct_pb();
      init_timestamp_pb();
      init_type_pb();
      init_wrappers_pb();
    }
  });

  // ../protoc/dist/rtc/sctp_capabilities_pb.js
  var require_sctp_capabilities_pb = __commonJS({
    "../protoc/dist/rtc/sctp_capabilities_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoSctpCapabilities = exports.ProtoNumSctpStreams = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoNumSctpStreams = class _ProtoNumSctpStreams extends protobuf_1.Message {
        constructor(data) {
          super();
          this.OS = 0;
          this.MIS = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoNumSctpStreams().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoNumSctpStreams().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoNumSctpStreams().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoNumSctpStreams, a, b);
        }
      };
      exports.ProtoNumSctpStreams = ProtoNumSctpStreams;
      ProtoNumSctpStreams.runtime = protobuf_1.proto3;
      ProtoNumSctpStreams.typeName = "ProtoNumSctpStreams";
      ProtoNumSctpStreams.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "OS", kind: "scalar", T: 5 },
        { no: 2, name: "MIS", kind: "scalar", T: 5 }
      ]);
      var ProtoSctpCapabilities = class _ProtoSctpCapabilities extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpCapabilities().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpCapabilities().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpCapabilities().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpCapabilities, a, b);
        }
      };
      exports.ProtoSctpCapabilities = ProtoSctpCapabilities;
      ProtoSctpCapabilities.runtime = protobuf_1.proto3;
      ProtoSctpCapabilities.typeName = "ProtoSctpCapabilities";
      ProtoSctpCapabilities.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "numStreams", kind: "message", T: ProtoNumSctpStreams }
      ]);
    }
  });

  // ../protoc/dist/rtc/sdp_info_pb.js
  var require_sdp_info_pb = __commonJS({
    "../protoc/dist/rtc/sdp_info_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoTransportSDPInfo = exports.ProtoSctpParameters = exports.ProtoDtlsParameters = exports.ProtoIceCandidates = exports.ProtoIceParameters = exports.ProtoDtlsFingerPrints = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoDtlsFingerPrints = class _ProtoDtlsFingerPrints extends protobuf_1.Message {
        constructor(data) {
          super();
          this.algorithm = "";
          this.value = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoDtlsFingerPrints().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoDtlsFingerPrints().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoDtlsFingerPrints().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoDtlsFingerPrints, a, b);
        }
      };
      exports.ProtoDtlsFingerPrints = ProtoDtlsFingerPrints;
      ProtoDtlsFingerPrints.runtime = protobuf_1.proto3;
      ProtoDtlsFingerPrints.typeName = "ProtoDtlsFingerPrints";
      ProtoDtlsFingerPrints.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "algorithm", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "scalar", T: 9 }
      ]);
      var ProtoIceParameters = class _ProtoIceParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.usernameFragment = "";
          this.password = "";
          this.iceLite = false;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoIceParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoIceParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoIceParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoIceParameters, a, b);
        }
      };
      exports.ProtoIceParameters = ProtoIceParameters;
      ProtoIceParameters.runtime = protobuf_1.proto3;
      ProtoIceParameters.typeName = "ProtoIceParameters";
      ProtoIceParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "usernameFragment", kind: "scalar", T: 9 },
        { no: 2, name: "password", kind: "scalar", T: 9 },
        { no: 3, name: "iceLite", kind: "scalar", T: 8 }
      ]);
      var ProtoIceCandidates = class _ProtoIceCandidates extends protobuf_1.Message {
        constructor(data) {
          super();
          this.foundation = "";
          this.priority = 0;
          this.ip = "";
          this.port = 0;
          this.type = "";
          this.protocol = "";
          this.tcpType = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoIceCandidates().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoIceCandidates().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoIceCandidates().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoIceCandidates, a, b);
        }
      };
      exports.ProtoIceCandidates = ProtoIceCandidates;
      ProtoIceCandidates.runtime = protobuf_1.proto3;
      ProtoIceCandidates.typeName = "ProtoIceCandidates";
      ProtoIceCandidates.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "foundation", kind: "scalar", T: 9 },
        { no: 2, name: "priority", kind: "scalar", T: 5 },
        { no: 3, name: "ip", kind: "scalar", T: 9 },
        { no: 4, name: "port", kind: "scalar", T: 5 },
        { no: 5, name: "type", kind: "scalar", T: 9 },
        { no: 6, name: "protocol", kind: "scalar", T: 9 },
        { no: 7, name: "tcpType", kind: "scalar", T: 9 }
      ]);
      var ProtoDtlsParameters = class _ProtoDtlsParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.role = "";
          this.fingerprints = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoDtlsParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoDtlsParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoDtlsParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoDtlsParameters, a, b);
        }
      };
      exports.ProtoDtlsParameters = ProtoDtlsParameters;
      ProtoDtlsParameters.runtime = protobuf_1.proto3;
      ProtoDtlsParameters.typeName = "ProtoDtlsParameters";
      ProtoDtlsParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "role", kind: "scalar", T: 9 },
        { no: 2, name: "fingerprints", kind: "message", T: ProtoDtlsFingerPrints, repeated: true }
      ]);
      var ProtoSctpParameters = class _ProtoSctpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.port = 0;
          this.OS = 0;
          this.MIS = 0;
          this.maxMessageSize = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpParameters, a, b);
        }
      };
      exports.ProtoSctpParameters = ProtoSctpParameters;
      ProtoSctpParameters.runtime = protobuf_1.proto3;
      ProtoSctpParameters.typeName = "ProtoSctpParameters";
      ProtoSctpParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "port", kind: "scalar", T: 5 },
        { no: 2, name: "OS", kind: "scalar", T: 5 },
        { no: 3, name: "MIS", kind: "scalar", T: 5 },
        { no: 4, name: "maxMessageSize", kind: "scalar", T: 5 }
      ]);
      var ProtoTransportSDPInfo = class _ProtoTransportSDPInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.id = "";
          this.iceCandidates = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoTransportSDPInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoTransportSDPInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoTransportSDPInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoTransportSDPInfo, a, b);
        }
      };
      exports.ProtoTransportSDPInfo = ProtoTransportSDPInfo;
      ProtoTransportSDPInfo.runtime = protobuf_1.proto3;
      ProtoTransportSDPInfo.typeName = "ProtoTransportSDPInfo";
      ProtoTransportSDPInfo.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "iceCandidates", kind: "message", T: ProtoIceCandidates, repeated: true },
        { no: 3, name: "iceParameters", kind: "message", T: ProtoIceParameters },
        { no: 4, name: "dtlsParameters", kind: "message", T: ProtoDtlsParameters },
        { no: 5, name: "sctpParameters", kind: "message", T: ProtoSctpParameters }
      ]);
    }
  });

  // ../protoc/dist/rtc/rtp_parameters_pb.js
  var require_rtp_parameters_pb = __commonJS({
    "../protoc/dist/rtc/rtp_parameters_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoRtpParameters = exports.RtcpParameters = exports.ProtoEncodings_ProtoRTX = exports.ProtoEncodings = exports.ProtoHeaderExtensionParameters = exports.ProtoCodecParameters = exports.ProtoRtcpFeedback = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoRtcpFeedback = class _ProtoRtcpFeedback extends protobuf_1.Message {
        constructor(data) {
          super();
          this.type = "";
          this.parameter = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtcpFeedback().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtcpFeedback().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtcpFeedback().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtcpFeedback, a, b);
        }
      };
      exports.ProtoRtcpFeedback = ProtoRtcpFeedback;
      ProtoRtcpFeedback.runtime = protobuf_1.proto3;
      ProtoRtcpFeedback.typeName = "ProtoRtcpFeedback";
      ProtoRtcpFeedback.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "parameter", kind: "scalar", T: 9 }
      ]);
      var ProtoCodecParameters = class _ProtoCodecParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.mimeType = "";
          this.payloadType = 0;
          this.clockRate = 0;
          this.channels = 0;
          this.parameters = {};
          this.rtcpFeedback = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoCodecParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoCodecParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoCodecParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoCodecParameters, a, b);
        }
      };
      exports.ProtoCodecParameters = ProtoCodecParameters;
      ProtoCodecParameters.runtime = protobuf_1.proto3;
      ProtoCodecParameters.typeName = "ProtoCodecParameters";
      ProtoCodecParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "mimeType", kind: "scalar", T: 9 },
        { no: 2, name: "payloadType", kind: "scalar", T: 5 },
        { no: 3, name: "clockRate", kind: "scalar", T: 5 },
        { no: 4, name: "channels", kind: "scalar", T: 5 },
        { no: 6, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
        { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtcpFeedback, repeated: true }
      ]);
      var ProtoHeaderExtensionParameters = class _ProtoHeaderExtensionParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.uri = "";
          this.id = 0;
          this.encrypt = false;
          this.parameters = {};
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoHeaderExtensionParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoHeaderExtensionParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoHeaderExtensionParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoHeaderExtensionParameters, a, b);
        }
      };
      exports.ProtoHeaderExtensionParameters = ProtoHeaderExtensionParameters;
      ProtoHeaderExtensionParameters.runtime = protobuf_1.proto3;
      ProtoHeaderExtensionParameters.typeName = "ProtoHeaderExtensionParameters";
      ProtoHeaderExtensionParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "uri", kind: "scalar", T: 9 },
        { no: 2, name: "id", kind: "scalar", T: 5 },
        { no: 3, name: "encrypt", kind: "scalar", T: 8 },
        { no: 4, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } }
      ]);
      var ProtoEncodings2 = class _ProtoEncodings extends protobuf_1.Message {
        constructor(data) {
          super();
          this.ssrc = protobuf_1.protoInt64.zero;
          this.rid = "";
          this.codecPayloadType = 0;
          this.dtx = false;
          this.scalabilityMode = "";
          this.scaleResolutionDownBy = 0;
          this.maxBitrate = 0;
          this.active = false;
          this.maxFramerate = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoEncodings().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoEncodings().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoEncodings().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoEncodings, a, b);
        }
      };
      exports.ProtoEncodings = ProtoEncodings2;
      ProtoEncodings2.runtime = protobuf_1.proto3;
      ProtoEncodings2.typeName = "ProtoEncodings";
      ProtoEncodings2.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "ssrc", kind: "scalar", T: 3 },
        { no: 2, name: "rid", kind: "scalar", T: 9 },
        { no: 3, name: "codecPayloadType", kind: "scalar", T: 5 },
        { no: 4, name: "rtx", kind: "message", T: ProtoEncodings_ProtoRTX },
        { no: 5, name: "dtx", kind: "scalar", T: 8 },
        { no: 6, name: "scalabilityMode", kind: "scalar", T: 9 },
        { no: 7, name: "scaleResolutionDownBy", kind: "scalar", T: 5 },
        { no: 8, name: "maxBitrate", kind: "scalar", T: 5 },
        { no: 9, name: "active", kind: "scalar", T: 8 },
        { no: 10, name: "maxFramerate", kind: "scalar", T: 5 }
      ]);
      var ProtoEncodings_ProtoRTX = class _ProtoEncodings_ProtoRTX extends protobuf_1.Message {
        constructor(data) {
          super();
          this.ssrc = protobuf_1.protoInt64.zero;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoEncodings_ProtoRTX().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoEncodings_ProtoRTX().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoEncodings_ProtoRTX().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoEncodings_ProtoRTX, a, b);
        }
      };
      exports.ProtoEncodings_ProtoRTX = ProtoEncodings_ProtoRTX;
      ProtoEncodings_ProtoRTX.runtime = protobuf_1.proto3;
      ProtoEncodings_ProtoRTX.typeName = "ProtoEncodings.ProtoRTX";
      ProtoEncodings_ProtoRTX.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "ssrc", kind: "scalar", T: 3 }
      ]);
      var RtcpParameters = class _RtcpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.cname = "";
          this.reducedSize = false;
          this.mux = false;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RtcpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RtcpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RtcpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_RtcpParameters, a, b);
        }
      };
      exports.RtcpParameters = RtcpParameters;
      RtcpParameters.runtime = protobuf_1.proto3;
      RtcpParameters.typeName = "RtcpParameters";
      RtcpParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "cname", kind: "scalar", T: 9 },
        { no: 2, name: "reducedSize", kind: "scalar", T: 8 },
        { no: 3, name: "mux", kind: "scalar", T: 8 }
      ]);
      var ProtoRtpParameters2 = class _ProtoRtpParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.mid = "";
          this.codecs = [];
          this.headerExtensions = [];
          this.encodings = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpParameters, a, b);
        }
      };
      exports.ProtoRtpParameters = ProtoRtpParameters2;
      ProtoRtpParameters2.runtime = protobuf_1.proto3;
      ProtoRtpParameters2.typeName = "ProtoRtpParameters";
      ProtoRtpParameters2.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "mid", kind: "scalar", T: 9 },
        { no: 2, name: "codecs", kind: "message", T: ProtoCodecParameters, repeated: true },
        { no: 3, name: "headerExtensions", kind: "message", T: ProtoHeaderExtensionParameters, repeated: true },
        { no: 4, name: "encodings", kind: "message", T: ProtoEncodings2, repeated: true },
        { no: 5, name: "rtcp", kind: "message", T: RtcpParameters }
      ]);
    }
  });

  // ../protoc/dist/client/app_data_pb.js
  var require_app_data_pb = __commonJS({
    "../protoc/dist/client/app_data_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AppData = exports.Value = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var Value2 = class _Value extends protobuf_1.Message {
        constructor(data) {
          super();
          this.valueType = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Value().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Value().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Value().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Value, a, b);
        }
      };
      exports.Value = Value2;
      Value2.runtime = protobuf_1.proto2;
      Value2.typeName = "Value";
      Value2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "string_value", kind: "scalar", T: 9, oneof: "value_type" },
        { no: 2, name: "int_value", kind: "scalar", T: 5, oneof: "value_type" },
        { no: 3, name: "float_value", kind: "scalar", T: 2, oneof: "value_type" }
      ]);
      var AppData = class _AppData extends protobuf_1.Message {
        constructor(data) {
          super();
          this.appData = {};
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _AppData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _AppData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _AppData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_AppData, a, b);
        }
      };
      exports.AppData = AppData;
      AppData.runtime = protobuf_1.proto2;
      AppData.typeName = "AppData";
      AppData.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "appData", kind: "map", K: 9, V: { kind: "message", T: Value2 } }
      ]);
    }
  });

  // ../protoc/dist/rtc/sctp_stream_parameters_pb.js
  var require_sctp_stream_parameters_pb = __commonJS({
    "../protoc/dist/rtc/sctp_stream_parameters_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoSctpStreamParameters = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoSctpStreamParameters = class _ProtoSctpStreamParameters extends protobuf_1.Message {
        constructor(data) {
          super();
          this.streamId = 0;
          this.ordered = false;
          this.maxPacketLifeTime = 0;
          this.maxRetransmits = 0;
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoSctpStreamParameters().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoSctpStreamParameters().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoSctpStreamParameters().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoSctpStreamParameters, a, b);
        }
      };
      exports.ProtoSctpStreamParameters = ProtoSctpStreamParameters;
      ProtoSctpStreamParameters.runtime = protobuf_1.proto3;
      ProtoSctpStreamParameters.typeName = "ProtoSctpStreamParameters";
      ProtoSctpStreamParameters.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "streamId", kind: "scalar", T: 5 },
        { no: 2, name: "ordered", kind: "scalar", T: 8 },
        { no: 3, name: "maxPacketLifeTime", kind: "scalar", T: 5 },
        { no: 4, name: "maxRetransmits", kind: "scalar", T: 5 }
      ]);
    }
  });

  // ../protoc/dist/client/room_control_pb.js
  var require_room_control_pb = __commonJS({
    "../protoc/dist/client/room_control_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProduceSourcesControl = exports.RoomControlType = exports.ProduceSources = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProduceSources = class _ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceSources, a, b);
        }
      };
      exports.ProduceSources = ProduceSources;
      ProduceSources.runtime = protobuf_1.proto2;
      ProduceSources.typeName = "ProduceSources";
      ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "mic", kind: "scalar", T: 8 },
        { no: 2, name: "cam", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
      var RoomControlType = class _RoomControlType extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControlType().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControlType().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControlType().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControlType, a, b);
        }
      };
      exports.RoomControlType = RoomControlType;
      RoomControlType.runtime = protobuf_1.proto2;
      RoomControlType.typeName = "RoomControlType";
      RoomControlType.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 5, name: "value", kind: "scalar", T: 8 }
      ]);
      var ProduceSourcesControl = class _ProduceSourcesControl extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceSourcesControl().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceSourcesControl().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceSourcesControl().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceSourcesControl, a, b);
        }
      };
      exports.ProduceSourcesControl = ProduceSourcesControl;
      ProduceSourcesControl.runtime = protobuf_1.proto2;
      ProduceSourcesControl.typeName = "ProduceSourcesControl";
      ProduceSourcesControl.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "value", kind: "message", T: ProduceSources }
      ]);
    }
  });

  // ../protoc/dist/client/permissions_pb.js
  var require_permissions_pb = __commonJS({
    "../protoc/dist/client/permissions_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Permissions_ProduceSources = exports.Permissions = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var Permissions2 = class _Permissions extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Permissions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Permissions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Permissions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Permissions, a, b);
        }
      };
      exports.Permissions = Permissions2;
      Permissions2.runtime = protobuf_1.proto2;
      Permissions2.typeName = "Permissions";
      Permissions2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "admin", kind: "scalar", T: 8 },
        { no: 2, name: "canConsume", kind: "scalar", T: 8 },
        { no: 3, name: "canProduce", kind: "scalar", T: 8 },
        { no: 4, name: "canProduceSources", kind: "message", T: Permissions_ProduceSources },
        { no: 5, name: "canSendData", kind: "scalar", T: 8 },
        { no: 6, name: "canRecvData", kind: "scalar", T: 8 },
        { no: 7, name: "canUpdateMetadata", kind: "scalar", T: 8 }
      ]);
      var Permissions_ProduceSources = class _Permissions_ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Permissions_ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Permissions_ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Permissions_ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Permissions_ProduceSources, a, b);
        }
      };
      exports.Permissions_ProduceSources = Permissions_ProduceSources;
      Permissions_ProduceSources.runtime = protobuf_1.proto2;
      Permissions_ProduceSources.typeName = "Permissions.ProduceSources";
      Permissions_ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "cam", kind: "scalar", T: 8 },
        { no: 2, name: "mic", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
    }
  });

  // ../protoc/dist/client/request_pb.js
  var require_request_pb = __commonJS({
    "../protoc/dist/client/request_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Request = exports.CloseRoom = exports.KickPeer = exports.DenyLobbyPeer = exports.AcceptLobbyPeer = exports.CloseStreamOfLabel = exports.UpdateRoomMetadata = exports.UpdatePeerMetadata = exports.UpdatePeerRole = exports.ActivateSpeakerNotification = exports.UpdatePeerPermission = exports.UpdateRoomControls = exports.SendData = exports.RestartTransportIce = exports.SyncMeetingState = exports.ResumeConsumer = exports.CloseConsumer = exports.CloseProducer = exports.Consume = exports.ProduceData = exports.Produce = exports.CreateDataConsumer = exports.ConnectTransport = exports.CreateTransport = exports.ConnectRoom = exports.TestEvent = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var sctp_capabilities_pb_js_1 = require_sctp_capabilities_pb();
      var sdp_info_pb_js_1 = require_sdp_info_pb();
      var rtp_parameters_pb_js_1 = require_rtp_parameters_pb();
      var app_data_pb_js_1 = require_app_data_pb();
      var sctp_stream_parameters_pb_js_1 = require_sctp_stream_parameters_pb();
      var room_control_pb_js_1 = require_room_control_pb();
      var permissions_pb_js_1 = require_permissions_pb();
      var TestEvent = class _TestEvent extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _TestEvent().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _TestEvent().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _TestEvent().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_TestEvent, a, b);
        }
      };
      exports.TestEvent = TestEvent;
      TestEvent.runtime = protobuf_1.proto2;
      TestEvent.typeName = "TestEvent";
      TestEvent.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "name", kind: "scalar", T: 9 },
        { no: 2, name: "payload", kind: "scalar", T: 9 },
        { no: 3, name: "from", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "to", kind: "scalar", T: 9, opt: true }
      ]);
      var ConnectRoom2 = class _ConnectRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoom, a, b);
        }
      };
      exports.ConnectRoom = ConnectRoom2;
      ConnectRoom2.runtime = protobuf_1.proto2;
      ConnectRoom2.typeName = "ConnectRoom";
      ConnectRoom2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomId", kind: "scalar", T: 9 }
      ]);
      var CreateTransport2 = class _CreateTransport extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateTransport().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateTransport().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateTransport().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateTransport, a, b);
        }
      };
      exports.CreateTransport = CreateTransport2;
      CreateTransport2.runtime = protobuf_1.proto2;
      CreateTransport2.typeName = "CreateTransport";
      CreateTransport2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "sctpCapabilities", kind: "message", T: sctp_capabilities_pb_js_1.ProtoSctpCapabilities },
        { no: 2, name: "transportType", kind: "scalar", T: 9 }
      ]);
      var ConnectTransport2 = class _ConnectTransport extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectTransport().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectTransport().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectTransport().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectTransport, a, b);
        }
      };
      exports.ConnectTransport = ConnectTransport2;
      ConnectTransport2.runtime = protobuf_1.proto2;
      ConnectTransport2.typeName = "ConnectTransport";
      ConnectTransport2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "dtlsParameters", kind: "message", T: sdp_info_pb_js_1.ProtoDtlsParameters }
      ]);
      var CreateDataConsumer2 = class _CreateDataConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateDataConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateDataConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateDataConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateDataConsumer, a, b);
        }
      };
      exports.CreateDataConsumer = CreateDataConsumer2;
      CreateDataConsumer2.runtime = protobuf_1.proto2;
      CreateDataConsumer2.typeName = "CreateDataConsumer";
      CreateDataConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 }
      ]);
      var Produce2 = class _Produce extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Produce().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Produce().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Produce().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Produce, a, b);
        }
      };
      exports.Produce = Produce2;
      Produce2.runtime = protobuf_1.proto2;
      Produce2.typeName = "Produce";
      Produce2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "kind", kind: "scalar", T: 9 },
        { no: 3, name: "rtpParameters", kind: "message", T: rtp_parameters_pb_js_1.ProtoRtpParameters },
        { no: 4, name: "paused", kind: "scalar", T: 8 },
        { no: 5, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ProduceData2 = class _ProduceData extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceData, a, b);
        }
      };
      exports.ProduceData = ProduceData2;
      ProduceData2.runtime = protobuf_1.proto2;
      ProduceData2.typeName = "ProduceData";
      ProduceData2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportId", kind: "scalar", T: 9 },
        { no: 2, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "protocol", kind: "scalar", T: 9, opt: true },
        { no: 5, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var Consume2 = class _Consume extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Consume().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Consume().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Consume().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Consume, a, b);
        }
      };
      exports.Consume = Consume2;
      Consume2.runtime = protobuf_1.proto2;
      Consume2.typeName = "Consume";
      Consume2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producerPeerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var CloseProducer2 = class _CloseProducer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseProducer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseProducer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseProducer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseProducer, a, b);
        }
      };
      exports.CloseProducer = CloseProducer2;
      CloseProducer2.runtime = protobuf_1.proto2;
      CloseProducer2.typeName = "CloseProducer";
      CloseProducer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producerId", kind: "scalar", T: 9 }
      ]);
      var CloseConsumer2 = class _CloseConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseConsumer, a, b);
        }
      };
      exports.CloseConsumer = CloseConsumer2;
      CloseConsumer2.runtime = protobuf_1.proto2;
      CloseConsumer2.typeName = "CloseConsumer";
      CloseConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var ResumeConsumer2 = class _ResumeConsumer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ResumeConsumer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ResumeConsumer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ResumeConsumer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ResumeConsumer, a, b);
        }
      };
      exports.ResumeConsumer = ResumeConsumer2;
      ResumeConsumer2.runtime = protobuf_1.proto2;
      ResumeConsumer2.typeName = "ResumeConsumer";
      ResumeConsumer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "consumerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerPeerId", kind: "scalar", T: 9 }
      ]);
      var SyncMeetingState2 = class _SyncMeetingState extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SyncMeetingState().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SyncMeetingState().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SyncMeetingState().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SyncMeetingState, a, b);
        }
      };
      exports.SyncMeetingState = SyncMeetingState2;
      SyncMeetingState2.runtime = protobuf_1.proto2;
      SyncMeetingState2.typeName = "SyncMeetingState";
      SyncMeetingState2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var RestartTransportIce2 = class _RestartTransportIce extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RestartTransportIce().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RestartTransportIce().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RestartTransportIce().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RestartTransportIce, a, b);
        }
      };
      exports.RestartTransportIce = RestartTransportIce2;
      RestartTransportIce2.runtime = protobuf_1.proto2;
      RestartTransportIce2.typeName = "RestartTransportIce";
      RestartTransportIce2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportId", kind: "scalar", T: 9 }
      ]);
      var SendData2 = class _SendData extends protobuf_1.Message {
        constructor(data) {
          super();
          this.to = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SendData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SendData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SendData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SendData, a, b);
        }
      };
      exports.SendData = SendData2;
      SendData2.runtime = protobuf_1.proto2;
      SendData2.typeName = "SendData";
      SendData2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "to", kind: "scalar", T: 9, repeated: true },
        { no: 2, name: "label", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "payload", kind: "scalar", T: 9 }
      ]);
      var UpdateRoomControls2 = class _UpdateRoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          this.control = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdateRoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdateRoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdateRoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdateRoomControls, a, b);
        }
      };
      exports.UpdateRoomControls = UpdateRoomControls2;
      UpdateRoomControls2.runtime = protobuf_1.proto2;
      UpdateRoomControls2.typeName = "UpdateRoomControls";
      UpdateRoomControls2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "room_control", kind: "message", T: room_control_pb_js_1.RoomControlType, oneof: "control" },
        { no: 2, name: "produce_sources_control", kind: "message", T: room_control_pb_js_1.ProduceSourcesControl, oneof: "control" }
      ]);
      var UpdatePeerPermission2 = class _UpdatePeerPermission extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerPermission().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerPermission().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerPermission().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerPermission, a, b);
        }
      };
      exports.UpdatePeerPermission = UpdatePeerPermission2;
      UpdatePeerPermission2.runtime = protobuf_1.proto2;
      UpdatePeerPermission2.typeName = "UpdatePeerPermission";
      UpdatePeerPermission2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "permissions", kind: "message", T: permissions_pb_js_1.Permissions, opt: true }
      ]);
      var ActivateSpeakerNotification2 = class _ActivateSpeakerNotification extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ActivateSpeakerNotification().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ActivateSpeakerNotification().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ActivateSpeakerNotification().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ActivateSpeakerNotification, a, b);
        }
      };
      exports.ActivateSpeakerNotification = ActivateSpeakerNotification2;
      ActivateSpeakerNotification2.runtime = protobuf_1.proto2;
      ActivateSpeakerNotification2.typeName = "ActivateSpeakerNotification";
      ActivateSpeakerNotification2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "size", kind: "scalar", T: 5, opt: true }
      ]);
      var UpdatePeerRole2 = class _UpdatePeerRole extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerRole().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerRole().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerRole().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerRole, a, b);
        }
      };
      exports.UpdatePeerRole = UpdatePeerRole2;
      UpdatePeerRole2.runtime = protobuf_1.proto2;
      UpdatePeerRole2.typeName = "UpdatePeerRole";
      UpdatePeerRole2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 }
      ]);
      var UpdatePeerMetadata2 = class _UpdatePeerMetadata extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdatePeerMetadata().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdatePeerMetadata().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdatePeerMetadata().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdatePeerMetadata, a, b);
        }
      };
      exports.UpdatePeerMetadata = UpdatePeerMetadata2;
      UpdatePeerMetadata2.runtime = protobuf_1.proto2;
      UpdatePeerMetadata2.typeName = "UpdatePeerMetadata";
      UpdatePeerMetadata2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var UpdateRoomMetadata2 = class _UpdateRoomMetadata extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _UpdateRoomMetadata().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _UpdateRoomMetadata().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _UpdateRoomMetadata().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_UpdateRoomMetadata, a, b);
        }
      };
      exports.UpdateRoomMetadata = UpdateRoomMetadata2;
      UpdateRoomMetadata2.runtime = protobuf_1.proto2;
      UpdateRoomMetadata2.typeName = "UpdateRoomMetadata";
      UpdateRoomMetadata2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var CloseStreamOfLabel2 = class _CloseStreamOfLabel extends protobuf_1.Message {
        constructor(data) {
          super();
          this.peerIds = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseStreamOfLabel().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseStreamOfLabel().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseStreamOfLabel().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseStreamOfLabel, a, b);
        }
      };
      exports.CloseStreamOfLabel = CloseStreamOfLabel2;
      CloseStreamOfLabel2.runtime = protobuf_1.proto2;
      CloseStreamOfLabel2.typeName = "CloseStreamOfLabel";
      CloseStreamOfLabel2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "peerIds", kind: "scalar", T: 9, repeated: true }
      ]);
      var AcceptLobbyPeer2 = class _AcceptLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _AcceptLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _AcceptLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _AcceptLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_AcceptLobbyPeer, a, b);
        }
      };
      exports.AcceptLobbyPeer = AcceptLobbyPeer2;
      AcceptLobbyPeer2.runtime = protobuf_1.proto2;
      AcceptLobbyPeer2.typeName = "AcceptLobbyPeer";
      AcceptLobbyPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var DenyLobbyPeer2 = class _DenyLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _DenyLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _DenyLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _DenyLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_DenyLobbyPeer, a, b);
        }
      };
      exports.DenyLobbyPeer = DenyLobbyPeer2;
      DenyLobbyPeer2.runtime = protobuf_1.proto2;
      DenyLobbyPeer2.typeName = "DenyLobbyPeer";
      DenyLobbyPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var KickPeer2 = class _KickPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _KickPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _KickPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _KickPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_KickPeer, a, b);
        }
      };
      exports.KickPeer = KickPeer2;
      KickPeer2.runtime = protobuf_1.proto2;
      KickPeer2.typeName = "KickPeer";
      KickPeer2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var CloseRoom2 = class _CloseRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseRoom, a, b);
        }
      };
      exports.CloseRoom = CloseRoom2;
      CloseRoom2.runtime = protobuf_1.proto2;
      CloseRoom2.typeName = "CloseRoom";
      CloseRoom2.fields = protobuf_1.proto2.util.newFieldList(() => []);
      var Request2 = class _Request extends protobuf_1.Message {
        constructor(data) {
          super();
          this.request = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Request().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Request().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Request().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Request, a, b);
        }
      };
      exports.Request = Request2;
      Request2.runtime = protobuf_1.proto2;
      Request2.typeName = "Request";
      Request2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 2, name: "connect_room", kind: "message", T: ConnectRoom2, oneof: "request" },
        { no: 3, name: "create_transport", kind: "message", T: CreateTransport2, oneof: "request" },
        { no: 4, name: "connect_transport", kind: "message", T: ConnectTransport2, oneof: "request" },
        { no: 25, name: "create_data_consumer", kind: "message", T: CreateDataConsumer2, oneof: "request" },
        { no: 5, name: "produce", kind: "message", T: Produce2, oneof: "request" },
        { no: 6, name: "produce_data", kind: "message", T: ProduceData2, oneof: "request" },
        { no: 7, name: "consume", kind: "message", T: Consume2, oneof: "request" },
        { no: 8, name: "close_producer", kind: "message", T: CloseProducer2, oneof: "request" },
        { no: 9, name: "close_consumer", kind: "message", T: CloseConsumer2, oneof: "request" },
        { no: 10, name: "resume_consumer", kind: "message", T: ResumeConsumer2, oneof: "request" },
        { no: 11, name: "sync_meeting_state", kind: "message", T: SyncMeetingState2, oneof: "request" },
        { no: 12, name: "restart_transport_ice", kind: "message", T: RestartTransportIce2, oneof: "request" },
        { no: 13, name: "send_data", kind: "message", T: SendData2, oneof: "request" },
        { no: 14, name: "update_room_controls", kind: "message", T: UpdateRoomControls2, oneof: "request" },
        { no: 15, name: "update_peer_permission", kind: "message", T: UpdatePeerPermission2, oneof: "request" },
        { no: 16, name: "activate_speaker_notification", kind: "message", T: ActivateSpeakerNotification2, oneof: "request" },
        { no: 17, name: "update_peer_role", kind: "message", T: UpdatePeerRole2, oneof: "request" },
        { no: 18, name: "update_peer_metadata", kind: "message", T: UpdatePeerMetadata2, oneof: "request" },
        { no: 19, name: "update_room_metadata", kind: "message", T: UpdateRoomMetadata2, oneof: "request" },
        { no: 20, name: "close_stream_of_label", kind: "message", T: CloseStreamOfLabel2, oneof: "request" },
        { no: 21, name: "accept_lobby_peer", kind: "message", T: AcceptLobbyPeer2, oneof: "request" },
        { no: 22, name: "deny_lobby_peer", kind: "message", T: DenyLobbyPeer2, oneof: "request" },
        { no: 23, name: "kick_peer", kind: "message", T: KickPeer2, oneof: "request" },
        { no: 24, name: "close_room", kind: "message", T: CloseRoom2, oneof: "request" }
      ]);
    }
  });

  // ../protoc/dist/rtc/rtp_capabilities_pb.js
  var require_rtp_capabilities_pb = __commonJS({
    "../protoc/dist/rtc/rtp_capabilities_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ProtoRtpCapabilities = exports.ProtoRtpHeaderExtension = exports.ProtoRtpCodecCapability_ProtoRtcpFeedback = exports.ProtoRtpCodecCapability = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var ProtoRtpCodecCapability = class _ProtoRtpCodecCapability extends protobuf_1.Message {
        constructor(data) {
          super();
          this.kind = "";
          this.mimeType = "";
          this.preferredPayloadType = 0;
          this.clockRate = 0;
          this.channels = 0;
          this.parameters = {};
          this.rtcpFeedback = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCodecCapability().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCodecCapability().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCodecCapability().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCodecCapability, a, b);
        }
      };
      exports.ProtoRtpCodecCapability = ProtoRtpCodecCapability;
      ProtoRtpCodecCapability.runtime = protobuf_1.proto3;
      ProtoRtpCodecCapability.typeName = "ProtoRtpCodecCapability";
      ProtoRtpCodecCapability.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "scalar", T: 9 },
        { no: 2, name: "mimeType", kind: "scalar", T: 9 },
        { no: 3, name: "preferredPayloadType", kind: "scalar", T: 5 },
        { no: 4, name: "clockRate", kind: "scalar", T: 5 },
        { no: 5, name: "channels", kind: "scalar", T: 5 },
        { no: 6, name: "parameters", kind: "map", K: 9, V: { kind: "scalar", T: 9 } },
        { no: 7, name: "rtcpFeedback", kind: "message", T: ProtoRtpCodecCapability_ProtoRtcpFeedback, repeated: true }
      ]);
      var ProtoRtpCodecCapability_ProtoRtcpFeedback = class _ProtoRtpCodecCapability_ProtoRtcpFeedback extends protobuf_1.Message {
        constructor(data) {
          super();
          this.type = "";
          this.parameter = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCodecCapability_ProtoRtcpFeedback().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCodecCapability_ProtoRtcpFeedback, a, b);
        }
      };
      exports.ProtoRtpCodecCapability_ProtoRtcpFeedback = ProtoRtpCodecCapability_ProtoRtcpFeedback;
      ProtoRtpCodecCapability_ProtoRtcpFeedback.runtime = protobuf_1.proto3;
      ProtoRtpCodecCapability_ProtoRtcpFeedback.typeName = "ProtoRtpCodecCapability.ProtoRtcpFeedback";
      ProtoRtpCodecCapability_ProtoRtcpFeedback.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "type", kind: "scalar", T: 9 },
        { no: 2, name: "parameter", kind: "scalar", T: 9 }
      ]);
      var ProtoRtpHeaderExtension = class _ProtoRtpHeaderExtension extends protobuf_1.Message {
        constructor(data) {
          super();
          this.kind = "";
          this.uri = "";
          this.preferredId = 0;
          this.preferredEncrypt = false;
          this.direction = "";
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpHeaderExtension().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpHeaderExtension().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpHeaderExtension().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpHeaderExtension, a, b);
        }
      };
      exports.ProtoRtpHeaderExtension = ProtoRtpHeaderExtension;
      ProtoRtpHeaderExtension.runtime = protobuf_1.proto3;
      ProtoRtpHeaderExtension.typeName = "ProtoRtpHeaderExtension";
      ProtoRtpHeaderExtension.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "kind", kind: "scalar", T: 9 },
        { no: 2, name: "uri", kind: "scalar", T: 9 },
        { no: 3, name: "preferredId", kind: "scalar", T: 5 },
        { no: 4, name: "preferredEncrypt", kind: "scalar", T: 8 },
        { no: 5, name: "direction", kind: "scalar", T: 9 }
      ]);
      var ProtoRtpCapabilities = class _ProtoRtpCapabilities extends protobuf_1.Message {
        constructor(data) {
          super();
          this.codecs = [];
          this.headerExtensions = [];
          protobuf_1.proto3.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProtoRtpCapabilities().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProtoRtpCapabilities().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProtoRtpCapabilities().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto3.util.equals(_ProtoRtpCapabilities, a, b);
        }
      };
      exports.ProtoRtpCapabilities = ProtoRtpCapabilities;
      ProtoRtpCapabilities.runtime = protobuf_1.proto3;
      ProtoRtpCapabilities.typeName = "ProtoRtpCapabilities";
      ProtoRtpCapabilities.fields = protobuf_1.proto3.util.newFieldList(() => [
        { no: 1, name: "codecs", kind: "message", T: ProtoRtpCodecCapability, repeated: true },
        { no: 2, name: "headerExtensions", kind: "message", T: ProtoRtpHeaderExtension, repeated: true }
      ]);
    }
  });

  // ../protoc/dist/client/response_pb.js
  var require_response_pb = __commonJS({
    "../protoc/dist/client/response_pb.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Response = exports.Error = exports.WaitingRoom = exports.LobbyPeerLeft = exports.PeerLeft = exports.RoomClosedProducers_CloseProducerReason = exports.RoomClosedProducers_CloseProducerInfo = exports.RoomClosedProducers = exports.RoomMetadataUpdated = exports.PeerMetadataUpdated = exports.ReceiveData = exports.NewPeerRole = exports.NewRoomControls = exports.NewPermissions = exports.NewLobbyPeer = exports.NewPeerJoined = exports.RestartTransportIceResponse = exports.CloseConsumerSuccess = exports.CloseProducerSuccess = exports.ConsumeResponse = exports.SyncMeetingStateResponse = exports.ConsumeDataResponse = exports.ProduceDataResponse = exports.ProduceResponse = exports.ConnectTransportResponse = exports.CreateTransportOnClient = exports.ConnectRoomResponse_RTCIceServer = exports.ConnectRoomResponse = exports.LobbyPeers = exports.RoomInfo = exports.PeersInfo_ProducerInfo = exports.PeersInfo = exports.RoomControls_ProduceSources = exports.RoomControls = exports.Hello = void 0;
      var protobuf_1 = (init_esm(), __toCommonJS(esm_exports));
      var permissions_pb_js_1 = require_permissions_pb();
      var rtp_capabilities_pb_js_1 = require_rtp_capabilities_pb();
      var sdp_info_pb_js_1 = require_sdp_info_pb();
      var app_data_pb_js_1 = require_app_data_pb();
      var sctp_stream_parameters_pb_js_1 = require_sctp_stream_parameters_pb();
      var rtp_parameters_pb_js_1 = require_rtp_parameters_pb();
      var Hello = class _Hello extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Hello().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Hello().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Hello().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Hello, a, b);
        }
      };
      exports.Hello = Hello;
      Hello.runtime = protobuf_1.proto2;
      Hello.typeName = "Hello";
      Hello.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "roomId", kind: "scalar", T: 9 },
        { no: 3, name: "sessionId", kind: "scalar", T: 9 },
        { no: 4, name: "acl", kind: "message", T: permissions_pb_js_1.Permissions },
        { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var RoomControls = class _RoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControls, a, b);
        }
      };
      exports.RoomControls = RoomControls;
      RoomControls.runtime = protobuf_1.proto2;
      RoomControls.typeName = "RoomControls";
      RoomControls.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomLocked", kind: "scalar", T: 8 },
        { no: 2, name: "allowProduce", kind: "scalar", T: 8 },
        { no: 3, name: "allowProduceSources", kind: "message", T: RoomControls_ProduceSources },
        { no: 4, name: "allowConsume", kind: "scalar", T: 8 },
        { no: 5, name: "allowSendData", kind: "scalar", T: 8 }
      ]);
      var RoomControls_ProduceSources = class _RoomControls_ProduceSources extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomControls_ProduceSources().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomControls_ProduceSources().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomControls_ProduceSources().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomControls_ProduceSources, a, b);
        }
      };
      exports.RoomControls_ProduceSources = RoomControls_ProduceSources;
      RoomControls_ProduceSources.runtime = protobuf_1.proto2;
      RoomControls_ProduceSources.typeName = "RoomControls.ProduceSources";
      RoomControls_ProduceSources.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "cam", kind: "scalar", T: 8 },
        { no: 2, name: "mic", kind: "scalar", T: 8 },
        { no: 3, name: "screen", kind: "scalar", T: 8 }
      ]);
      var PeersInfo = class _PeersInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.producers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeersInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeersInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeersInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeersInfo, a, b);
        }
      };
      exports.PeersInfo = PeersInfo;
      PeersInfo.runtime = protobuf_1.proto2;
      PeersInfo.typeName = "PeersInfo";
      PeersInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 5, name: "role", kind: "scalar", T: 9, opt: true },
        { no: 4, name: "producers", kind: "message", T: PeersInfo_ProducerInfo, repeated: true }
      ]);
      var PeersInfo_ProducerInfo = class _PeersInfo_ProducerInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeersInfo_ProducerInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeersInfo_ProducerInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeersInfo_ProducerInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeersInfo_ProducerInfo, a, b);
        }
      };
      exports.PeersInfo_ProducerInfo = PeersInfo_ProducerInfo;
      PeersInfo_ProducerInfo.runtime = protobuf_1.proto2;
      PeersInfo_ProducerInfo.typeName = "PeersInfo.ProducerInfo";
      PeersInfo_ProducerInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "label", kind: "scalar", T: 9 }
      ]);
      var RoomInfo = class _RoomInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          this.peers = [];
          this.lobbyPeers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomInfo, a, b);
        }
      };
      exports.RoomInfo = RoomInfo;
      RoomInfo.runtime = protobuf_1.proto2;
      RoomInfo.typeName = "RoomInfo";
      RoomInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomLocked", kind: "scalar", T: 8 },
        { no: 2, name: "config", kind: "message", T: RoomControls },
        { no: 3, name: "peers", kind: "message", T: PeersInfo, repeated: true },
        { no: 4, name: "lobbyPeers", kind: "message", T: LobbyPeers, repeated: true },
        { no: 5, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 6, name: "startTime", kind: "scalar", T: 3 }
      ]);
      var LobbyPeers = class _LobbyPeers extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _LobbyPeers().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _LobbyPeers().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _LobbyPeers().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_LobbyPeers, a, b);
        }
      };
      exports.LobbyPeers = LobbyPeers;
      LobbyPeers.runtime = protobuf_1.proto2;
      LobbyPeers.typeName = "LobbyPeers";
      LobbyPeers.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 3, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var ConnectRoomResponse = class _ConnectRoomResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          this.turnServers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoomResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoomResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoomResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoomResponse, a, b);
        }
      };
      exports.ConnectRoomResponse = ConnectRoomResponse;
      ConnectRoomResponse.runtime = protobuf_1.proto2;
      ConnectRoomResponse.typeName = "ConnectRoomResponse";
      ConnectRoomResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomId", kind: "scalar", T: 9 },
        { no: 2, name: "roomInfo", kind: "message", T: RoomInfo },
        { no: 3, name: "routerRTPCapabilities", kind: "message", T: rtp_capabilities_pb_js_1.ProtoRtpCapabilities },
        { no: 4, name: "turnServers", kind: "message", T: ConnectRoomResponse_RTCIceServer, repeated: true }
      ]);
      var ConnectRoomResponse_RTCIceServer = class _ConnectRoomResponse_RTCIceServer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectRoomResponse_RTCIceServer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectRoomResponse_RTCIceServer, a, b);
        }
      };
      exports.ConnectRoomResponse_RTCIceServer = ConnectRoomResponse_RTCIceServer;
      ConnectRoomResponse_RTCIceServer.runtime = protobuf_1.proto2;
      ConnectRoomResponse_RTCIceServer.typeName = "ConnectRoomResponse.RTCIceServer";
      ConnectRoomResponse_RTCIceServer.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "urls", kind: "scalar", T: 9 },
        { no: 2, name: "username", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "credential", kind: "scalar", T: 9, opt: true }
      ]);
      var CreateTransportOnClient = class _CreateTransportOnClient extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CreateTransportOnClient().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CreateTransportOnClient().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CreateTransportOnClient().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CreateTransportOnClient, a, b);
        }
      };
      exports.CreateTransportOnClient = CreateTransportOnClient;
      CreateTransportOnClient.runtime = protobuf_1.proto2;
      CreateTransportOnClient.typeName = "CreateTransportOnClient";
      CreateTransportOnClient.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportSDPInfo", kind: "message", T: sdp_info_pb_js_1.ProtoTransportSDPInfo }
      ]);
      var ConnectTransportResponse = class _ConnectTransportResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConnectTransportResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConnectTransportResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConnectTransportResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConnectTransportResponse, a, b);
        }
      };
      exports.ConnectTransportResponse = ConnectTransportResponse;
      ConnectTransportResponse.runtime = protobuf_1.proto2;
      ConnectTransportResponse.typeName = "ConnectTransportResponse";
      ConnectTransportResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "transportId", kind: "scalar", T: 9 }
      ]);
      var ProduceResponse = class _ProduceResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceResponse, a, b);
        }
      };
      exports.ProduceResponse = ProduceResponse;
      ProduceResponse.runtime = protobuf_1.proto2;
      ProduceResponse.typeName = "ProduceResponse";
      ProduceResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ProduceDataResponse = class _ProduceDataResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ProduceDataResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ProduceDataResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ProduceDataResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ProduceDataResponse, a, b);
        }
      };
      exports.ProduceDataResponse = ProduceDataResponse;
      ProduceDataResponse.runtime = protobuf_1.proto2;
      ProduceDataResponse.typeName = "ProduceDataResponse";
      ProduceDataResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "dataProducerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "peerId", kind: "scalar", T: 9 },
        { no: 5, name: "protocol", kind: "scalar", T: 9 },
        { no: 6, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var ConsumeDataResponse = class _ConsumeDataResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConsumeDataResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConsumeDataResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConsumeDataResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConsumeDataResponse, a, b);
        }
      };
      exports.ConsumeDataResponse = ConsumeDataResponse;
      ConsumeDataResponse.runtime = protobuf_1.proto2;
      ConsumeDataResponse.typeName = "ConsumeDataResponse";
      ConsumeDataResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "id", kind: "scalar", T: 9 },
        { no: 2, name: "dataProducerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 },
        { no: 4, name: "peerId", kind: "scalar", T: 9 },
        { no: 5, name: "protocol", kind: "scalar", T: 9 },
        { no: 6, name: "sctpStreamParameters", kind: "message", T: sctp_stream_parameters_pb_js_1.ProtoSctpStreamParameters },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var SyncMeetingStateResponse = class _SyncMeetingStateResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _SyncMeetingStateResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _SyncMeetingStateResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _SyncMeetingStateResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_SyncMeetingStateResponse, a, b);
        }
      };
      exports.SyncMeetingStateResponse = SyncMeetingStateResponse;
      SyncMeetingStateResponse.runtime = protobuf_1.proto2;
      SyncMeetingStateResponse.typeName = "SyncMeetingStateResponse";
      SyncMeetingStateResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "roomInfo", kind: "message", T: RoomInfo }
      ]);
      var ConsumeResponse = class _ConsumeResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ConsumeResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ConsumeResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ConsumeResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ConsumeResponse, a, b);
        }
      };
      exports.ConsumeResponse = ConsumeResponse;
      ConsumeResponse.runtime = protobuf_1.proto2;
      ConsumeResponse.typeName = "ConsumeResponse";
      ConsumeResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "label", kind: "scalar", T: 9 },
        { no: 2, name: "consumerId", kind: "scalar", T: 9 },
        { no: 3, name: "producerId", kind: "scalar", T: 9 },
        { no: 4, name: "kind", kind: "scalar", T: 9 },
        { no: 5, name: "rtpParameters", kind: "message", T: rtp_parameters_pb_js_1.ProtoRtpParameters },
        { no: 6, name: "producerPeerId", kind: "scalar", T: 9 },
        { no: 7, name: "appData", kind: "message", T: app_data_pb_js_1.AppData, opt: true }
      ]);
      var CloseProducerSuccess = class _CloseProducerSuccess extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseProducerSuccess().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseProducerSuccess().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseProducerSuccess().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseProducerSuccess, a, b);
        }
      };
      exports.CloseProducerSuccess = CloseProducerSuccess;
      CloseProducerSuccess.runtime = protobuf_1.proto2;
      CloseProducerSuccess.typeName = "CloseProducerSuccess";
      CloseProducerSuccess.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 }
      ]);
      var CloseConsumerSuccess = class _CloseConsumerSuccess extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _CloseConsumerSuccess().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _CloseConsumerSuccess().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _CloseConsumerSuccess().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_CloseConsumerSuccess, a, b);
        }
      };
      exports.CloseConsumerSuccess = CloseConsumerSuccess;
      CloseConsumerSuccess.runtime = protobuf_1.proto2;
      CloseConsumerSuccess.typeName = "CloseConsumerSuccess";
      CloseConsumerSuccess.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "consumerId", kind: "scalar", T: 9 }
      ]);
      var RestartTransportIceResponse = class _RestartTransportIceResponse extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RestartTransportIceResponse().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RestartTransportIceResponse().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RestartTransportIceResponse().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RestartTransportIceResponse, a, b);
        }
      };
      exports.RestartTransportIceResponse = RestartTransportIceResponse;
      RestartTransportIceResponse.runtime = protobuf_1.proto2;
      RestartTransportIceResponse.typeName = "RestartTransportIceResponse";
      RestartTransportIceResponse.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "transportType", kind: "scalar", T: 9 },
        { no: 2, name: "iceParameters", kind: "message", T: sdp_info_pb_js_1.ProtoIceParameters }
      ]);
      var NewPeerJoined = class _NewPeerJoined extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPeerJoined().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPeerJoined().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPeerJoined().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPeerJoined, a, b);
        }
      };
      exports.NewPeerJoined = NewPeerJoined;
      NewPeerJoined.runtime = protobuf_1.proto2;
      NewPeerJoined.typeName = "NewPeerJoined";
      NewPeerJoined.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true },
        { no: 3, name: "role", kind: "scalar", T: 9, opt: true }
      ]);
      var NewLobbyPeer = class _NewLobbyPeer extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewLobbyPeer().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewLobbyPeer().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewLobbyPeer().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewLobbyPeer, a, b);
        }
      };
      exports.NewLobbyPeer = NewLobbyPeer;
      NewLobbyPeer.runtime = protobuf_1.proto2;
      NewLobbyPeer.typeName = "NewLobbyPeer";
      NewLobbyPeer.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var NewPermissions = class _NewPermissions extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPermissions().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPermissions().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPermissions().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPermissions, a, b);
        }
      };
      exports.NewPermissions = NewPermissions;
      NewPermissions.runtime = protobuf_1.proto2;
      NewPermissions.typeName = "NewPermissions";
      NewPermissions.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 2, name: "acl", kind: "message", T: permissions_pb_js_1.Permissions }
      ]);
      var NewRoomControls = class _NewRoomControls extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewRoomControls().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewRoomControls().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewRoomControls().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewRoomControls, a, b);
        }
      };
      exports.NewRoomControls = NewRoomControls;
      NewRoomControls.runtime = protobuf_1.proto2;
      NewRoomControls.typeName = "NewRoomControls";
      NewRoomControls.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "controls", kind: "message", T: RoomControls }
      ]);
      var NewPeerRole = class _NewPeerRole extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _NewPeerRole().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _NewPeerRole().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _NewPeerRole().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_NewPeerRole, a, b);
        }
      };
      exports.NewPeerRole = NewPeerRole;
      NewPeerRole.runtime = protobuf_1.proto2;
      NewPeerRole.typeName = "NewPeerRole";
      NewPeerRole.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "role", kind: "scalar", T: 9 }
      ]);
      var ReceiveData = class _ReceiveData extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _ReceiveData().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _ReceiveData().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _ReceiveData().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_ReceiveData, a, b);
        }
      };
      exports.ReceiveData = ReceiveData;
      ReceiveData.runtime = protobuf_1.proto2;
      ReceiveData.typeName = "ReceiveData";
      ReceiveData.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "from", kind: "scalar", T: 9 },
        { no: 2, name: "payload", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9, opt: true }
      ]);
      var PeerMetadataUpdated = class _PeerMetadataUpdated extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeerMetadataUpdated().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeerMetadataUpdated().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeerMetadataUpdated().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeerMetadataUpdated, a, b);
        }
      };
      exports.PeerMetadataUpdated = PeerMetadataUpdated;
      PeerMetadataUpdated.runtime = protobuf_1.proto2;
      PeerMetadataUpdated.typeName = "PeerMetadataUpdated";
      PeerMetadataUpdated.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var RoomMetadataUpdated = class _RoomMetadataUpdated extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomMetadataUpdated().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomMetadataUpdated().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomMetadataUpdated().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomMetadataUpdated, a, b);
        }
      };
      exports.RoomMetadataUpdated = RoomMetadataUpdated;
      RoomMetadataUpdated.runtime = protobuf_1.proto2;
      RoomMetadataUpdated.typeName = "RoomMetadataUpdated";
      RoomMetadataUpdated.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "metadata", kind: "scalar", T: 9 }
      ]);
      var RoomClosedProducers = class _RoomClosedProducers extends protobuf_1.Message {
        constructor(data) {
          super();
          this.producers = [];
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers, a, b);
        }
      };
      exports.RoomClosedProducers = RoomClosedProducers;
      RoomClosedProducers.runtime = protobuf_1.proto2;
      RoomClosedProducers.typeName = "RoomClosedProducers";
      RoomClosedProducers.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "producers", kind: "message", T: RoomClosedProducers_CloseProducerInfo, repeated: true },
        { no: 2, name: "reason", kind: "message", T: RoomClosedProducers_CloseProducerReason }
      ]);
      var RoomClosedProducers_CloseProducerInfo = class _RoomClosedProducers_CloseProducerInfo extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers_CloseProducerInfo().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers_CloseProducerInfo, a, b);
        }
      };
      exports.RoomClosedProducers_CloseProducerInfo = RoomClosedProducers_CloseProducerInfo;
      RoomClosedProducers_CloseProducerInfo.runtime = protobuf_1.proto2;
      RoomClosedProducers_CloseProducerInfo.typeName = "RoomClosedProducers.CloseProducerInfo";
      RoomClosedProducers_CloseProducerInfo.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "producerId", kind: "scalar", T: 9 },
        { no: 3, name: "label", kind: "scalar", T: 9 }
      ]);
      var RoomClosedProducers_CloseProducerReason = class _RoomClosedProducers_CloseProducerReason extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _RoomClosedProducers_CloseProducerReason().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_RoomClosedProducers_CloseProducerReason, a, b);
        }
      };
      exports.RoomClosedProducers_CloseProducerReason = RoomClosedProducers_CloseProducerReason;
      RoomClosedProducers_CloseProducerReason.runtime = protobuf_1.proto2;
      RoomClosedProducers_CloseProducerReason.typeName = "RoomClosedProducers.CloseProducerReason";
      RoomClosedProducers_CloseProducerReason.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "code", kind: "scalar", T: 5 },
        { no: 2, name: "tag", kind: "scalar", T: 9 },
        { no: 3, name: "message", kind: "scalar", T: 9 }
      ]);
      var PeerLeft = class _PeerLeft extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _PeerLeft().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _PeerLeft().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _PeerLeft().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_PeerLeft, a, b);
        }
      };
      exports.PeerLeft = PeerLeft;
      PeerLeft.runtime = protobuf_1.proto2;
      PeerLeft.typeName = "PeerLeft";
      PeerLeft.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 }
      ]);
      var LobbyPeerLeft = class _LobbyPeerLeft extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _LobbyPeerLeft().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _LobbyPeerLeft().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _LobbyPeerLeft().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_LobbyPeerLeft, a, b);
        }
      };
      exports.LobbyPeerLeft = LobbyPeerLeft;
      LobbyPeerLeft.runtime = protobuf_1.proto2;
      LobbyPeerLeft.typeName = "LobbyPeerLeft";
      LobbyPeerLeft.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "peerId", kind: "scalar", T: 9 },
        { no: 2, name: "status", kind: "scalar", T: 9 },
        { no: 3, name: "message", kind: "scalar", T: 9, opt: true }
      ]);
      var WaitingRoom = class _WaitingRoom extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _WaitingRoom().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _WaitingRoom().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _WaitingRoom().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_WaitingRoom, a, b);
        }
      };
      exports.WaitingRoom = WaitingRoom;
      WaitingRoom.runtime = protobuf_1.proto2;
      WaitingRoom.typeName = "WaitingRoom";
      WaitingRoom.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "reason", kind: "scalar", T: 9 },
        { no: 2, name: "metadata", kind: "scalar", T: 9, opt: true }
      ]);
      var Error2 = class _Error extends protobuf_1.Message {
        constructor(data) {
          super();
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Error().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Error().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Error().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Error, a, b);
        }
      };
      exports.Error = Error2;
      Error2.runtime = protobuf_1.proto2;
      Error2.typeName = "Error";
      Error2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "event", kind: "scalar", T: 9 },
        { no: 2, name: "error", kind: "scalar", T: 9 }
      ]);
      var Response2 = class _Response extends protobuf_1.Message {
        constructor(data) {
          super();
          this.Response = { case: void 0 };
          protobuf_1.proto2.util.initPartial(data, this);
        }
        static fromBinary(bytes, options) {
          return new _Response().fromBinary(bytes, options);
        }
        static fromJson(jsonValue, options) {
          return new _Response().fromJson(jsonValue, options);
        }
        static fromJsonString(jsonString, options) {
          return new _Response().fromJsonString(jsonString, options);
        }
        static equals(a, b) {
          return protobuf_1.proto2.util.equals(_Response, a, b);
        }
      };
      exports.Response = Response2;
      Response2.runtime = protobuf_1.proto2;
      Response2.typeName = "Response";
      Response2.fields = protobuf_1.proto2.util.newFieldList(() => [
        { no: 1, name: "hello", kind: "message", T: Hello, oneof: "Response" },
        { no: 2, name: "connectRoomResponse", kind: "message", T: ConnectRoomResponse, oneof: "Response" },
        { no: 3, name: "createTransportOnClient", kind: "message", T: CreateTransportOnClient, oneof: "Response" },
        { no: 4, name: "produceResponse", kind: "message", T: ProduceResponse, oneof: "Response" },
        { no: 25, name: "consumeDataResponse", kind: "message", T: ConsumeDataResponse, oneof: "Response" },
        { no: 5, name: "produceDataResponse", kind: "message", T: ProduceDataResponse, oneof: "Response" },
        { no: 6, name: "syncMeetingStateResponse", kind: "message", T: SyncMeetingStateResponse, oneof: "Response" },
        { no: 7, name: "consumeResponse", kind: "message", T: ConsumeResponse, oneof: "Response" },
        { no: 8, name: "closeProducerSuccess", kind: "message", T: CloseProducerSuccess, oneof: "Response" },
        { no: 9, name: "closeConsumerSuccess", kind: "message", T: CloseConsumerSuccess, oneof: "Response" },
        { no: 10, name: "connectTransportResponse", kind: "message", T: ConnectTransportResponse, oneof: "Response" },
        { no: 11, name: "restartTransportIceResponse", kind: "message", T: RestartTransportIceResponse, oneof: "Response" },
        { no: 12, name: "newPeerJoined", kind: "message", T: NewPeerJoined, oneof: "Response" },
        { no: 13, name: "newLobbyPeer", kind: "message", T: NewLobbyPeer, oneof: "Response" },
        { no: 14, name: "newPermissions", kind: "message", T: NewPermissions, oneof: "Response" },
        { no: 15, name: "newRoomControls", kind: "message", T: NewRoomControls, oneof: "Response" },
        { no: 16, name: "newPeerRole", kind: "message", T: NewPeerRole, oneof: "Response" },
        { no: 17, name: "receiveData", kind: "message", T: ReceiveData, oneof: "Response" },
        { no: 18, name: "peerMetadataUpdated", kind: "message", T: PeerMetadataUpdated, oneof: "Response" },
        { no: 19, name: "roomMetadataUpdated", kind: "message", T: RoomMetadataUpdated, oneof: "Response" },
        { no: 20, name: "roomClosedProducers", kind: "message", T: RoomClosedProducers, oneof: "Response" },
        { no: 21, name: "peerLeft", kind: "message", T: PeerLeft, oneof: "Response" },
        { no: 22, name: "lobbyPeerLeft", kind: "message", T: LobbyPeerLeft, oneof: "Response" },
        { no: 23, name: "waitingRoom", kind: "message", T: WaitingRoom, oneof: "Response" },
        { no: 24, name: "error", kind: "message", T: Error2, oneof: "Response" }
      ]);
    }
  });

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    Consumer: () => Consumer_default,
    DeviceHandler: () => DeviceHandler_default,
    HuddleClient: () => HuddleClient_default,
    LocalPeer: () => LocalPeer_default,
    Permissions: () => Permissions_default,
    RemotePeer: () => RemotePeer_default,
    Room: () => Room_default,
    Socket: () => Socket_default,
    Transport: () => Transport_default
  });

  // src/LocalPeer.ts
  var import_mediasoup_client = __toESM(require_lib4(), 1);

  // src/common-js/EnhancedEventEmitter.ts
  var import_events = __toESM(require_events(), 1);
  var EnhancedEventEmitter = class {
    emitter;
    constructor() {
      this.emitter = new import_events.EventEmitter();
      this.emitter.setMaxListeners(Infinity);
    }
    on(eventName, listener) {
      this.emitter.on(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: need to override the type because default it's any[ and we cannot assign E[K] to any[]
        listener
      );
      return this;
    }
    off(eventName, listener) {
      this.emitter.off(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    listenerCount(eventName) {
      return this.emitter.listenerCount(eventName);
    }
    listeners(eventName) {
      return this.emitter.listeners(eventName);
    }
    emit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    safeEmit(eventName, ...args) {
      return this.emitter.emit(eventName, ...args);
    }
    once(eventName, listener) {
      this.emitter.once(
        eventName,
        // biome-ignore lint/suspicious/noExplicitAny: <explanation>
        listener
      );
      return this;
    }
    removeAllListeners(eventName) {
      if (eventName) {
        this.emitter.removeAllListeners(eventName);
      } else {
        this.emitter.removeAllListeners();
      }
      return this;
    }
  };

  // src/constants/rtpConstants.ts
  var VIDEO_CONSTRAINTS = {
    qvga: { width: { ideal: 320 }, height: { ideal: 240 } },
    vga: { width: { ideal: 640 }, height: { ideal: 480 } },
    hd: { width: { ideal: 1280 }, height: { ideal: 720 } },
    fHd: { width: { ideal: 1920 }, height: { ideal: 1080 } },
    qHd: { width: { ideal: 4096 }, height: { ideal: 2160 } }
  };
  var WEBCAM_SIMULCAST_ENCODINGS = [
    {
      scaleResolutionDownBy: 4,
      maxBitrate: 3e5,
      // 300kbps
      rid: "r0",
      scalabilityMode: "S1T3",
      maxFramerate: 15
    },
    {
      scaleResolutionDownBy: 2,
      maxBitrate: 6e5,
      // 600kbps
      rid: "r1",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    },
    {
      scaleResolutionDownBy: 1,
      maxBitrate: 9e6,
      // 900kbps
      rid: "r2",
      scalabilityMode: "S1T3",
      maxFramerate: 30
    }
  ];
  var encodingViaMediaType = {
    video: WEBCAM_SIMULCAST_ENCODINGS,
    "screen-share-video": void 0,
    audio: [{ maxBitrate: 128e3 }]
  };
  var codecOptionsViaKind = {
    audio: { opusStereo: true, opusFec: true, opusDtx: true },
    video: { videoGoogleStartBitrate: 1e3 }
  };

  // src/constants/deviceConstraints.ts
  var videoDefaultConstraints = {
    video: {
      ...VIDEO_CONSTRAINTS.hd
    }
  };
  var audioConstraints = {
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var shareConstraints = {
    video: {
      displaySurface: "monitor",
      logicalSurface: true,
      cursor: true,
      width: { ideal: 1920, max: 1920 },
      height: { ideal: 1080, max: 1080 },
      frameRate: { ideal: 25, max: 30 }
    },
    audio: {
      echoCancellation: true,
      noiseSuppression: true
    }
  };
  var defaultMediaConstraints = {
    cam: videoDefaultConstraints,
    mic: audioConstraints,
    screen: shareConstraints
  };
  var deviceConstraints_default = defaultMediaConstraints;

  // src/logger.ts
  var COLORS = {
    black: "\x1B[30m",
    red: "\x1B[31m",
    green: "\x1B[32m",
    yellow: "\x1B[33m",
    blue: "\x1B[34m",
    magenta: "\x1B[35m",
    cyan: "\x1B[36m",
    white: "\x1B[37m",
    default: "\x1B[39m"
  };
  var defaultLevel = "error";
  var created = Date.now();
  function createDefaultLoggerFactory() {
    return () => {
      const trace = (...args) => {
        console.trace(...args);
      };
      const debug = (...args) => {
        console.debug(...args);
      };
      const info = (...args) => {
        console.info(...args);
      };
      const warn = (...args) => {
        console.warn(...args);
      };
      const error = (...args) => {
        console.error(...args);
      };
      return {
        trace,
        debug,
        info,
        warn,
        error
      };
    };
  }
  var wrapLogger = (logger12, moduleName, logLevel) => {
    let isTrace = false;
    let isDebug = false;
    let isInfo = false;
    let isWarning = false;
    let isError = false;
    let _level = logLevel;
    let _logger = logger12;
    const tracePrefix = `${COLORS.magenta}[TRACE]${COLORS.default} ${moduleName}`;
    const debugPrefix = `${COLORS.cyan}[DEBUG]${COLORS.default} ${moduleName}`;
    const infoPrefix = `${COLORS.green}[INFO]${COLORS.default} ${moduleName}`;
    const warnPrefix = `${COLORS.yellow}[WARN]${COLORS.default} ${moduleName}`;
    const errorPrefix = `${COLORS.red}[ERROR]${COLORS.default} ${moduleName}`;
    const result = new class {
      init() {
        isTrace = ["trace"].includes(_level ?? defaultLevel);
        isDebug = ["trace", "debug"].includes(_level ?? defaultLevel);
        isInfo = ["trace", "debug", "info"].includes(_level ?? defaultLevel);
        isWarning = ["trace", "debug", "info", "warn"].includes(
          _level ?? defaultLevel
        );
        isError = ["trace", "debug", "info", "warn", "error"].includes(
          _level ?? defaultLevel
        );
      }
      get logger() {
        return _logger;
      }
      set logger(value) {
        _logger = value;
      }
      get level() {
        return _level;
      }
      set level(value) {
        _level = value;
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      trace(...args) {
        if (isTrace) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.trace(tracePrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      debug(...args) {
        if (isDebug) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.debug(debugPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      info(...args) {
        if (isInfo) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.info(infoPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      warn(...args) {
        if (isWarning) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.warn(warnPrefix, ...args, elapsedInMs);
        }
      }
      // biome-ignore lint/suspicious/noExplicitAny: need any
      error(...args) {
        if (isError) {
          const elapsedInMs = `${COLORS.magenta}+${Date.now() - created}ms${COLORS.default}`;
          logger12.error(errorPrefix, ...args, elapsedInMs);
        }
      }
    }();
    return result;
  };
  var actualLoggerFactory = createDefaultLoggerFactory();
  var loggers = /* @__PURE__ */ new Map();
  var createLogger = (moduleName, logLevel) => {
    let wrappedLogger = loggers.get(moduleName);
    if (!wrappedLogger) {
      const logger12 = actualLoggerFactory();
      wrappedLogger = wrapLogger(logger12, moduleName, logLevel ?? defaultLevel);
      loggers.set(moduleName, wrappedLogger);
    } else {
      wrappedLogger.level = logLevel ?? defaultLevel;
    }
    wrappedLogger.init();
    return wrappedLogger;
  };
  var setLogLevel = (level) => {
    defaultLevel = level;
    for (const [moduleName] of Array.from(loggers.entries())) {
      loggers.set(moduleName, createLogger(moduleName, level));
    }
  };
  var mainLogger = {
    createSubLogger: (moduleName) => createLogger(`HuddleWebCore:${moduleName}`)
  };

  // src/DeviceHandler.ts
  var logger = mainLogger.createSubLogger("DeviceHandler");
  var CustomMediaKindToSystemKind = {
    cam: "videoinput",
    mic: "audioinput",
    speaker: "audiooutput"
  };
  var DeviceHandler = class extends EnhancedEventEmitter {
    SCREEN_DEFAULT_DEVICE = "monitor";
    /**
     * User Selected Devices, If no device is selected, it will use the default device of the system
     *
     * is preffered device is null, it will use the default device of the system
     *
     * `NOTE: User has the ability to select a preferred device for each media kind`
     */
    __preferredDevices = /* @__PURE__ */ new Map([
      ["cam", null],
      ["mic", null],
      ["speaker", null]
    ]);
    /**
     * Map the media devices currently present in the system
     */
    __mediaDevicesInfo = /* @__PURE__ */ new Map([
      ["cam", []],
      ["mic", []],
      ["speaker", []]
    ]);
    /**
     * Get all the devices which are currently available in the system
     */
    get devices() {
      return this.__mediaDevicesInfo;
    }
    get preferredDevices() {
      return this.__preferredDevices;
    }
    /**
     * Get all the devices which are currently available in the system, also updates the `__mediaDevicesInfo` record
     *
     * Can also query for a specific device kind `audioinput` | `videoinput` | `audiooutput`
     *
     * @param deviceKind `cam` | `mic` | `speaker` | `undefined`
     * @returns - MediaDeviceInfo[] | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getMediaDevices = async (filterByDeviceKind, shouldFetchStream = false) => {
      logger.info("\u{1F4F9} Fetching Media Devices");
      let constraints;
      if (filterByDeviceKind === "speaker" || filterByDeviceKind === "device-change") {
        constraints = deviceConstraints_default.mic;
      } else if (filterByDeviceKind) {
        constraints = deviceConstraints_default[filterByDeviceKind];
      } else {
        constraints = {
          ...deviceConstraints_default.mic,
          ...deviceConstraints_default.cam
        };
      }
      let devices = [];
      if (shouldFetchStream) {
        const stream = await navigator.mediaDevices.getUserMedia(constraints).catch((err) => {
          logger.error("fetching stream failed", err);
        });
        devices = await navigator.mediaDevices.enumerateDevices();
        if (stream) {
          const tracks = stream.getTracks();
          for (const track of tracks) {
            track.stop();
          }
        }
      } else {
        devices = await navigator.mediaDevices.enumerateDevices();
      }
      if (!filterByDeviceKind || filterByDeviceKind === "device-change") {
        this.__setMediaDeviceInfo({ devices, update: "all" });
      }
      if (filterByDeviceKind === "cam" || filterByDeviceKind === "mic") {
        this.__setMediaDeviceInfo({ devices, update: filterByDeviceKind });
      }
      const mediaDevices = devices.filter((device) => {
        if (device.deviceId === "" || device.label === "") {
          return false;
        }
        if (filterByDeviceKind && filterByDeviceKind !== "device-change") {
          const systemDeviceKind = CustomMediaKindToSystemKind[filterByDeviceKind];
          return device.kind === systemDeviceKind;
        }
        return true;
      });
      return mediaDevices;
    };
    /**
     * Get the device from the given facing type of device
     *
     * This function is used for only RN
     *
     * @param facing - facing of the device { 'environment' | 'front' | 'undefined' }
     * @param mediaDeviceKind - mediaDeviceKind for the device { 'audioinput' | 'videoinput' }
     * @returns - deviceId: string | null
     *
     * `NOTE`: Ask for MediaDevice Permission to get the right result for that device else it will return `null`
     */
    getDeviceFromFacingMode = (facing, mediaDeviceKind) => {
      const allDevices = this.__mediaDevicesInfo.get(mediaDeviceKind);
      if (allDevices) {
        const d = allDevices.find((device) => device.facing === facing);
        if (d) {
          if (mediaDeviceKind === "cam") {
            return facing || d.deviceId;
          }
          return d.deviceId;
        }
      }
      return null;
    };
    setPreferredDevice = (data) => {
      const { deviceId, deviceKind } = data;
      this.__preferredDevices.set(deviceKind, deviceId);
      this.emit("preferred-device-change", {
        deviceId,
        deviceKind
      });
    };
    /**
     * Fetches a stream of the screen of the device i.e the screen sharing stream
     * based on the selected choice from the pop up returns the audio and video stream
     * in one stream.
     *
     * `NOTE: This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK`
     * @returns
     */
    fetchScreen = async () => {
      const constraints = deviceConstraints_default.screen;
      try {
        const stream = await navigator.mediaDevices.getDisplayMedia(constraints);
        return { stream };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        return {
          stream: null,
          error
        };
      }
    };
    /**
     * Fetch the stream from the device for the given media kind, if no preferred device is found it will throw an error.
     * by default the preferred device is the system default device
     *
     * `NOTE: If Preffered device is not found, it will use the system default device, if no default device is found it will throw an error`
     * `Set the preferred device using setPreferredDevice()`
     *
     */
    fetchStream = async (data) => {
      const preferredDeviceId = this.__preferredDevices.get(data.mediaDeviceKind);
      logger.info("\u{1F4F9} Fetching Stream", {
        mediaDeviceKind: data.mediaDeviceKind,
        preferredDeviceId
      });
      navigator.mediaDevices.ondevicechange = async () => {
        const newMediaDevices = await this.getMediaDevices("device-change");
        for (const [deviceKind, deviceId] of this.__preferredDevices) {
          const device = newMediaDevices.find((d) => d.deviceId === deviceId);
          if (!device) {
            this.setPreferredDevice({ deviceId: null, deviceKind });
          }
        }
        this.emit("device-change");
      };
      try {
        let fetchStreamFunc;
        if (typeof navigator === "object" && navigator.product === "ReactNative") {
          fetchStreamFunc = this.__fetchStreamFromDeviceForRN;
        } else {
          fetchStreamFunc = this.__fetchStreamFromDeviceForWeb;
        }
        const { stream, deviceId } = await fetchStreamFunc({
          deviceId: preferredDeviceId ?? void 0,
          mediaKind: data.mediaDeviceKind === "mic" ? "mic" : "cam"
        });
        const track = data.mediaDeviceKind === "mic" ? stream.getAudioTracks()[0] : stream.getVideoTracks()[0];
        if (!this.__preferredDevices.get(data.mediaDeviceKind)) {
          this.setPreferredDevice({ deviceId, deviceKind: data.mediaDeviceKind });
        }
        return {
          stream,
          track,
          deviceId
        };
      } catch (err) {
        logger.error(err);
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        return {
          stream: null,
          track: null,
          deviceId: null,
          error
        };
      }
    };
    fetchStreamByGroupId = async (data) => {
      let constraints;
      if (data.mediaDeviceKind === "mic") {
        constraints = { audio: { groupId: data.groupId } };
      } else {
        constraints = { video: { groupId: data.groupId } };
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      return stream;
    };
    /**
     * Fetch the stream from the device for the React Native Based Application
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: "front" | "back" | "audio" | string; kind: "audioinput" | "videoinput" }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForRN = async (data) => {
      const constraints = deviceConstraints_default[data.mediaKind];
      let facingMode;
      if (data.mediaKind === "cam") {
        facingMode = data.deviceId === "environment" ? "environment" : "front";
        constraints.video = Object.assign({}, constraints.video, {
          facingMode
        });
      }
      if (data.mediaKind === "mic") {
        constraints.audio = Object.assign({}, constraints.audio, {
          deviceId: data.deviceId
        });
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = this.getDeviceFromFacingMode(
        facingMode,
        data.mediaKind === "mic" ? "mic" : "cam"
      );
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the SDK, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: streamDeviceId
      };
    };
    /**
     * Fetch the stream from the device for the web
     *
     * `This stream is not managed by the Huddle01 SDK, i.e. it will not be closed by the SDK
     * the user has to close it manually by calling {stream.getTracks().forEach(track => track.stop())}`
     *
     * NOTE: `using stopTrackOnClose = true` while producing will stop the track when producing is stopped
     *
     * @param data - { deviceId: string; kind: 'audio' | 'video' }
     * @returns - { stream: MediaStream, deviceId: string }
     */
    __fetchStreamFromDeviceForWeb = async (data) => {
      const constraints = Object.assign(
        {},
        deviceConstraints_default[data.mediaKind]
      );
      if (data.mediaKind === "cam" && data.deviceId) {
        constraints.video = Object.assign({}, constraints.video, {
          deviceId: data.deviceId
        });
      }
      if (data.mediaKind === "mic" && data.deviceId) {
        constraints.audio = Object.assign({}, constraints.audio, {
          deviceId: {
            exact: data.deviceId
          }
        });
      }
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      const streamDeviceId = stream.getTracks()[0].getSettings().deviceId;
      const devices = await navigator.mediaDevices.enumerateDevices();
      if (data.mediaKind === "cam" || data.mediaKind === "mic") {
        this.emit("permission-granted", { deviceKind: data.mediaKind });
        this.__setMediaDeviceInfo({ devices, update: data.mediaKind });
      }
      if (!streamDeviceId) {
        const tracks = stream.getTracks();
        for (const track of tracks) {
          track.stop();
        }
        throw new Error(
          "\u274C No DeviceId found for this stream, this is a bug in the browser, please report it to the developers"
        );
      }
      return {
        stream,
        deviceId: streamDeviceId
      };
    };
    /**
     * @description Get the media permission for the given type
     * @param data  { type: 'video' | 'audio' }
     * @throws error { StreamPermissionsError }
     * @example await getMediaPermission({ type: 'video' })
     */
    getMediaPermission = async (data) => {
      const { mediaDeviceKind } = data;
      try {
        await this.getMediaDevices(mediaDeviceKind);
        this.emit("permission-granted", { deviceKind: mediaDeviceKind });
        return {
          permission: "granted"
        };
      } catch (err) {
        let error = {
          message: "Unknown Error",
          errorStack: err
        };
        if (err instanceof DOMException) {
          error = {
            blocked: {
              byDeviceMissing: err.name === "NotFoundError",
              byDeviceInUse: err.name === "OverconstrainedError",
              byPermissions: err.name === "NotAllowedError"
            },
            message: err.message
          };
        }
        this.emit("permission-denied", { deviceKind: mediaDeviceKind, error });
        return {
          permission: "denied",
          error
        };
      }
    };
    stopStream = (stream) => {
      if (!stream)
        return;
      for (const track of stream.getTracks()) {
        track.stop();
      }
    };
    destroy = () => {
      this.__preferredDevices.clear();
      this.__mediaDevicesInfo.clear();
      logger.info("\u2705 Destroyed StreamHandler");
    };
    /**
     * Set the Media devices info based on the latest devices available in the system
     */
    __setMediaDeviceInfo = (data) => {
      const { devices, update } = data;
      const camDevices = [];
      const micDevices = [];
      const speakerDevices = [];
      for (const device of devices) {
        if (device.label === "" || device.deviceId === "")
          continue;
        if (device.kind === "videoinput")
          camDevices.push(device);
        if (device.kind === "audioinput")
          micDevices.push(device);
        if (device.kind === "audiooutput")
          speakerDevices.push(device);
      }
      if (update === "all") {
        this.__mediaDevicesInfo.set("cam", camDevices);
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
      if (update === "cam")
        this.__mediaDevicesInfo.set("cam", camDevices);
      if (update === "mic") {
        this.__mediaDevicesInfo.set("mic", micDevices);
        this.__mediaDevicesInfo.set("speaker", speakerDevices);
      }
    };
  };
  var DeviceHandler_default = DeviceHandler;

  // src/Socket.ts
  var import_socket = __toESM(require_socket_types(), 1);

  // ../../node_modules/zod/lib/index.mjs
  var util;
  (function(util2) {
    util2.assertEqual = (val) => val;
    function assertIs(_arg) {
    }
    util2.assertIs = assertIs;
    function assertNever(_x) {
      throw new Error();
    }
    util2.assertNever = assertNever;
    util2.arrayToEnum = (items) => {
      const obj = {};
      for (const item of items) {
        obj[item] = item;
      }
      return obj;
    };
    util2.getValidEnumValues = (obj) => {
      const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
      const filtered = {};
      for (const k of validKeys) {
        filtered[k] = obj[k];
      }
      return util2.objectValues(filtered);
    };
    util2.objectValues = (obj) => {
      return util2.objectKeys(obj).map(function(e) {
        return obj[e];
      });
    };
    util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
      const keys = [];
      for (const key in object) {
        if (Object.prototype.hasOwnProperty.call(object, key)) {
          keys.push(key);
        }
      }
      return keys;
    };
    util2.find = (arr, checker) => {
      for (const item of arr) {
        if (checker(item))
          return item;
      }
      return void 0;
    };
    util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
      return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
    }
    util2.joinValues = joinValues;
    util2.jsonStringifyReplacer = (_, value) => {
      if (typeof value === "bigint") {
        return value.toString();
      }
      return value;
    };
  })(util || (util = {}));
  var objectUtil;
  (function(objectUtil2) {
    objectUtil2.mergeShapes = (first, second) => {
      return {
        ...first,
        ...second
        // second overwrites first
      };
    };
  })(objectUtil || (objectUtil = {}));
  var ZodParsedType = util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set"
  ]);
  var getParsedType = (data) => {
    const t = typeof data;
    switch (t) {
      case "undefined":
        return ZodParsedType.undefined;
      case "string":
        return ZodParsedType.string;
      case "number":
        return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
      case "boolean":
        return ZodParsedType.boolean;
      case "function":
        return ZodParsedType.function;
      case "bigint":
        return ZodParsedType.bigint;
      case "symbol":
        return ZodParsedType.symbol;
      case "object":
        if (Array.isArray(data)) {
          return ZodParsedType.array;
        }
        if (data === null) {
          return ZodParsedType.null;
        }
        if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
          return ZodParsedType.promise;
        }
        if (typeof Map !== "undefined" && data instanceof Map) {
          return ZodParsedType.map;
        }
        if (typeof Set !== "undefined" && data instanceof Set) {
          return ZodParsedType.set;
        }
        if (typeof Date !== "undefined" && data instanceof Date) {
          return ZodParsedType.date;
        }
        return ZodParsedType.object;
      default:
        return ZodParsedType.unknown;
    }
  };
  var ZodIssueCode = util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite"
  ]);
  var quotelessJson = (obj) => {
    const json = JSON.stringify(obj, null, 2);
    return json.replace(/"([^"]+)":/g, "$1:");
  };
  var ZodError = class extends Error {
    constructor(issues) {
      super();
      this.issues = [];
      this.addIssue = (sub) => {
        this.issues = [...this.issues, sub];
      };
      this.addIssues = (subs = []) => {
        this.issues = [...this.issues, ...subs];
      };
      const actualProto = new.target.prototype;
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(this, actualProto);
      } else {
        this.__proto__ = actualProto;
      }
      this.name = "ZodError";
      this.issues = issues;
    }
    get errors() {
      return this.issues;
    }
    format(_mapper) {
      const mapper = _mapper || function(issue) {
        return issue.message;
      };
      const fieldErrors = { _errors: [] };
      const processError = (error) => {
        for (const issue of error.issues) {
          if (issue.code === "invalid_union") {
            issue.unionErrors.map(processError);
          } else if (issue.code === "invalid_return_type") {
            processError(issue.returnTypeError);
          } else if (issue.code === "invalid_arguments") {
            processError(issue.argumentsError);
          } else if (issue.path.length === 0) {
            fieldErrors._errors.push(mapper(issue));
          } else {
            let curr = fieldErrors;
            let i = 0;
            while (i < issue.path.length) {
              const el = issue.path[i];
              const terminal = i === issue.path.length - 1;
              if (!terminal) {
                curr[el] = curr[el] || { _errors: [] };
              } else {
                curr[el] = curr[el] || { _errors: [] };
                curr[el]._errors.push(mapper(issue));
              }
              curr = curr[el];
              i++;
            }
          }
        }
      };
      processError(this);
      return fieldErrors;
    }
    toString() {
      return this.message;
    }
    get message() {
      return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
      return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
      const fieldErrors = {};
      const formErrors = [];
      for (const sub of this.issues) {
        if (sub.path.length > 0) {
          fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
          fieldErrors[sub.path[0]].push(mapper(sub));
        } else {
          formErrors.push(mapper(sub));
        }
      }
      return { formErrors, fieldErrors };
    }
    get formErrors() {
      return this.flatten();
    }
  };
  ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
  };
  var errorMap = (issue, _ctx) => {
    let message;
    switch (issue.code) {
      case ZodIssueCode.invalid_type:
        if (issue.received === ZodParsedType.undefined) {
          message = "Required";
        } else {
          message = `Expected ${issue.expected}, received ${issue.received}`;
        }
        break;
      case ZodIssueCode.invalid_literal:
        message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
        break;
      case ZodIssueCode.unrecognized_keys:
        message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
        break;
      case ZodIssueCode.invalid_union:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_union_discriminator:
        message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
        break;
      case ZodIssueCode.invalid_enum_value:
        message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
        break;
      case ZodIssueCode.invalid_arguments:
        message = `Invalid function arguments`;
        break;
      case ZodIssueCode.invalid_return_type:
        message = `Invalid function return type`;
        break;
      case ZodIssueCode.invalid_date:
        message = `Invalid date`;
        break;
      case ZodIssueCode.invalid_string:
        if (typeof issue.validation === "object") {
          if ("includes" in issue.validation) {
            message = `Invalid input: must include "${issue.validation.includes}"`;
            if (typeof issue.validation.position === "number") {
              message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
            }
          } else if ("startsWith" in issue.validation) {
            message = `Invalid input: must start with "${issue.validation.startsWith}"`;
          } else if ("endsWith" in issue.validation) {
            message = `Invalid input: must end with "${issue.validation.endsWith}"`;
          } else {
            util.assertNever(issue.validation);
          }
        } else if (issue.validation !== "regex") {
          message = `Invalid ${issue.validation}`;
        } else {
          message = "Invalid";
        }
        break;
      case ZodIssueCode.too_small:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.too_big:
        if (issue.type === "array")
          message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
        else if (issue.type === "string")
          message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
        else if (issue.type === "number")
          message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "bigint")
          message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
        else if (issue.type === "date")
          message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
        else
          message = "Invalid input";
        break;
      case ZodIssueCode.custom:
        message = `Invalid input`;
        break;
      case ZodIssueCode.invalid_intersection_types:
        message = `Intersection results could not be merged`;
        break;
      case ZodIssueCode.not_multiple_of:
        message = `Number must be a multiple of ${issue.multipleOf}`;
        break;
      case ZodIssueCode.not_finite:
        message = "Number must be finite";
        break;
      default:
        message = _ctx.defaultError;
        util.assertNever(issue);
    }
    return { message };
  };
  var overrideErrorMap = errorMap;
  function setErrorMap(map) {
    overrideErrorMap = map;
  }
  function getErrorMap() {
    return overrideErrorMap;
  }
  var makeIssue = (params) => {
    const { data, path, errorMaps, issueData } = params;
    const fullPath = [...path, ...issueData.path || []];
    const fullIssue = {
      ...issueData,
      path: fullPath
    };
    let errorMessage = "";
    const maps = errorMaps.filter((m) => !!m).slice().reverse();
    for (const map of maps) {
      errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
    }
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message || errorMessage
    };
  };
  var EMPTY_PATH = [];
  function addIssueToContext(ctx, issueData) {
    const issue = makeIssue({
      issueData,
      data: ctx.data,
      path: ctx.path,
      errorMaps: [
        ctx.common.contextualErrorMap,
        ctx.schemaErrorMap,
        getErrorMap(),
        errorMap
        // then global default map
      ].filter((x) => !!x)
    });
    ctx.common.issues.push(issue);
  }
  var ParseStatus = class _ParseStatus {
    constructor() {
      this.value = "valid";
    }
    dirty() {
      if (this.value === "valid")
        this.value = "dirty";
    }
    abort() {
      if (this.value !== "aborted")
        this.value = "aborted";
    }
    static mergeArray(status, results) {
      const arrayValue = [];
      for (const s of results) {
        if (s.status === "aborted")
          return INVALID;
        if (s.status === "dirty")
          status.dirty();
        arrayValue.push(s.value);
      }
      return { status: status.value, value: arrayValue };
    }
    static async mergeObjectAsync(status, pairs) {
      const syncPairs = [];
      for (const pair of pairs) {
        syncPairs.push({
          key: await pair.key,
          value: await pair.value
        });
      }
      return _ParseStatus.mergeObjectSync(status, syncPairs);
    }
    static mergeObjectSync(status, pairs) {
      const finalObject = {};
      for (const pair of pairs) {
        const { key, value } = pair;
        if (key.status === "aborted")
          return INVALID;
        if (value.status === "aborted")
          return INVALID;
        if (key.status === "dirty")
          status.dirty();
        if (value.status === "dirty")
          status.dirty();
        if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
          finalObject[key.value] = value.value;
        }
      }
      return { status: status.value, value: finalObject };
    }
  };
  var INVALID = Object.freeze({
    status: "aborted"
  });
  var DIRTY = (value) => ({ status: "dirty", value });
  var OK = (value) => ({ status: "valid", value });
  var isAborted = (x) => x.status === "aborted";
  var isDirty = (x) => x.status === "dirty";
  var isValid = (x) => x.status === "valid";
  var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  var errorUtil;
  (function(errorUtil2) {
    errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
  })(errorUtil || (errorUtil = {}));
  var ParseInputLazyPath = class {
    constructor(parent, value, path, key) {
      this._cachedPath = [];
      this.parent = parent;
      this.data = value;
      this._path = path;
      this._key = key;
    }
    get path() {
      if (!this._cachedPath.length) {
        if (this._key instanceof Array) {
          this._cachedPath.push(...this._path, ...this._key);
        } else {
          this._cachedPath.push(...this._path, this._key);
        }
      }
      return this._cachedPath;
    }
  };
  var handleResult = (ctx, result) => {
    if (isValid(result)) {
      return { success: true, data: result.value };
    } else {
      if (!ctx.common.issues.length) {
        throw new Error("Validation failed but no issues detected.");
      }
      return {
        success: false,
        get error() {
          if (this._error)
            return this._error;
          const error = new ZodError(ctx.common.issues);
          this._error = error;
          return this._error;
        }
      };
    }
  };
  function processCreateParams(params) {
    if (!params)
      return {};
    const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
    if (errorMap2 && (invalid_type_error || required_error)) {
      throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    }
    if (errorMap2)
      return { errorMap: errorMap2, description };
    const customMap = (iss, ctx) => {
      if (iss.code !== "invalid_type")
        return { message: ctx.defaultError };
      if (typeof ctx.data === "undefined") {
        return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
      }
      return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
    };
    return { errorMap: customMap, description };
  }
  var ZodType = class {
    constructor(def) {
      this.spa = this.safeParseAsync;
      this._def = def;
      this.parse = this.parse.bind(this);
      this.safeParse = this.safeParse.bind(this);
      this.parseAsync = this.parseAsync.bind(this);
      this.safeParseAsync = this.safeParseAsync.bind(this);
      this.spa = this.spa.bind(this);
      this.refine = this.refine.bind(this);
      this.refinement = this.refinement.bind(this);
      this.superRefine = this.superRefine.bind(this);
      this.optional = this.optional.bind(this);
      this.nullable = this.nullable.bind(this);
      this.nullish = this.nullish.bind(this);
      this.array = this.array.bind(this);
      this.promise = this.promise.bind(this);
      this.or = this.or.bind(this);
      this.and = this.and.bind(this);
      this.transform = this.transform.bind(this);
      this.brand = this.brand.bind(this);
      this.default = this.default.bind(this);
      this.catch = this.catch.bind(this);
      this.describe = this.describe.bind(this);
      this.pipe = this.pipe.bind(this);
      this.readonly = this.readonly.bind(this);
      this.isNullable = this.isNullable.bind(this);
      this.isOptional = this.isOptional.bind(this);
    }
    get description() {
      return this._def.description;
    }
    _getType(input) {
      return getParsedType(input.data);
    }
    _getOrReturnCtx(input, ctx) {
      return ctx || {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      };
    }
    _processInputParams(input) {
      return {
        status: new ParseStatus(),
        ctx: {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        }
      };
    }
    _parseSync(input) {
      const result = this._parse(input);
      if (isAsync(result)) {
        throw new Error("Synchronous parse encountered promise.");
      }
      return result;
    }
    _parseAsync(input) {
      const result = this._parse(input);
      return Promise.resolve(result);
    }
    parse(data, params) {
      const result = this.safeParse(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    safeParse(data, params) {
      var _a;
      const ctx = {
        common: {
          issues: [],
          async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const result = this._parseSync({ data, path: ctx.path, parent: ctx });
      return handleResult(ctx, result);
    }
    async parseAsync(data, params) {
      const result = await this.safeParseAsync(data, params);
      if (result.success)
        return result.data;
      throw result.error;
    }
    async safeParseAsync(data, params) {
      const ctx = {
        common: {
          issues: [],
          contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
          async: true
        },
        path: (params === null || params === void 0 ? void 0 : params.path) || [],
        schemaErrorMap: this._def.errorMap,
        parent: null,
        data,
        parsedType: getParsedType(data)
      };
      const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
      const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
      return handleResult(ctx, result);
    }
    refine(check, message) {
      const getIssueProperties = (val) => {
        if (typeof message === "string" || typeof message === "undefined") {
          return { message };
        } else if (typeof message === "function") {
          return message(val);
        } else {
          return message;
        }
      };
      return this._refinement((val, ctx) => {
        const result = check(val);
        const setError = () => ctx.addIssue({
          code: ZodIssueCode.custom,
          ...getIssueProperties(val)
        });
        if (typeof Promise !== "undefined" && result instanceof Promise) {
          return result.then((data) => {
            if (!data) {
              setError();
              return false;
            } else {
              return true;
            }
          });
        }
        if (!result) {
          setError();
          return false;
        } else {
          return true;
        }
      });
    }
    refinement(check, refinementData) {
      return this._refinement((val, ctx) => {
        if (!check(val)) {
          ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
          return false;
        } else {
          return true;
        }
      });
    }
    _refinement(refinement) {
      return new ZodEffects({
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "refinement", refinement }
      });
    }
    superRefine(refinement) {
      return this._refinement(refinement);
    }
    optional() {
      return ZodOptional.create(this, this._def);
    }
    nullable() {
      return ZodNullable.create(this, this._def);
    }
    nullish() {
      return this.nullable().optional();
    }
    array() {
      return ZodArray.create(this, this._def);
    }
    promise() {
      return ZodPromise.create(this, this._def);
    }
    or(option) {
      return ZodUnion.create([this, option], this._def);
    }
    and(incoming) {
      return ZodIntersection.create(this, incoming, this._def);
    }
    transform(transform) {
      return new ZodEffects({
        ...processCreateParams(this._def),
        schema: this,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect: { type: "transform", transform }
      });
    }
    default(def) {
      const defaultValueFunc = typeof def === "function" ? def : () => def;
      return new ZodDefault({
        ...processCreateParams(this._def),
        innerType: this,
        defaultValue: defaultValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodDefault
      });
    }
    brand() {
      return new ZodBranded({
        typeName: ZodFirstPartyTypeKind.ZodBranded,
        type: this,
        ...processCreateParams(this._def)
      });
    }
    catch(def) {
      const catchValueFunc = typeof def === "function" ? def : () => def;
      return new ZodCatch({
        ...processCreateParams(this._def),
        innerType: this,
        catchValue: catchValueFunc,
        typeName: ZodFirstPartyTypeKind.ZodCatch
      });
    }
    describe(description) {
      const This = this.constructor;
      return new This({
        ...this._def,
        description
      });
    }
    pipe(target) {
      return ZodPipeline.create(this, target);
    }
    readonly() {
      return ZodReadonly.create(this);
    }
    isOptional() {
      return this.safeParse(void 0).success;
    }
    isNullable() {
      return this.safeParse(null).success;
    }
  };
  var cuidRegex = /^c[^\s-]{8,}$/i;
  var cuid2Regex = /^[a-z][a-z0-9]*$/;
  var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
  var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
  var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
  var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
  var emojiRegex;
  var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
  var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
  var datetimeRegex = (args) => {
    if (args.precision) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
      }
    } else if (args.precision === 0) {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
      }
    } else {
      if (args.offset) {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
      } else {
        return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
      }
    }
  };
  function isValidIP(ip, version) {
    if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
      return true;
    }
    if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
      return true;
    }
    return false;
  }
  var ZodString = class _ZodString extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = String(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.string) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(
          ctx2,
          {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          }
          //
        );
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.length < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.length > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "length") {
          const tooBig = input.data.length > check.value;
          const tooSmall = input.data.length < check.value;
          if (tooBig || tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            if (tooBig) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            } else if (tooSmall) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: true,
                message: check.message
              });
            }
            status.dirty();
          }
        } else if (check.kind === "email") {
          if (!emailRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "email",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "emoji") {
          if (!emojiRegex) {
            emojiRegex = new RegExp(_emojiRegex, "u");
          }
          if (!emojiRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "emoji",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "uuid") {
          if (!uuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "uuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid") {
          if (!cuidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "cuid2") {
          if (!cuid2Regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "cuid2",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ulid") {
          if (!ulidRegex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ulid",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "url") {
          try {
            new URL(input.data);
          } catch (_a) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "url",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "regex") {
          check.regex.lastIndex = 0;
          const testResult = check.regex.test(input.data);
          if (!testResult) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "regex",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "trim") {
          input.data = input.data.trim();
        } else if (check.kind === "includes") {
          if (!input.data.includes(check.value, check.position)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { includes: check.value, position: check.position },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "toLowerCase") {
          input.data = input.data.toLowerCase();
        } else if (check.kind === "toUpperCase") {
          input.data = input.data.toUpperCase();
        } else if (check.kind === "startsWith") {
          if (!input.data.startsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { startsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "endsWith") {
          if (!input.data.endsWith(check.value)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: { endsWith: check.value },
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "datetime") {
          const regex = datetimeRegex(check);
          if (!regex.test(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_string,
              validation: "datetime",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "ip") {
          if (!isValidIP(input.data, check.version)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              validation: "ip",
              code: ZodIssueCode.invalid_string,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    _regex(regex, validation, message) {
      return this.refinement((data) => regex.test(data), {
        validation,
        code: ZodIssueCode.invalid_string,
        ...errorUtil.errToObj(message)
      });
    }
    _addCheck(check) {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    email(message) {
      return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
    }
    url(message) {
      return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
    }
    emoji(message) {
      return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
    }
    uuid(message) {
      return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
    }
    cuid(message) {
      return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
    }
    cuid2(message) {
      return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
    }
    ulid(message) {
      return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
    }
    ip(options) {
      return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
    }
    datetime(options) {
      var _a;
      if (typeof options === "string") {
        return this._addCheck({
          kind: "datetime",
          precision: null,
          offset: false,
          message: options
        });
      }
      return this._addCheck({
        kind: "datetime",
        precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
        offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    regex(regex, message) {
      return this._addCheck({
        kind: "regex",
        regex,
        ...errorUtil.errToObj(message)
      });
    }
    includes(value, options) {
      return this._addCheck({
        kind: "includes",
        value,
        position: options === null || options === void 0 ? void 0 : options.position,
        ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
      });
    }
    startsWith(value, message) {
      return this._addCheck({
        kind: "startsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    endsWith(value, message) {
      return this._addCheck({
        kind: "endsWith",
        value,
        ...errorUtil.errToObj(message)
      });
    }
    min(minLength, message) {
      return this._addCheck({
        kind: "min",
        value: minLength,
        ...errorUtil.errToObj(message)
      });
    }
    max(maxLength, message) {
      return this._addCheck({
        kind: "max",
        value: maxLength,
        ...errorUtil.errToObj(message)
      });
    }
    length(len, message) {
      return this._addCheck({
        kind: "length",
        value: len,
        ...errorUtil.errToObj(message)
      });
    }
    /**
     * @deprecated Use z.string().min(1) instead.
     * @see {@link ZodString.min}
     */
    nonempty(message) {
      return this.min(1, errorUtil.errToObj(message));
    }
    trim() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "trim" }]
      });
    }
    toLowerCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toLowerCase" }]
      });
    }
    toUpperCase() {
      return new _ZodString({
        ...this._def,
        checks: [...this._def.checks, { kind: "toUpperCase" }]
      });
    }
    get isDatetime() {
      return !!this._def.checks.find((ch) => ch.kind === "datetime");
    }
    get isEmail() {
      return !!this._def.checks.find((ch) => ch.kind === "email");
    }
    get isURL() {
      return !!this._def.checks.find((ch) => ch.kind === "url");
    }
    get isEmoji() {
      return !!this._def.checks.find((ch) => ch.kind === "emoji");
    }
    get isUUID() {
      return !!this._def.checks.find((ch) => ch.kind === "uuid");
    }
    get isCUID() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid");
    }
    get isCUID2() {
      return !!this._def.checks.find((ch) => ch.kind === "cuid2");
    }
    get isULID() {
      return !!this._def.checks.find((ch) => ch.kind === "ulid");
    }
    get isIP() {
      return !!this._def.checks.find((ch) => ch.kind === "ip");
    }
    get minLength() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxLength() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodString.create = (params) => {
    var _a;
    return new ZodString({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodString,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepDecCount = (step.toString().split(".")[1] || "").length;
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
    return valInt % stepInt / Math.pow(10, decCount);
  }
  var ZodNumber = class _ZodNumber extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
      this.step = this.multipleOf;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = Number(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.number) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.number,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "int") {
          if (!util.isInteger(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_type,
              expected: "integer",
              received: "float",
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "number",
              inclusive: check.inclusive,
              exact: false,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (floatSafeRemainder(input.data, check.value) !== 0) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "finite") {
          if (!Number.isFinite(input.data)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_finite,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodNumber({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodNumber({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    int(message) {
      return this._addCheck({
        kind: "int",
        message: errorUtil.toString(message)
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: 0,
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    finite(message) {
      return this._addCheck({
        kind: "finite",
        message: errorUtil.toString(message)
      });
    }
    safe(message) {
      return this._addCheck({
        kind: "min",
        inclusive: true,
        value: Number.MIN_SAFE_INTEGER,
        message: errorUtil.toString(message)
      })._addCheck({
        kind: "max",
        inclusive: true,
        value: Number.MAX_SAFE_INTEGER,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
    get isInt() {
      return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
    }
    get isFinite() {
      let max = null, min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
          return true;
        } else if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        } else if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return Number.isFinite(min) && Number.isFinite(max);
    }
  };
  ZodNumber.create = (params) => {
    return new ZodNumber({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodNumber,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodBigInt = class _ZodBigInt extends ZodType {
    constructor() {
      super(...arguments);
      this.min = this.gte;
      this.max = this.lte;
    }
    _parse(input) {
      if (this._def.coerce) {
        input.data = BigInt(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.bigint) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      let ctx = void 0;
      const status = new ParseStatus();
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
          if (tooSmall) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              type: "bigint",
              minimum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
          if (tooBig) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              type: "bigint",
              maximum: check.value,
              inclusive: check.inclusive,
              message: check.message
            });
            status.dirty();
          }
        } else if (check.kind === "multipleOf") {
          if (input.data % check.value !== BigInt(0)) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.not_multiple_of,
              multipleOf: check.value,
              message: check.message
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return { status: status.value, value: input.data };
    }
    gte(value, message) {
      return this.setLimit("min", value, true, errorUtil.toString(message));
    }
    gt(value, message) {
      return this.setLimit("min", value, false, errorUtil.toString(message));
    }
    lte(value, message) {
      return this.setLimit("max", value, true, errorUtil.toString(message));
    }
    lt(value, message) {
      return this.setLimit("max", value, false, errorUtil.toString(message));
    }
    setLimit(kind, value, inclusive, message) {
      return new _ZodBigInt({
        ...this._def,
        checks: [
          ...this._def.checks,
          {
            kind,
            value,
            inclusive,
            message: errorUtil.toString(message)
          }
        ]
      });
    }
    _addCheck(check) {
      return new _ZodBigInt({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    positive(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    negative(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: false,
        message: errorUtil.toString(message)
      });
    }
    nonpositive(message) {
      return this._addCheck({
        kind: "max",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    nonnegative(message) {
      return this._addCheck({
        kind: "min",
        value: BigInt(0),
        inclusive: true,
        message: errorUtil.toString(message)
      });
    }
    multipleOf(value, message) {
      return this._addCheck({
        kind: "multipleOf",
        value,
        message: errorUtil.toString(message)
      });
    }
    get minValue() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min;
    }
    get maxValue() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max;
    }
  };
  ZodBigInt.create = (params) => {
    var _a;
    return new ZodBigInt({
      checks: [],
      typeName: ZodFirstPartyTypeKind.ZodBigInt,
      coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
      ...processCreateParams(params)
    });
  };
  var ZodBoolean = class extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = Boolean(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.boolean) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.boolean,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodBoolean.create = (params) => {
    return new ZodBoolean({
      typeName: ZodFirstPartyTypeKind.ZodBoolean,
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      ...processCreateParams(params)
    });
  };
  var ZodDate = class _ZodDate extends ZodType {
    _parse(input) {
      if (this._def.coerce) {
        input.data = new Date(input.data);
      }
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.date) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.date,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      if (isNaN(input.data.getTime())) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_date
        });
        return INVALID;
      }
      const status = new ParseStatus();
      let ctx = void 0;
      for (const check of this._def.checks) {
        if (check.kind === "min") {
          if (input.data.getTime() < check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              message: check.message,
              inclusive: true,
              exact: false,
              minimum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else if (check.kind === "max") {
          if (input.data.getTime() > check.value) {
            ctx = this._getOrReturnCtx(input, ctx);
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              message: check.message,
              inclusive: true,
              exact: false,
              maximum: check.value,
              type: "date"
            });
            status.dirty();
          }
        } else {
          util.assertNever(check);
        }
      }
      return {
        status: status.value,
        value: new Date(input.data.getTime())
      };
    }
    _addCheck(check) {
      return new _ZodDate({
        ...this._def,
        checks: [...this._def.checks, check]
      });
    }
    min(minDate, message) {
      return this._addCheck({
        kind: "min",
        value: minDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    max(maxDate, message) {
      return this._addCheck({
        kind: "max",
        value: maxDate.getTime(),
        message: errorUtil.toString(message)
      });
    }
    get minDate() {
      let min = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "min") {
          if (min === null || ch.value > min)
            min = ch.value;
        }
      }
      return min != null ? new Date(min) : null;
    }
    get maxDate() {
      let max = null;
      for (const ch of this._def.checks) {
        if (ch.kind === "max") {
          if (max === null || ch.value < max)
            max = ch.value;
        }
      }
      return max != null ? new Date(max) : null;
    }
  };
  ZodDate.create = (params) => {
    return new ZodDate({
      checks: [],
      coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
      typeName: ZodFirstPartyTypeKind.ZodDate,
      ...processCreateParams(params)
    });
  };
  var ZodSymbol = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.symbol) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.symbol,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodSymbol.create = (params) => {
    return new ZodSymbol({
      typeName: ZodFirstPartyTypeKind.ZodSymbol,
      ...processCreateParams(params)
    });
  };
  var ZodUndefined = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.undefined,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodUndefined.create = (params) => {
    return new ZodUndefined({
      typeName: ZodFirstPartyTypeKind.ZodUndefined,
      ...processCreateParams(params)
    });
  };
  var ZodNull = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.null) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.null,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodNull.create = (params) => {
    return new ZodNull({
      typeName: ZodFirstPartyTypeKind.ZodNull,
      ...processCreateParams(params)
    });
  };
  var ZodAny = class extends ZodType {
    constructor() {
      super(...arguments);
      this._any = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodAny.create = (params) => {
    return new ZodAny({
      typeName: ZodFirstPartyTypeKind.ZodAny,
      ...processCreateParams(params)
    });
  };
  var ZodUnknown = class extends ZodType {
    constructor() {
      super(...arguments);
      this._unknown = true;
    }
    _parse(input) {
      return OK(input.data);
    }
  };
  ZodUnknown.create = (params) => {
    return new ZodUnknown({
      typeName: ZodFirstPartyTypeKind.ZodUnknown,
      ...processCreateParams(params)
    });
  };
  var ZodNever = class extends ZodType {
    _parse(input) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.never,
        received: ctx.parsedType
      });
      return INVALID;
    }
  };
  ZodNever.create = (params) => {
    return new ZodNever({
      typeName: ZodFirstPartyTypeKind.ZodNever,
      ...processCreateParams(params)
    });
  };
  var ZodVoid = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.undefined) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.void,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return OK(input.data);
    }
  };
  ZodVoid.create = (params) => {
    return new ZodVoid({
      typeName: ZodFirstPartyTypeKind.ZodVoid,
      ...processCreateParams(params)
    });
  };
  var ZodArray = class _ZodArray extends ZodType {
    _parse(input) {
      const { ctx, status } = this._processInputParams(input);
      const def = this._def;
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (def.exactLength !== null) {
        const tooBig = ctx.data.length > def.exactLength.value;
        const tooSmall = ctx.data.length < def.exactLength.value;
        if (tooBig || tooSmall) {
          addIssueToContext(ctx, {
            code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
            minimum: tooSmall ? def.exactLength.value : void 0,
            maximum: tooBig ? def.exactLength.value : void 0,
            type: "array",
            inclusive: true,
            exact: true,
            message: def.exactLength.message
          });
          status.dirty();
        }
      }
      if (def.minLength !== null) {
        if (ctx.data.length < def.minLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.minLength.message
          });
          status.dirty();
        }
      }
      if (def.maxLength !== null) {
        if (ctx.data.length > def.maxLength.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxLength.value,
            type: "array",
            inclusive: true,
            exact: false,
            message: def.maxLength.message
          });
          status.dirty();
        }
      }
      if (ctx.common.async) {
        return Promise.all([...ctx.data].map((item, i) => {
          return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        })).then((result2) => {
          return ParseStatus.mergeArray(status, result2);
        });
      }
      const result = [...ctx.data].map((item, i) => {
        return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      });
      return ParseStatus.mergeArray(status, result);
    }
    get element() {
      return this._def.type;
    }
    min(minLength, message) {
      return new _ZodArray({
        ...this._def,
        minLength: { value: minLength, message: errorUtil.toString(message) }
      });
    }
    max(maxLength, message) {
      return new _ZodArray({
        ...this._def,
        maxLength: { value: maxLength, message: errorUtil.toString(message) }
      });
    }
    length(len, message) {
      return new _ZodArray({
        ...this._def,
        exactLength: { value: len, message: errorUtil.toString(message) }
      });
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodArray.create = (schema, params) => {
    return new ZodArray({
      type: schema,
      minLength: null,
      maxLength: null,
      exactLength: null,
      typeName: ZodFirstPartyTypeKind.ZodArray,
      ...processCreateParams(params)
    });
  };
  function deepPartialify(schema) {
    if (schema instanceof ZodObject) {
      const newShape = {};
      for (const key in schema.shape) {
        const fieldSchema = schema.shape[key];
        newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
      }
      return new ZodObject({
        ...schema._def,
        shape: () => newShape
      });
    } else if (schema instanceof ZodArray) {
      return new ZodArray({
        ...schema._def,
        type: deepPartialify(schema.element)
      });
    } else if (schema instanceof ZodOptional) {
      return ZodOptional.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodNullable) {
      return ZodNullable.create(deepPartialify(schema.unwrap()));
    } else if (schema instanceof ZodTuple) {
      return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
    } else {
      return schema;
    }
  }
  var ZodObject = class _ZodObject extends ZodType {
    constructor() {
      super(...arguments);
      this._cached = null;
      this.nonstrict = this.passthrough;
      this.augment = this.extend;
    }
    _getCached() {
      if (this._cached !== null)
        return this._cached;
      const shape = this._def.shape();
      const keys = util.objectKeys(shape);
      return this._cached = { shape, keys };
    }
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.object) {
        const ctx2 = this._getOrReturnCtx(input);
        addIssueToContext(ctx2, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx2.parsedType
        });
        return INVALID;
      }
      const { status, ctx } = this._processInputParams(input);
      const { shape, keys: shapeKeys } = this._getCached();
      const extraKeys = [];
      if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
        for (const key in ctx.data) {
          if (!shapeKeys.includes(key)) {
            extraKeys.push(key);
          }
        }
      }
      const pairs = [];
      for (const key of shapeKeys) {
        const keyValidator = shape[key];
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
      if (this._def.catchall instanceof ZodNever) {
        const unknownKeys = this._def.unknownKeys;
        if (unknownKeys === "passthrough") {
          for (const key of extraKeys) {
            pairs.push({
              key: { status: "valid", value: key },
              value: { status: "valid", value: ctx.data[key] }
            });
          }
        } else if (unknownKeys === "strict") {
          if (extraKeys.length > 0) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.unrecognized_keys,
              keys: extraKeys
            });
            status.dirty();
          }
        } else if (unknownKeys === "strip")
          ;
        else {
          throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
        }
      } else {
        const catchall = this._def.catchall;
        for (const key of extraKeys) {
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: catchall._parse(
              new ParseInputLazyPath(ctx, value, ctx.path, key)
              //, ctx.child(key), value, getParsedType(value)
            ),
            alwaysSet: key in ctx.data
          });
        }
      }
      if (ctx.common.async) {
        return Promise.resolve().then(async () => {
          const syncPairs = [];
          for (const pair of pairs) {
            const key = await pair.key;
            syncPairs.push({
              key,
              value: await pair.value,
              alwaysSet: pair.alwaysSet
            });
          }
          return syncPairs;
        }).then((syncPairs) => {
          return ParseStatus.mergeObjectSync(status, syncPairs);
        });
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get shape() {
      return this._def.shape();
    }
    strict(message) {
      errorUtil.errToObj;
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strict",
        ...message !== void 0 ? {
          errorMap: (issue, ctx) => {
            var _a, _b, _c, _d;
            const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
            if (issue.code === "unrecognized_keys")
              return {
                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
              };
            return {
              message: defaultError
            };
          }
        } : {}
      });
    }
    strip() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "strip"
      });
    }
    passthrough() {
      return new _ZodObject({
        ...this._def,
        unknownKeys: "passthrough"
      });
    }
    // const AugmentFactory =
    //   <Def extends ZodObjectDef>(def: Def) =>
    //   <Augmentation extends ZodRawShape>(
    //     augmentation: Augmentation
    //   ): ZodObject<
    //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
    //     Def["unknownKeys"],
    //     Def["catchall"]
    //   > => {
    //     return new ZodObject({
    //       ...def,
    //       shape: () => ({
    //         ...def.shape(),
    //         ...augmentation,
    //       }),
    //     }) as any;
    //   };
    extend(augmentation) {
      return new _ZodObject({
        ...this._def,
        shape: () => ({
          ...this._def.shape(),
          ...augmentation
        })
      });
    }
    /**
     * Prior to zod@1.0.12 there was a bug in the
     * inferred type of merged objects. Please
     * upgrade if you are experiencing issues.
     */
    merge(merging) {
      const merged = new _ZodObject({
        unknownKeys: merging._def.unknownKeys,
        catchall: merging._def.catchall,
        shape: () => ({
          ...this._def.shape(),
          ...merging._def.shape()
        }),
        typeName: ZodFirstPartyTypeKind.ZodObject
      });
      return merged;
    }
    // merge<
    //   Incoming extends AnyZodObject,
    //   Augmentation extends Incoming["shape"],
    //   NewOutput extends {
    //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
    //       ? Augmentation[k]["_output"]
    //       : k extends keyof Output
    //       ? Output[k]
    //       : never;
    //   },
    //   NewInput extends {
    //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
    //       ? Augmentation[k]["_input"]
    //       : k extends keyof Input
    //       ? Input[k]
    //       : never;
    //   }
    // >(
    //   merging: Incoming
    // ): ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"],
    //   NewOutput,
    //   NewInput
    // > {
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    setKey(key, schema) {
      return this.augment({ [key]: schema });
    }
    // merge<Incoming extends AnyZodObject>(
    //   merging: Incoming
    // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
    // ZodObject<
    //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
    //   Incoming["_def"]["unknownKeys"],
    //   Incoming["_def"]["catchall"]
    // > {
    //   // const mergedShape = objectUtil.mergeShapes(
    //   //   this._def.shape(),
    //   //   merging._def.shape()
    //   // );
    //   const merged: any = new ZodObject({
    //     unknownKeys: merging._def.unknownKeys,
    //     catchall: merging._def.catchall,
    //     shape: () =>
    //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
    //     typeName: ZodFirstPartyTypeKind.ZodObject,
    //   }) as any;
    //   return merged;
    // }
    catchall(index) {
      return new _ZodObject({
        ...this._def,
        catchall: index
      });
    }
    pick(mask) {
      const shape = {};
      util.objectKeys(mask).forEach((key) => {
        if (mask[key] && this.shape[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    omit(mask) {
      const shape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (!mask[key]) {
          shape[key] = this.shape[key];
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => shape
      });
    }
    /**
     * @deprecated
     */
    deepPartial() {
      return deepPartialify(this);
    }
    partial(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        const fieldSchema = this.shape[key];
        if (mask && !mask[key]) {
          newShape[key] = fieldSchema;
        } else {
          newShape[key] = fieldSchema.optional();
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    required(mask) {
      const newShape = {};
      util.objectKeys(this.shape).forEach((key) => {
        if (mask && !mask[key]) {
          newShape[key] = this.shape[key];
        } else {
          const fieldSchema = this.shape[key];
          let newField2 = fieldSchema;
          while (newField2 instanceof ZodOptional) {
            newField2 = newField2._def.innerType;
          }
          newShape[key] = newField2;
        }
      });
      return new _ZodObject({
        ...this._def,
        shape: () => newShape
      });
    }
    keyof() {
      return createZodEnum(util.objectKeys(this.shape));
    }
  };
  ZodObject.create = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.strictCreate = (shape, params) => {
    return new ZodObject({
      shape: () => shape,
      unknownKeys: "strict",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  ZodObject.lazycreate = (shape, params) => {
    return new ZodObject({
      shape,
      unknownKeys: "strip",
      catchall: ZodNever.create(),
      typeName: ZodFirstPartyTypeKind.ZodObject,
      ...processCreateParams(params)
    });
  };
  var ZodUnion = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const options = this._def.options;
      function handleResults(results) {
        for (const result of results) {
          if (result.result.status === "valid") {
            return result.result;
          }
        }
        for (const result of results) {
          if (result.result.status === "dirty") {
            ctx.common.issues.push(...result.ctx.common.issues);
            return result.result;
          }
        }
        const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return Promise.all(options.map(async (option) => {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          return {
            result: await option._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            }),
            ctx: childCtx
          };
        })).then(handleResults);
      } else {
        let dirty = void 0;
        const issues = [];
        for (const option of options) {
          const childCtx = {
            ...ctx,
            common: {
              ...ctx.common,
              issues: []
            },
            parent: null
          };
          const result = option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          });
          if (result.status === "valid") {
            return result;
          } else if (result.status === "dirty" && !dirty) {
            dirty = { result, ctx: childCtx };
          }
          if (childCtx.common.issues.length) {
            issues.push(childCtx.common.issues);
          }
        }
        if (dirty) {
          ctx.common.issues.push(...dirty.ctx.common.issues);
          return dirty.result;
        }
        const unionErrors = issues.map((issues2) => new ZodError(issues2));
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union,
          unionErrors
        });
        return INVALID;
      }
    }
    get options() {
      return this._def.options;
    }
  };
  ZodUnion.create = (types, params) => {
    return new ZodUnion({
      options: types,
      typeName: ZodFirstPartyTypeKind.ZodUnion,
      ...processCreateParams(params)
    });
  };
  var getDiscriminator = (type) => {
    if (type instanceof ZodLazy) {
      return getDiscriminator(type.schema);
    } else if (type instanceof ZodEffects) {
      return getDiscriminator(type.innerType());
    } else if (type instanceof ZodLiteral) {
      return [type.value];
    } else if (type instanceof ZodEnum) {
      return type.options;
    } else if (type instanceof ZodNativeEnum) {
      return Object.keys(type.enum);
    } else if (type instanceof ZodDefault) {
      return getDiscriminator(type._def.innerType);
    } else if (type instanceof ZodUndefined) {
      return [void 0];
    } else if (type instanceof ZodNull) {
      return [null];
    } else {
      return null;
    }
  };
  var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const discriminator = this.discriminator;
      const discriminatorValue = ctx.data[discriminator];
      const option = this.optionsMap.get(discriminatorValue);
      if (!option) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_union_discriminator,
          options: Array.from(this.optionsMap.keys()),
          path: [discriminator]
        });
        return INVALID;
      }
      if (ctx.common.async) {
        return option._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      } else {
        return option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    get discriminator() {
      return this._def.discriminator;
    }
    get options() {
      return this._def.options;
    }
    get optionsMap() {
      return this._def.optionsMap;
    }
    /**
     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
     * have a different value for each object in the union.
     * @param discriminator the name of the discriminator property
     * @param types an array of object schemas
     * @param params
     */
    static create(discriminator, options, params) {
      const optionsMap = /* @__PURE__ */ new Map();
      for (const type of options) {
        const discriminatorValues = getDiscriminator(type.shape[discriminator]);
        if (!discriminatorValues) {
          throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
        }
        for (const value of discriminatorValues) {
          if (optionsMap.has(value)) {
            throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
          }
          optionsMap.set(value, type);
        }
      }
      return new _ZodDiscriminatedUnion({
        typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
        discriminator,
        options,
        optionsMap,
        ...processCreateParams(params)
      });
    }
  };
  function mergeValues(a, b) {
    const aType = getParsedType(a);
    const bType = getParsedType(b);
    if (a === b) {
      return { valid: true, data: a };
    } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
      const bKeys = util.objectKeys(b);
      const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
      const newObj = { ...a, ...b };
      for (const key of sharedKeys) {
        const sharedValue = mergeValues(a[key], b[key]);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newObj[key] = sharedValue.data;
      }
      return { valid: true, data: newObj };
    } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
      if (a.length !== b.length) {
        return { valid: false };
      }
      const newArray = [];
      for (let index = 0; index < a.length; index++) {
        const itemA = a[index];
        const itemB = b[index];
        const sharedValue = mergeValues(itemA, itemB);
        if (!sharedValue.valid) {
          return { valid: false };
        }
        newArray.push(sharedValue.data);
      }
      return { valid: true, data: newArray };
    } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
      return { valid: true, data: a };
    } else {
      return { valid: false };
    }
  }
  var ZodIntersection = class extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const handleParsed = (parsedLeft, parsedRight) => {
        if (isAborted(parsedLeft) || isAborted(parsedRight)) {
          return INVALID;
        }
        const merged = mergeValues(parsedLeft.value, parsedRight.value);
        if (!merged.valid) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_intersection_types
          });
          return INVALID;
        }
        if (isDirty(parsedLeft) || isDirty(parsedRight)) {
          status.dirty();
        }
        return { status: status.value, value: merged.data };
      };
      if (ctx.common.async) {
        return Promise.all([
          this._def.left._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }),
          this._def.right._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          })
        ]).then(([left, right]) => handleParsed(left, right));
      } else {
        return handleParsed(this._def.left._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }), this._def.right._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }));
      }
    }
  };
  ZodIntersection.create = (left, right, params) => {
    return new ZodIntersection({
      left,
      right,
      typeName: ZodFirstPartyTypeKind.ZodIntersection,
      ...processCreateParams(params)
    });
  };
  var ZodTuple = class _ZodTuple extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.array) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.array,
          received: ctx.parsedType
        });
        return INVALID;
      }
      if (ctx.data.length < this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        return INVALID;
      }
      const rest = this._def.rest;
      if (!rest && ctx.data.length > this._def.items.length) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: this._def.items.length,
          inclusive: true,
          exact: false,
          type: "array"
        });
        status.dirty();
      }
      const items = [...ctx.data].map((item, itemIndex) => {
        const schema = this._def.items[itemIndex] || this._def.rest;
        if (!schema)
          return null;
        return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
      }).filter((x) => !!x);
      if (ctx.common.async) {
        return Promise.all(items).then((results) => {
          return ParseStatus.mergeArray(status, results);
        });
      } else {
        return ParseStatus.mergeArray(status, items);
      }
    }
    get items() {
      return this._def.items;
    }
    rest(rest) {
      return new _ZodTuple({
        ...this._def,
        rest
      });
    }
  };
  ZodTuple.create = (schemas, params) => {
    if (!Array.isArray(schemas)) {
      throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    }
    return new ZodTuple({
      items: schemas,
      typeName: ZodFirstPartyTypeKind.ZodTuple,
      rest: null,
      ...processCreateParams(params)
    });
  };
  var ZodRecord = class _ZodRecord extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.object) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.object,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const pairs = [];
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      for (const key in ctx.data) {
        pairs.push({
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
          value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
        });
      }
      if (ctx.common.async) {
        return ParseStatus.mergeObjectAsync(status, pairs);
      } else {
        return ParseStatus.mergeObjectSync(status, pairs);
      }
    }
    get element() {
      return this._def.valueType;
    }
    static create(first, second, third) {
      if (second instanceof ZodType) {
        return new _ZodRecord({
          keyType: first,
          valueType: second,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(third)
        });
      }
      return new _ZodRecord({
        keyType: ZodString.create(),
        valueType: first,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(second)
      });
    }
  };
  var ZodMap = class extends ZodType {
    get keySchema() {
      return this._def.keyType;
    }
    get valueSchema() {
      return this._def.valueType;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.map) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.map,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const keyType = this._def.keyType;
      const valueType = this._def.valueType;
      const pairs = [...ctx.data.entries()].map(([key, value], index) => {
        return {
          key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
          value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
        };
      });
      if (ctx.common.async) {
        const finalMap = /* @__PURE__ */ new Map();
        return Promise.resolve().then(async () => {
          for (const pair of pairs) {
            const key = await pair.key;
            const value = await pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        });
      } else {
        const finalMap = /* @__PURE__ */ new Map();
        for (const pair of pairs) {
          const key = pair.key;
          const value = pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      }
    }
  };
  ZodMap.create = (keyType, valueType, params) => {
    return new ZodMap({
      valueType,
      keyType,
      typeName: ZodFirstPartyTypeKind.ZodMap,
      ...processCreateParams(params)
    });
  };
  var ZodSet = class _ZodSet extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.set) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.set,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const def = this._def;
      if (def.minSize !== null) {
        if (ctx.data.size < def.minSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: def.minSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.minSize.message
          });
          status.dirty();
        }
      }
      if (def.maxSize !== null) {
        if (ctx.data.size > def.maxSize.value) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: def.maxSize.value,
            type: "set",
            inclusive: true,
            exact: false,
            message: def.maxSize.message
          });
          status.dirty();
        }
      }
      const valueType = this._def.valueType;
      function finalizeSet(elements2) {
        const parsedSet = /* @__PURE__ */ new Set();
        for (const element of elements2) {
          if (element.status === "aborted")
            return INVALID;
          if (element.status === "dirty")
            status.dirty();
          parsedSet.add(element.value);
        }
        return { status: status.value, value: parsedSet };
      }
      const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
      if (ctx.common.async) {
        return Promise.all(elements).then((elements2) => finalizeSet(elements2));
      } else {
        return finalizeSet(elements);
      }
    }
    min(minSize, message) {
      return new _ZodSet({
        ...this._def,
        minSize: { value: minSize, message: errorUtil.toString(message) }
      });
    }
    max(maxSize, message) {
      return new _ZodSet({
        ...this._def,
        maxSize: { value: maxSize, message: errorUtil.toString(message) }
      });
    }
    size(size, message) {
      return this.min(size, message).max(size, message);
    }
    nonempty(message) {
      return this.min(1, message);
    }
  };
  ZodSet.create = (valueType, params) => {
    return new ZodSet({
      valueType,
      minSize: null,
      maxSize: null,
      typeName: ZodFirstPartyTypeKind.ZodSet,
      ...processCreateParams(params)
    });
  };
  var ZodFunction = class _ZodFunction extends ZodType {
    constructor() {
      super(...arguments);
      this.validate = this.implement;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.function) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.function,
          received: ctx.parsedType
        });
        return INVALID;
      }
      function makeArgsIssue(args, error) {
        return makeIssue({
          data: args,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_arguments,
            argumentsError: error
          }
        });
      }
      function makeReturnsIssue(returns, error) {
        return makeIssue({
          data: returns,
          path: ctx.path,
          errorMaps: [
            ctx.common.contextualErrorMap,
            ctx.schemaErrorMap,
            getErrorMap(),
            errorMap
          ].filter((x) => !!x),
          issueData: {
            code: ZodIssueCode.invalid_return_type,
            returnTypeError: error
          }
        });
      }
      const params = { errorMap: ctx.common.contextualErrorMap };
      const fn = ctx.data;
      if (this._def.returns instanceof ZodPromise) {
        const me = this;
        return OK(async function(...args) {
          const error = new ZodError([]);
          const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
            error.addIssue(makeArgsIssue(args, e));
            throw error;
          });
          const result = await Reflect.apply(fn, this, parsedArgs);
          const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
            error.addIssue(makeReturnsIssue(result, e));
            throw error;
          });
          return parsedReturns;
        });
      } else {
        const me = this;
        return OK(function(...args) {
          const parsedArgs = me._def.args.safeParse(args, params);
          if (!parsedArgs.success) {
            throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
          }
          const result = Reflect.apply(fn, this, parsedArgs.data);
          const parsedReturns = me._def.returns.safeParse(result, params);
          if (!parsedReturns.success) {
            throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
          }
          return parsedReturns.data;
        });
      }
    }
    parameters() {
      return this._def.args;
    }
    returnType() {
      return this._def.returns;
    }
    args(...items) {
      return new _ZodFunction({
        ...this._def,
        args: ZodTuple.create(items).rest(ZodUnknown.create())
      });
    }
    returns(returnType) {
      return new _ZodFunction({
        ...this._def,
        returns: returnType
      });
    }
    implement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    strictImplement(func) {
      const validatedFunc = this.parse(func);
      return validatedFunc;
    }
    static create(args, returns, params) {
      return new _ZodFunction({
        args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
        returns: returns || ZodUnknown.create(),
        typeName: ZodFirstPartyTypeKind.ZodFunction,
        ...processCreateParams(params)
      });
    }
  };
  var ZodLazy = class extends ZodType {
    get schema() {
      return this._def.getter();
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const lazySchema = this._def.getter();
      return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
    }
  };
  ZodLazy.create = (getter, params) => {
    return new ZodLazy({
      getter,
      typeName: ZodFirstPartyTypeKind.ZodLazy,
      ...processCreateParams(params)
    });
  };
  var ZodLiteral = class extends ZodType {
    _parse(input) {
      if (input.data !== this._def.value) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_literal,
          expected: this._def.value
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
    get value() {
      return this._def.value;
    }
  };
  ZodLiteral.create = (value, params) => {
    return new ZodLiteral({
      value,
      typeName: ZodFirstPartyTypeKind.ZodLiteral,
      ...processCreateParams(params)
    });
  };
  function createZodEnum(values, params) {
    return new ZodEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodEnum,
      ...processCreateParams(params)
    });
  }
  var ZodEnum = class _ZodEnum extends ZodType {
    _parse(input) {
      if (typeof input.data !== "string") {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (this._def.values.indexOf(input.data) === -1) {
        const ctx = this._getOrReturnCtx(input);
        const expectedValues = this._def.values;
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get options() {
      return this._def.values;
    }
    get enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Values() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    get Enum() {
      const enumValues = {};
      for (const val of this._def.values) {
        enumValues[val] = val;
      }
      return enumValues;
    }
    extract(values) {
      return _ZodEnum.create(values);
    }
    exclude(values) {
      return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
    }
  };
  ZodEnum.create = createZodEnum;
  var ZodNativeEnum = class extends ZodType {
    _parse(input) {
      const nativeEnumValues = util.getValidEnumValues(this._def.values);
      const ctx = this._getOrReturnCtx(input);
      if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          expected: util.joinValues(expectedValues),
          received: ctx.parsedType,
          code: ZodIssueCode.invalid_type
        });
        return INVALID;
      }
      if (nativeEnumValues.indexOf(input.data) === -1) {
        const expectedValues = util.objectValues(nativeEnumValues);
        addIssueToContext(ctx, {
          received: ctx.data,
          code: ZodIssueCode.invalid_enum_value,
          options: expectedValues
        });
        return INVALID;
      }
      return OK(input.data);
    }
    get enum() {
      return this._def.values;
    }
  };
  ZodNativeEnum.create = (values, params) => {
    return new ZodNativeEnum({
      values,
      typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
      ...processCreateParams(params)
    });
  };
  var ZodPromise = class extends ZodType {
    unwrap() {
      return this._def.type;
    }
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.promise,
          received: ctx.parsedType
        });
        return INVALID;
      }
      const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
      return OK(promisified.then((data) => {
        return this._def.type.parseAsync(data, {
          path: ctx.path,
          errorMap: ctx.common.contextualErrorMap
        });
      }));
    }
  };
  ZodPromise.create = (schema, params) => {
    return new ZodPromise({
      type: schema,
      typeName: ZodFirstPartyTypeKind.ZodPromise,
      ...processCreateParams(params)
    });
  };
  var ZodEffects = class extends ZodType {
    innerType() {
      return this._def.schema;
    }
    sourceType() {
      return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
    }
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      const effect = this._def.effect || null;
      const checkCtx = {
        addIssue: (arg) => {
          addIssueToContext(ctx, arg);
          if (arg.fatal) {
            status.abort();
          } else {
            status.dirty();
          }
        },
        get path() {
          return ctx.path;
        }
      };
      checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
      if (effect.type === "preprocess") {
        const processed = effect.transform(ctx.data, checkCtx);
        if (ctx.common.issues.length) {
          return {
            status: "dirty",
            value: ctx.data
          };
        }
        if (ctx.common.async) {
          return Promise.resolve(processed).then((processed2) => {
            return this._def.schema._parseAsync({
              data: processed2,
              path: ctx.path,
              parent: ctx
            });
          });
        } else {
          return this._def.schema._parseSync({
            data: processed,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      if (effect.type === "refinement") {
        const executeRefinement = (acc) => {
          const result = effect.refinement(acc, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(result);
          }
          if (result instanceof Promise) {
            throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
          }
          return acc;
        };
        if (ctx.common.async === false) {
          const inner = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          executeRefinement(inner.value);
          return { status: status.value, value: inner.value };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            return executeRefinement(inner.value).then(() => {
              return { status: status.value, value: inner.value };
            });
          });
        }
      }
      if (effect.type === "transform") {
        if (ctx.common.async === false) {
          const base = this._def.schema._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (!isValid(base))
            return base;
          const result = effect.transform(base.value, checkCtx);
          if (result instanceof Promise) {
            throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
          }
          return { status: status.value, value: result };
        } else {
          return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
            if (!isValid(base))
              return base;
            return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
          });
        }
      }
      util.assertNever(effect);
    }
  };
  ZodEffects.create = (schema, effect, params) => {
    return new ZodEffects({
      schema,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect,
      ...processCreateParams(params)
    });
  };
  ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
    return new ZodEffects({
      schema,
      effect: { type: "preprocess", transform: preprocess },
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      ...processCreateParams(params)
    });
  };
  var ZodOptional = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.undefined) {
        return OK(void 0);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodOptional.create = (type, params) => {
    return new ZodOptional({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodOptional,
      ...processCreateParams(params)
    });
  };
  var ZodNullable = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType === ZodParsedType.null) {
        return OK(null);
      }
      return this._def.innerType._parse(input);
    }
    unwrap() {
      return this._def.innerType;
    }
  };
  ZodNullable.create = (type, params) => {
    return new ZodNullable({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodNullable,
      ...processCreateParams(params)
    });
  };
  var ZodDefault = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      let data = ctx.data;
      if (ctx.parsedType === ZodParsedType.undefined) {
        data = this._def.defaultValue();
      }
      return this._def.innerType._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    removeDefault() {
      return this._def.innerType;
    }
  };
  ZodDefault.create = (type, params) => {
    return new ZodDefault({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodDefault,
      defaultValue: typeof params.default === "function" ? params.default : () => params.default,
      ...processCreateParams(params)
    });
  };
  var ZodCatch = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const newCtx = {
        ...ctx,
        common: {
          ...ctx.common,
          issues: []
        }
      };
      const result = this._def.innerType._parse({
        data: newCtx.data,
        path: newCtx.path,
        parent: {
          ...newCtx
        }
      });
      if (isAsync(result)) {
        return result.then((result2) => {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        });
      } else {
        return {
          status: "valid",
          value: result.status === "valid" ? result.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      }
    }
    removeCatch() {
      return this._def.innerType;
    }
  };
  ZodCatch.create = (type, params) => {
    return new ZodCatch({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodCatch,
      catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
      ...processCreateParams(params)
    });
  };
  var ZodNaN = class extends ZodType {
    _parse(input) {
      const parsedType = this._getType(input);
      if (parsedType !== ZodParsedType.nan) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.nan,
          received: ctx.parsedType
        });
        return INVALID;
      }
      return { status: "valid", value: input.data };
    }
  };
  ZodNaN.create = (params) => {
    return new ZodNaN({
      typeName: ZodFirstPartyTypeKind.ZodNaN,
      ...processCreateParams(params)
    });
  };
  var BRAND = Symbol("zod_brand");
  var ZodBranded = class extends ZodType {
    _parse(input) {
      const { ctx } = this._processInputParams(input);
      const data = ctx.data;
      return this._def.type._parse({
        data,
        path: ctx.path,
        parent: ctx
      });
    }
    unwrap() {
      return this._def.type;
    }
  };
  var ZodPipeline = class _ZodPipeline extends ZodType {
    _parse(input) {
      const { status, ctx } = this._processInputParams(input);
      if (ctx.common.async) {
        const handleAsync = async () => {
          const inResult = await this._def.in._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return DIRTY(inResult.value);
          } else {
            return this._def.out._parseAsync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        };
        return handleAsync();
      } else {
        const inResult = this._def.in._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return {
            status: "dirty",
            value: inResult.value
          };
        } else {
          return this._def.out._parseSync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      }
    }
    static create(a, b) {
      return new _ZodPipeline({
        in: a,
        out: b,
        typeName: ZodFirstPartyTypeKind.ZodPipeline
      });
    }
  };
  var ZodReadonly = class extends ZodType {
    _parse(input) {
      const result = this._def.innerType._parse(input);
      if (isValid(result)) {
        result.value = Object.freeze(result.value);
      }
      return result;
    }
  };
  ZodReadonly.create = (type, params) => {
    return new ZodReadonly({
      innerType: type,
      typeName: ZodFirstPartyTypeKind.ZodReadonly,
      ...processCreateParams(params)
    });
  };
  var custom = (check, params = {}, fatal) => {
    if (check)
      return ZodAny.create().superRefine((data, ctx) => {
        var _a, _b;
        if (!check(data)) {
          const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
          const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
          const p2 = typeof p === "string" ? { message: p } : p;
          ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
        }
      });
    return ZodAny.create();
  };
  var late = {
    object: ZodObject.lazycreate
  };
  var ZodFirstPartyTypeKind;
  (function(ZodFirstPartyTypeKind2) {
    ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
  })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
  var instanceOfType = (cls, params = {
    message: `Input not instance of ${cls.name}`
  }) => custom((data) => data instanceof cls, params);
  var stringType = ZodString.create;
  var numberType = ZodNumber.create;
  var nanType = ZodNaN.create;
  var bigIntType = ZodBigInt.create;
  var booleanType = ZodBoolean.create;
  var dateType = ZodDate.create;
  var symbolType = ZodSymbol.create;
  var undefinedType = ZodUndefined.create;
  var nullType = ZodNull.create;
  var anyType = ZodAny.create;
  var unknownType = ZodUnknown.create;
  var neverType = ZodNever.create;
  var voidType = ZodVoid.create;
  var arrayType = ZodArray.create;
  var objectType = ZodObject.create;
  var strictObjectType = ZodObject.strictCreate;
  var unionType = ZodUnion.create;
  var discriminatedUnionType = ZodDiscriminatedUnion.create;
  var intersectionType = ZodIntersection.create;
  var tupleType = ZodTuple.create;
  var recordType = ZodRecord.create;
  var mapType = ZodMap.create;
  var setType = ZodSet.create;
  var functionType = ZodFunction.create;
  var lazyType = ZodLazy.create;
  var literalType = ZodLiteral.create;
  var enumType = ZodEnum.create;
  var nativeEnumType = ZodNativeEnum.create;
  var promiseType = ZodPromise.create;
  var effectsType = ZodEffects.create;
  var optionalType = ZodOptional.create;
  var nullableType = ZodNullable.create;
  var preprocessType = ZodEffects.createWithPreprocess;
  var pipelineType = ZodPipeline.create;
  var ostring = () => stringType().optional();
  var onumber = () => numberType().optional();
  var oboolean = () => booleanType().optional();
  var coerce = {
    string: (arg) => ZodString.create({ ...arg, coerce: true }),
    number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
    boolean: (arg) => ZodBoolean.create({
      ...arg,
      coerce: true
    }),
    bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
    date: (arg) => ZodDate.create({ ...arg, coerce: true })
  };
  var NEVER = INVALID;
  var z = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    defaultErrorMap: errorMap,
    setErrorMap,
    getErrorMap,
    makeIssue,
    EMPTY_PATH,
    addIssueToContext,
    ParseStatus,
    INVALID,
    DIRTY,
    OK,
    isAborted,
    isDirty,
    isValid,
    isAsync,
    get util() {
      return util;
    },
    get objectUtil() {
      return objectUtil;
    },
    ZodParsedType,
    getParsedType,
    ZodType,
    ZodString,
    ZodNumber,
    ZodBigInt,
    ZodBoolean,
    ZodDate,
    ZodSymbol,
    ZodUndefined,
    ZodNull,
    ZodAny,
    ZodUnknown,
    ZodNever,
    ZodVoid,
    ZodArray,
    ZodObject,
    ZodUnion,
    ZodDiscriminatedUnion,
    ZodIntersection,
    ZodTuple,
    ZodRecord,
    ZodMap,
    ZodSet,
    ZodFunction,
    ZodLazy,
    ZodLiteral,
    ZodEnum,
    ZodNativeEnum,
    ZodPromise,
    ZodEffects,
    ZodTransformer: ZodEffects,
    ZodOptional,
    ZodNullable,
    ZodDefault,
    ZodCatch,
    ZodNaN,
    BRAND,
    ZodBranded,
    ZodPipeline,
    ZodReadonly,
    custom,
    Schema: ZodType,
    ZodSchema: ZodType,
    late,
    get ZodFirstPartyTypeKind() {
      return ZodFirstPartyTypeKind;
    },
    coerce,
    any: anyType,
    array: arrayType,
    bigint: bigIntType,
    boolean: booleanType,
    date: dateType,
    discriminatedUnion: discriminatedUnionType,
    effect: effectsType,
    "enum": enumType,
    "function": functionType,
    "instanceof": instanceOfType,
    intersection: intersectionType,
    lazy: lazyType,
    literal: literalType,
    map: mapType,
    nan: nanType,
    nativeEnum: nativeEnumType,
    never: neverType,
    "null": nullType,
    nullable: nullableType,
    number: numberType,
    object: objectType,
    oboolean,
    onumber,
    optional: optionalType,
    ostring,
    pipeline: pipelineType,
    preprocess: preprocessType,
    promise: promiseType,
    record: recordType,
    set: setType,
    strictObject: strictObjectType,
    string: stringType,
    symbol: symbolType,
    transformer: effectsType,
    tuple: tupleType,
    "undefined": undefinedType,
    union: unionType,
    unknown: unknownType,
    "void": voidType,
    NEVER,
    ZodIssueCode,
    quotelessJson,
    ZodError
  });

  // src/validators/common.validators.ts
  var ConnectionParameterSchema = z.object({
    roomId: z.string({
      required_error: "Room id must provided"
    }),
    token: z.string({
      required_error: "Token must provided"
    })
  });
  var GeolocationSchema = z.object({
    country: z.string({
      required_error: "Country must provided"
    }),
    latitude: z.string({
      required_error: "Latitude must provided"
    }),
    longitude: z.string({
      required_error: "Longitude must provided"
    }),
    region: z.string({
      required_error: "Region must provided"
    }),
    globalRegion: z.string({
      required_error: "Global region must provided"
    }),
    ip: z.string({
      required_error: "IP must provided"
    })
  });
  var VolatileDataMessageSchema = z.object({
    from: z.string(),
    payload: z.unknown(),
    label: z.string().optional(),
    to: z.union([z.literal("*"), z.array(z.string())]).optional()
  });
  var DataMessageSchema = z.object({
    from: z.string(),
    payload: z.string(),
    label: z.string().optional()
  });

  // src/Socket.ts
  var import_request_pb = __toESM(require_request_pb(), 1);
  var import_response_pb = __toESM(require_response_pb(), 1);

  // src/request.events.ts
  var ProtoRequest = __toESM(require_request_pb(), 1);
  var ProtoRequestEvent = {
    acceptLobbyPeer: ProtoRequest.AcceptLobbyPeer,
    activateSpeakerNotification: ProtoRequest.ActivateSpeakerNotification,
    createDataConsumer: ProtoRequest.CreateDataConsumer,
    closeConsumer: ProtoRequest.CloseConsumer,
    closeProducer: ProtoRequest.CloseProducer,
    closeRoom: ProtoRequest.CloseRoom,
    connectRoom: ProtoRequest.ConnectRoom,
    closeStreamOfLabel: ProtoRequest.CloseStreamOfLabel,
    connectTransport: ProtoRequest.ConnectTransport,
    consume: ProtoRequest.Consume,
    createTransport: ProtoRequest.CreateTransport,
    denyLobbyPeer: ProtoRequest.DenyLobbyPeer,
    kickPeer: ProtoRequest.KickPeer,
    produce: ProtoRequest.Produce,
    produceData: ProtoRequest.ProduceData,
    restartTransportIce: ProtoRequest.RestartTransportIce,
    resumeConsumer: ProtoRequest.ResumeConsumer,
    sendData: ProtoRequest.SendData,
    syncMeetingState: ProtoRequest.SyncMeetingState,
    updatePeerMetadata: ProtoRequest.UpdatePeerMetadata,
    updatePeerPermission: ProtoRequest.UpdatePeerPermission,
    updatePeerRole: ProtoRequest.UpdatePeerRole,
    updateRoomControls: ProtoRequest.UpdateRoomControls,
    updateRoomMetadata: ProtoRequest.UpdateRoomMetadata
  };

  // src/Socket.ts
  var logger2 = mainLogger.createSubLogger("Socket.ts");
  var Socket = class _Socket extends EnhancedEventEmitter {
    /**
     * Socket Instance, Singleton class
     */
    static __instance = null;
    /**
     * Retry count for the socket connection, if the connection is closed abnormally, we try to reconnect 5 times
     */
    __retryCount = 0;
    /**
     * Current connection state of the socket connection
     */
    __connectionState = "uninitialized";
    /**
     * Underlying WebSocket connection, until we dont call Socket.connect(); this will be null
     */
    __ws = null;
    /**
     * Map of all the subscribed events/topics for the socket connection
     */
    __subscribedMap = /* @__PURE__ */ new Map();
    /**
     * Region of the current socket connection, specific to the Local Peer who joined the meeting
     */
    __region = null;
    /**
     * Endpoint of the socket server, this is fetched from the API server
     */
    __ENDPOINT = null;
    /**
     * Flag to enable local development
     */
    isLocalDev = false;
    /**
     * Token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    token = null;
    /**
     * Returns the underlying WebSocket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    get ws() {
      if (!this.__ws) {
        throw new Error("\u{1F534} Socket Not Initialised");
      }
      return this.__ws;
    }
    /**
     * Getter for the region of the current socket connection
     */
    get region() {
      return this.__region;
    }
    /**
     * Returns the current connection state of the socket connection
     */
    get connectionState() {
      return this.__connectionState;
    }
    /**
     * Returns true if the socket connection is connected
     */
    get connected() {
      return this.__ws?.OPEN === 1 && this.connectionState === "connected";
    }
    /**
     * Returns true if the socket connection is connecting
     */
    get connecting() {
      return this.__ws?.CONNECTING === 0 && this.connectionState === "connecting";
    }
    /**
     * Returns true if the socket connection is closed
     */
    get closed() {
      return this.__ws?.CLOSED === 3 || this.__ws?.CLOSING === 2;
    }
    /**
     * Sets the current connection state of the socket connection
     */
    set connectionState(state) {
      logger2.info(`\u{1F50C} WebSocket state changed to ${state}`);
      this.__connectionState = state;
    }
    /**
     * Update the token for this socket
     * @throws `Error` if the token is already set
     */
    setToken(token) {
      if (this.token) {
        throw new Error("\u{1F534} Token Already Set");
      }
      this.token = token;
      this.emit("token-updated", token);
    }
    /**
     * Set a new region for the socket connection
     */
    setRegion(region) {
      this.__region = region;
      this.emit("region-updated", region);
    }
    /**
     * Creates the socket and returns the instance of the socket if already initialized
     * you need to call connect method to connect to the server
     * @param data
     * @returns
     */
    static create() {
      if (!this.__instance) {
        this.__instance = new _Socket();
      }
      return this.__instance;
    }
    /**
     * Returns the instance of the socket connection, throws an error if the connection is not initialized
     * @throws `Error` if the connection is not initialized
     */
    static getInstance() {
      if (!_Socket.__instance) {
        throw new Error(
          "\u{1F534} Socket Instance Not Initialised, You are trying to do something which is not possible"
        );
      }
      return _Socket.__instance;
    }
    constructor() {
      super();
    }
    /**
     *
     */
    __getRegion = async () => {
      const resp = await fetch(
        "https://shinigami.huddle01.com/api/get-geolocation"
      );
      const data = await resp?.json();
      const geolocationdata = GeolocationSchema.safeParse(data);
      if (!geolocationdata.success) {
        throw new Error("\u{1F534} Error While Finding the Region to connect to");
      }
      const region = geolocationdata.data.globalRegion;
      return region;
    };
    enableLocalDev = () => {
      this.isLocalDev = true;
    };
    /**
     * Connect to the socket server using the token
     * @param data - `{ token: string }`
     */
    connect = async (data) => {
      if (!_Socket.__instance) {
        throw new Error("\u{1F534} Socket Instance Not Initialised");
      }
      if (!this.token) {
        this.setToken(data.token);
      }
      if (this.connectionState === "connected") {
        logger2.error("\u{1F534} Socket Already Connected");
        return _Socket.__instance;
      }
      if (this.connectionState === "connecting") {
        logger2.error("\u{1F534} Socket Already Connecting");
        return _Socket.__instance;
      }
      if (this.__ws) {
        logger2.error("\u{1F534} Socket Already Initialized");
        return _Socket.__instance;
      }
      logger2.info("\u{1F50C} Connecting to the socket server");
      if (!this.__region) {
        const region = await this.__getRegion();
        this.__region = region;
      }
      const url = await this.__getConfigUrl(data.token, this.__region);
      this.connectionState = "connecting";
      this.emit("connecting");
      this.__ws = new WebSocket(url);
      this.__ws.binaryType = "arraybuffer";
      this.__ws.onmessage = this.__handleIncomingMessage;
      this.__registerSocketEvents(this.ws);
      const socketConnectionPromise = new Promise((resolve, reject) => {
        const handleSuccess = () => {
          logger2.info("\u2705 WebSocket Connection Established Promise Resolved");
          handleRemoveListeners();
          resolve();
        };
        const handleClose = () => {
          logger2.error(
            "\u{1F534} Error Connecting WebSocket, Closing the Connection, Try Again."
          );
          handleRemoveListeners();
          reject(
            new Error(
              "\u274C Error Connecting WebSocket, Closing the Connection, Try Again."
            )
          );
        };
        const handleRemoveListeners = () => {
          this.off("connected", handleSuccess);
          this.off("closed", handleClose);
        };
        this.once("connected", handleSuccess);
        this.once("closed", handleClose);
      });
      await socketConnectionPromise;
      return _Socket.__instance;
    };
    /**
     * Closes the underlying socket connection, and clears all the event listeners and subscriptions to events as well as
     * any other information related to the connection.
     * @param code `{ ESocketCloseCode }`
     */
    close = (code, reconnect = false) => {
      if (this.__ws) {
        this.__ws.onmessage = null;
      }
      const reason = import_socket.SocketCloseReason[code];
      const isNative = navigator?.product === "ReactNative";
      if (code >= 3e3 && code <= 4999 || code === 1e3 || // 1001 is going_away, which is the code for all server closes in react-native but could also be a cloudflare close,
      // if reconnect is true then cloudflare has dropped the connection so try reconnecting in both web and mobile
      //
      code === 1001 && isNative && !reconnect) {
        logger2.info(`\u{1F534} Closing the WebSocket Connection, ${code} ${reason}`);
        this.__ws?.close(code, reason);
        this.__ws = null;
        this.token = null;
        this.__ENDPOINT = null;
        this.emit("token-updated", null);
        this.connectionState = "closed";
        this.emit("closed", code);
        logger2.info("\u{1F50C} WebSocket Connection closed");
        return;
      }
      this.__ws?.close();
      if (this.__ws) {
        this.__unregisterSocketEvents(this.ws);
      }
      this.__ws = null;
      if (code === import_socket.ESocketCloseCode.ABNORMAL_CLOSURE || reconnect) {
        logger2.info(
          "\u{1F50C} Socket Connection closed abnormally, Trying to Reconnect",
          {
            code,
            reason
          }
        );
        if (this.__retryCount < 7) {
          const delay = 2 ** this.__retryCount * 1e3;
          setTimeout(() => {
            if (this.token) {
              try {
                logger2.info(
                  "\u{1F514} Trying to reconnect, Attempt:",
                  this.__retryCount
                );
                this.connectionState = "reconnecting";
                this.emit("reconnecting");
                this.connect({ token: this.token }).then(() => {
                  if (this.__retryCount > 0) {
                    this.emit("reconnected");
                  }
                  this.__retryCount = 0;
                }).catch(() => {
                  if (this.__retryCount === 7) {
                    logger2.error("All Reconnection Attempt failed");
                  }
                });
              } catch (err) {
                logger2.error(`Reconnection Attempt ${this.__retryCount} failed`);
              }
            }
          }, Math.min(delay, 2e4));
          this.__retryCount++;
        } else {
          logger2.error(
            "\u{1F534} Socket connection closed abnormally, reconnecting failed"
          );
          this.close(import_socket.ESocketCloseCode.CONNECTION_EXPIRED);
        }
      } else {
        logger2.info("\u{1F50C} Socket Connection closed", code, reason);
        this.connectionState = "closed";
        this.emit("closed", code);
      }
    };
    /**
     * Publish a message to the server using the socket connection based on some events/topics
     */
    publish = (event, data) => {
      try {
        const message = new import_request_pb.Request({
          request: {
            case: event,
            value: new ProtoRequestEvent[event](data)
          }
        });
        const binaryData = message.toBinary();
        this.ws.send(binaryData);
      } catch (error) {
        logger2.error("\u{1F534} Error While Sending the Message", error);
      }
    };
    /**
     * Subscribe to a specific event/topic from the server
     */
    subscribe = (event, fn) => {
      if (this.__subscribedMap.has(event)) {
        logger2.warn("\u26A0\uFE0F Overriding existing event handler");
      }
      this.__subscribedMap.set(event, fn);
    };
    /**
     * Get the config url for the socket connection based on the token and region
     * @param token Local Peer specific meeting token
     * @param region Local Peer specific region
     * @returns
     */
    async __getConfigUrl(token, region) {
      if (this.__ENDPOINT) {
        return this.__ENDPOINT;
      }
      const apiServerUrl = this.isLocalDev ? "http://localhost:8000/api/v1" : "https://apira.huddle01.media/api/v1";
      const res = await fetch(`${apiServerUrl}/getSushiUrl`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          authorization: `Bearer ${token}`
        }
      });
      if (!res.ok) {
        throw new Error("\u{1F534} Error While Fetching the Url");
      }
      const { url, sessionId } = await res.json();
      this.__ENDPOINT = url.replace("https://", "wss://").replace("http://", "ws://");
      const wssAddress = `${this.__ENDPOINT}/ws`;
      const wsAddress = `${wssAddress}?${[
        `token=${token}`,
        `version=${2}`,
        `region=${region}`,
        `sessionId=${sessionId}`
      ].join("&")}`;
      this.__ENDPOINT = wsAddress;
      return wsAddress;
    }
    /**
     * !Important
     * Handle the incoming message from the server based on the events received from the server and call the subscribed event handler
     */
    __handleIncomingMessage = (event) => {
      try {
        const eventData = new Uint8Array(event.data);
        const msg = import_response_pb.Response.fromBinary(eventData).Response;
        logger2.debug("\u{1F4E8} Incoming message", msg);
        const eventName = msg.case;
        if (eventName === void 0) {
          throw new Error("\u{1F534} Can't find the event name, Found: { undefined }");
        }
        const data = JSON.parse(JSON.stringify(msg.value));
        logger2.info("\u{1F4E8} Incoming message event name: ", eventName);
        const fn = this.__subscribedMap.get(eventName);
        if (fn) {
          fn(data);
        }
      } catch (error) {
        logger2.error("\u{1F534} Error: Handling Incoming Message", error);
      }
    };
    __handleSocketError = (ev) => {
      logger2.error("\u274C Socket connection error", ev);
    };
    /**
     * @description Handle the socket close event which is sent by the server
     * @param ev CloseEvent
     */
    __handleSocketClose = async (ev) => {
      logger2.info("\u{1F514} Socket connection closed emitted", ev);
      const code = ev.code;
      const reason = ev.reason;
      const isCloudflareClose = reason?.toLowerCase().includes("cloudflare");
      this.close(code, isCloudflareClose);
    };
    /**
     * @description Handle the socket open event which is sent after the connection is established with the server
     * @param ev Event
     */
    __handleSocketOpen = (ev) => {
      logger2.debug("WebSocket Connection Open", ev);
      this.connectionState = "connected";
      this.emit("connected");
    };
    /**
     * @description Register the socket events
     * @param ws WebSocket
     */
    __registerSocketEvents = (ws) => {
      ws.onerror = this.__handleSocketError;
      ws.onclose = this.__handleSocketClose;
      ws.onopen = this.__handleSocketOpen;
    };
    /**
     * @description Unregister the socket events
     * @param ws WebSocket
     */
    __unregisterSocketEvents = (ws) => {
      ws.onerror = null;
      ws.onclose = null;
      ws.onopen = null;
    };
  };
  var Socket_default = Socket;

  // src/Permissions.ts
  var logger3 = mainLogger.createSubLogger("Permissions");
  var Permissions = class _Permissions extends EnhancedEventEmitter {
    /**
     * Get the Singleton Instance of the Permissions Class.
     */
    static __instance;
    /**
     * Admin Access of the Room.
     */
    __admin = false;
    /**
     * Can Consume Media Stream of the Room from RemotePeers;
     */
    __canConsume = false;
    /**
     * Can Produce Media Stream to the Room
     */
    __canProduce = true;
    /**
     * Allowed Sources to Produce Media Stream to the Room
     */
    __canProduceSources = {
      cam: true,
      mic: true,
      screen: true
    };
    /**
     * Can Send Data to the Room, e.g. Chat Messages, update of avatar, name etc. to the room
     */
    __canSendData = false;
    /**
     * Can Receive Data from the Room, e.g. Chat Messages, update of avatar, name etc. from other Remote Peers.
     */
    __canRecvData = false;
    /**
     * Can Update Metadata of the Room, e.g. DisplayName, Avatar, etc.
     */
    __canUpdateMetadata = false;
    /**
     * Custom Role of the Peer in the Room.
     */
    __role = null;
    /**
     * Getter for the role of the peer.
     */
    get role() {
      return this.__role;
    }
    set role(role) {
      this.__role = role;
    }
    /**
     * Get the Access Control List ( acl ) of the Local Peer in the Room.
     */
    get acl() {
      return {
        admin: this.__admin,
        canConsume: this.__canConsume,
        canProduce: this.__canProduce,
        canProduceSources: this.__canProduceSources,
        canSendData: this.__canSendData,
        canRecvData: this.__canRecvData,
        canUpdateMetadata: this.__canUpdateMetadata
      };
    }
    /**
     * Update the Permissions of the Local Peer in the Room. This will emit an event `updated` with the updated permissions.
     *
     * `NOTE: If the Peer is not an admin, then the permissions will not be updated on the server`
     */
    updatePermissions(permissions) {
      logger3.info("\u{1F514} Updating Permissions", permissions);
      this.__admin = permissions.admin ?? this.__admin;
      this.__canConsume = permissions.canConsume ?? this.__canConsume;
      this.__canProduce = permissions.canProduce ?? this.__canProduce;
      this.__canProduceSources = permissions.canProduceSources ?? this.__canProduceSources;
      this.__canSendData = permissions.canSendData ?? this.__canSendData;
      this.__canRecvData = permissions.canRecvData ?? this.__canRecvData;
      this.__canUpdateMetadata = permissions.canUpdateMetadata ?? this.__canUpdateMetadata;
    }
    static createInstance() {
      if (_Permissions.__instance)
        return _Permissions.__instance;
      _Permissions.__instance = new _Permissions();
      return _Permissions.__instance;
    }
    static getInstance() {
      if (!_Permissions.__instance) {
        throw new Error("Permissions Instance not created yet.");
      }
      return _Permissions.__instance;
    }
    constructor() {
      super();
    }
    reset() {
      this.__admin = false;
      this.__canConsume = false;
      this.__canProduce = true;
      this.__canProduceSources = {
        cam: true,
        mic: true,
        screen: true
      };
      this.__canSendData = false;
      this.__canRecvData = false;
      this.__canUpdateMetadata = false;
      this.__role = null;
    }
  };
  var checkPermissions = (permission) => {
    return {
      validate: (fn) => {
        return (...args) => {
          const peerPermission = Permissions.getInstance().acl;
          if (permission.admin && !peerPermission.admin) {
            throw new Error("Admin Access Required.");
          }
          if (permission.canConsume && !peerPermission.canConsume) {
            throw new Error("Can Consume Access Required.");
          }
          if (permission.canProduce && !peerPermission.canProduce) {
            throw new Error("Can Produce Access Required.");
          }
          if (permission.canProduceSources?.cam && !peerPermission.canProduceSources.cam) {
            throw new Error("Produce Sources Access Required. for 'cam'");
          }
          if (permission.canProduceSources?.mic && !peerPermission.canProduceSources.mic) {
            throw new Error("Produce Sources Access Required. for 'mic'");
          }
          if (permission.canProduceSources?.screen && !peerPermission.canProduceSources.screen) {
            throw new Error("Produce Sources Access Required. for 'screen'");
          }
          if (permission.canSendData && !peerPermission.canSendData) {
            throw new Error("Can Send Data Access Required.");
          }
          if (permission.canRecvData && !peerPermission.canRecvData) {
            throw new Error("Can Recv Data Access Required.");
          }
          return fn(...args);
        };
      }
    };
  };
  checkPermissions({
    canProduceSources: {
      cam: true,
      mic: true,
      screen: true
    }
  });
  var Permissions_default = Permissions;

  // src/Room.ts
  var logger4 = mainLogger.createSubLogger("Room.ts");
  var Room = class _Room extends EnhancedEventEmitter {
    /**
     * Room Instance, Singleton class
     */
    static __instance = null;
    /**
     * Socket Instance, Singleton class
     */
    __socket = Socket_default.getInstance();
    /**
     * Returns the instance of the socket connection
     */
    get socket() {
      return this.__socket;
    }
    /**
     * Room Id of the current room
     */
    __roomId = null;
    /**
     * session id
     */
    __sessionId = null;
    /**
     * Lobby PeerIds
     */
    __lobbyPeers = /* @__PURE__ */ new Map();
    /**
     * Removed Lobby PeerId from the lobby
     * @param peerId - PeerId of the peer who joined the room
     */
    removeLobbyPeer = (peerId) => {
      this.__lobbyPeers.delete(peerId);
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    };
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    __config = {
      roomLocked: false,
      allowProduce: true,
      allowProduceSources: {
        cam: true,
        mic: true,
        screen: true
      },
      allowConsume: true,
      allowSendData: true
    };
    /**
     * Auto consume flag, if set to true, Peers Joining the Room will automatically consume the media streams of the remote peers
     *
     * @default true
     *
     * @remarks - This flag is used by the `useRoom` hook to automatically consume the media streams of the remote peers,
     * - if set to false, the user will have to manually consume the media streams of the remote peers
     * using the `consume` method of the `LocalPeer` instance `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    autoConsume = true;
    /**
     * Handler for the ActiveSpeaker
     */
    __activeSpeakers = null;
    /**
     * Get the active speakers instance
     */
    get activeSpeakers() {
      return this.__activeSpeakers;
    }
    set activeSpeakers(activeSpeakers) {
      if (this.__activeSpeakers) {
        logger4.warn(
          "Active Speakers is already set, Ignoring the new active speakers, end this room and create a new room"
        );
      }
      this.__activeSpeakers = activeSpeakers;
    }
    /**
     * State of the Room
     */
    __state = "idle";
    /**
     * Room Stats
     */
    __stats = {
      startTime: 0
    };
    /**
     * Set the state of the room
     */
    set state(newState) {
      if (this.state !== newState) {
        this.__state = newState;
      }
    }
    /**
     * State of the room
     */
    get state() {
      return this.__state;
    }
    /**
     * Get the lobby peers in the form of map
     * @returns - Map of Lobby PeerIds, with the metadata, {peerId ==> {peerId, metadata}}
     * @example
     * ```ts
     * const lobbyPeers = room.lobbyPeersMap;
     *
     * for (const [peerId, metadata] of lobbyPeers) {}
     *
     * ```
     */
    get lobbyPeersMap() {
      return this.__lobbyPeers;
    }
    /**
     * Get lobby peers in the form of array
     */
    get lobbyPeerIds() {
      return Array.from(this.__lobbyPeers.keys());
    }
    /**
     * Get lobby peers in the form of array
     * @returns - Array of Lobby PeerIds
     */
    get lobbyPeers() {
      return this.__lobbyPeers;
    }
    /**
     * Set lobby peers in the form of map
     * `NOTE: This function is an internal function of the SDK, Used to emit evnts based on changes`
     */
    set lobbyPeersMap(peers) {
      this.__lobbyPeers = peers;
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Get Room Stats
     */
    get stats() {
      return this.__stats;
    }
    /**
     * Set Room Stats
     */
    set stats(stats) {
      this.__stats = stats;
    }
    /**
     * Get
     * @returns
     */
    getLobbyPeerMetadata = (peerId) => {
      const lobbyPeer = this.lobbyPeers.get(peerId);
      let metadata = {};
      if (lobbyPeer?.metadata) {
        metadata = JSON.parse(lobbyPeer.metadata);
      }
      return {
        peerId,
        metadata
      };
    };
    /**
     * Set lobby peers in the form of array
     */
    set newlobbyPeers(peers) {
      for (const peer of peers) {
        this.__lobbyPeers.set(peer.peerId, peer);
      }
      this.emit("lobby-peers-updated", this.lobbyPeerIds);
    }
    /**
     * Room Config Object
     * - `allowProduce`: Allow non-admin Peers in the Room to produce Media Streams
     * - `allowConsume`: Allow non-admin Peers in the Room to consume Media Streams
     * - `allowSendData`: Allow non-admin Peers in the Room to send data message
     * - `roomLocked`: If the room is locked
     */
    get config() {
      return this.__config;
    }
    set config(config) {
      this.__config = config;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    remotePeers = /* @__PURE__ */ new Map();
    /**
     * Metadata of the room.
     */
    __metadata = "{}";
    /**
     * Setter function for the metadata of the room
     * `Note: This will not update the metadata of the room, this is just a setter function for the metadata`
     * `To notify everyone in the room about the metadata change, use the updateMetadata function`
     */
    set metadata(metadata) {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", parse);
    }
    /**
     * Get the metadata of the room
     */
    getMetadata = () => {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    };
    /**
     * Update Metadata of the room
     */
    updateMetadata = checkPermissions({}).validate(
      (data) => {
        try {
          if (this.state === "closed" || this.state === "failed" || this.state === "left") {
            logger4.error(
              "\u274C Cannot Update Metadata, You have not joined the room yet"
            );
            return;
          }
          const metadata = JSON.stringify(data);
          this.metadata = metadata;
          this.socket.publish("updateRoomMetadata", {
            metadata
          });
        } catch (error) {
          logger4.error("\u274C Error Updating Metadata");
          logger4.error(error);
        }
      }
    );
    /**
     * Create a new Room Instance if not created, else return the existing Room Instance
     *
     * @returns - Room Instance
     */
    static create(data) {
      if (_Room.__instance) {
        return _Room.__instance;
      }
      logger4.debug({ data });
      _Room.__instance = new _Room(data);
      return _Room.__instance;
    }
    /**
     * Get the Room Instance if its not initialized it will throw an error
     * @returns - Room Instance
     * @throws { Error } If the Room Instance is not initialized
     */
    static getInstance = () => {
      if (!_Room.__instance) {
        throw new Error("\u274C Room Instance Not Initialized");
      }
      return _Room.__instance;
    };
    /**
     * RoomId of the currently joined room.
     */
    get roomId() {
      return this.__roomId;
    }
    /**
     *
     */
    get sessionId() {
      return this.__sessionId;
    }
    set roomId(roomId) {
      if (this.__roomId) {
        logger4.warn(
          "RoomId is already set, Ignoring the new roomId, end this room and create a new room"
        );
        return;
      }
      this.__roomId = roomId;
    }
    set sessionId(sessionId) {
      if (this.__sessionId) {
        logger4.warn(
          "sessionId is already set, Ignoring the new sessionId, end this room and create a new room"
        );
        return;
      }
      this.__sessionId = sessionId;
    }
    /**
     * Returns the PeerIds of the remote peers
     */
    get peerIds() {
      return Array.from(this.remotePeers.keys());
    }
    /**
     * @description Update room control booleans - roomLocked, allowProduce, allowConsume, allowSendData
     * @param data: TNewRoomControls
     */
    updateRoomControls = checkPermissions({
      admin: true
    }).validate((data) => {
      logger4.info("\u{1F514} Updating Room Controls", data);
      this.config[data.type] = data.value;
      this.emit("room-controls-updated");
      if (data.type === "allowProduceSources") {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "produceSourcesControl",
            value: data
          }
        });
      } else {
        this.socket.publish("updateRoomControls", {
          control: {
            case: "roomControl",
            value: data
          }
        });
      }
    });
    /**
     * Close a particular stream of remote peers
     *  @param data: { label: string; peerIds?: string[] }
     *  @param label: Label of the stream
     *  @param peerIds: PeerIds of the remote peers, if not provided, it will close the stream of all the remote peers
     */
    closeStreamOfLabel = checkPermissions({}).validate(
      (data) => {
        logger4.info("\u{1F514} Closing Stream of Label", data);
        this.socket.publish("closeStreamOfLabel", data);
      }
    );
    /**
     * Mute everyone in the room. This will close the audio stream of all the remote peers who dont have admin permissions
     *
     * `NOTE: This will target all the audio stream in the room with the label "audio"`
     */
    muteEveryone = checkPermissions({ admin: true }).validate(() => {
      logger4.info("\u{1F514} Muting Everyone");
      this.socket.publish("closeStreamOfLabel", {
        label: "audio"
      });
    });
    /**
     * Returns the Remote Peer with the given peerId is present in the room. Returns null if the peer is not present in the room.
     *
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @return - null if the peer is not present in the room
     */
    remotePeerExists = (peerId) => {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        return null;
      }
      return peer;
    };
    /**
     * Returns the Remote Peer if present in room.
     * @param peerId - PeerId of the remote peer
     * @returns - RemotePeer Instance
     * @throws { Error } If the Remote Peer is not found
     */
    getRemotePeerById(peerId) {
      const peer = this.remotePeers.get(peerId);
      if (!peer) {
        throw new Error(`Remote Peer Not Found, peerId: ${peerId}`);
      }
      return peer;
    }
    constructor(data) {
      super();
      if (data?.autoConsume !== void 0) {
        this.autoConsume = data.autoConsume;
      }
    }
    /**
     * Connects to the room and returns the instance of the room
     * @throws { Error } If the socket connection is not connected, or if the socket connection is connecting
     */
    connect = () => {
      if (_Room.__instance === null) {
        throw new Error("Room Instance Not Initialized");
      }
      if (!this.socket.connected) {
        throw new Error("Socket is Not Connected");
      }
      if (this.socket.connecting) {
        throw new Error("Socket is Connecting, Wait for it to be connected");
      }
      if (!this.roomId) {
        throw new Error("Room Id is required to connect to the room");
      }
      logger4.info("\u{1F514} Connecting to the room");
      this.socket.publish("connectRoom", { roomId: this.roomId });
      this.__state = "connecting";
      this.emit("room-connecting");
      return _Room.__instance;
    };
    /**
     * Admit a Peer to the room who is in the lobby
     */
    admitPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("acceptLobbyPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error admitting peer", error);
        }
      }
    );
    /**
     * Denies the peer from joining the room, who is in the lobby
     */
    denyPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.removeLobbyPeer(peerId);
          this.socket.publish("denyLobbyPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * kick peer from room with respective peerId
     */
    kickPeer = checkPermissions({ admin: true }).validate(
      (peerId) => {
        try {
          this.socket.publish("kickPeer", { peerId });
        } catch (error) {
          logger4.error("\u{1F534} Error denying peer", error);
        }
      }
    );
    /**
     * @deprecated Use `leaveRoom` from `huddleClient` instead
     * closing the room for the current user, room will keep on running for the remote users
     */
    close = (reason) => {
      try {
        logger4.info("\u{1F534} Leaving the room");
        this.__roomId = null;
        this.remotePeers.clear();
        this.lobbyPeers.clear();
        this.metadata = "{}";
        this.state = "left";
        this.emit("room-closed", { reason: reason || "LEFT" });
      } catch (error) {
        logger4.error("Error: Leaving the Room");
      }
    };
  };
  var Room_default = Room;

  // src/RemotePeer.ts
  var logger5 = mainLogger.createSubLogger("RemotePeer");
  var RemotePeer = class extends EnhancedEventEmitter {
    /**
     * peerId of the remote peer, this is unique for each peer
     */
    peerId;
    /**
     * Stores the Metadata for the Remote Peer.
     */
    __metadata = "{}";
    /**
     * Stores the Role of the Remote Peer.
     */
    __role = null;
    /**
     * Labels are the unique identifier for the media stream that the remote peer is producing
     */
    __labelsToProducerId = /* @__PURE__ */ new Map();
    /**
     * Returns the list of labels that the remote peer is producing
     */
    get labels() {
      return Array.from(this.__labelsToProducerId.keys());
    }
    get producerIds() {
      return Array.from(this.__labelsToProducerId.values()).map(
        (labelData) => labelData.producerId
      );
    }
    /**
     * Role of the Peer.
     * @returns The Role of the Peer which if passed in the options when creating the token
     */
    get role() {
      if (!this.__role)
        return null;
      return this.__role;
    }
    set role(role) {
      this.__role = role;
      this.emit("role-updated", {
        role
      });
    }
    /**
     * Checks if the remote peer is producing the label
     * @param label - Label to check if the remote peer is producing
     * @returns - Returns true if the remote peer is producing the label
     */
    hasLabel(label) {
      return this.__labelsToProducerId.has(label);
    }
    /**
     * Returns the data associated to the label, this is the producerId
     *
     * @returns
     * producerId - Unique identifier for the producer
     */
    getLabelData(label) {
      return this.__labelsToProducerId.get(label);
    }
    /**
     * Get the associated consumer for the label
     * @param label - Unique identifier for the consumer e.g. `video` | `audio` | `screen-share-video` | string
     * @returns Consumer | null
     */
    getConsumer(label) {
      try {
        const localPeer = LocalPeer_default.getInstance();
        const consumer = localPeer.recvTransport.getConsumer({
          label,
          peerId: this.peerId
        });
        return consumer;
      } catch (error) {
        return null;
      }
    }
    /**
     * Returns the metadata associated to the RemotePeer
     */
    getMetadata() {
      return this.__metadata;
    }
    /**
     * Setter function to update the Remote Peer Metadata
     *
     * `NOTE: This will NOT notify other Remote Peers of the update`
     */
    set metadata(data) {
      this.__metadata = data;
      this.emit("metadata-updated", {
        metadata: data
      });
    }
    /**
     * Update the Permissions of the Remote Peer in the Room. This will emit an event `updated` with the updated permissions.
     */
    updatePermissions = checkPermissions({
      admin: true
    }).validate(async (data) => {
      try {
        logger5.info("\u{1F514} Updating Permissions", data);
        const localPeer = LocalPeer_default.getInstance();
        const socket = localPeer.socket;
        socket.publish("updatePeerPermission", {
          peerId: this.peerId,
          permissions: data
        });
      } catch (error) {
        logger5.error("\u{1F514} Error Updating Permissions");
        logger5.error(error);
      }
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     */
    updateRole = checkPermissions({
      admin: true
    }).validate((data) => {
      try {
        logger5.info("\u{1F514} Updating Peer Role", data);
        if (data.role === this.__role) {
          logger5.warn("\u{1F514} Role is already set to", data.role);
          return;
        }
        const localPeer = LocalPeer_default.getInstance();
        const socket = localPeer.socket;
        socket.publish("updatePeerRole", {
          peerId: this.peerId,
          role: data.role
        });
      } catch (error) {
        logger5.error("\u{1F514} Error Updating Role", data);
        logger5.error(error);
      }
    });
    /**
     * Removes all the states of the remote peer and clears memory;
     *
     * `NOTE`: You need to close consumers using the `recvTransport.closeConsumer` of the local peer
     */
    close = () => {
      logger5.info("Closing Remote Peer");
      this.removeAllListeners();
    };
    constructor(data) {
      super();
      this.peerId = data.peerId;
      if (data.metadata) {
        this.metadata = JSON.parse(data.metadata);
      }
      if (data.role) {
        this.__role = data.role;
      }
    }
    /**
     * @protected
     * Add a New Label to the Remote Peer and associate it with the ProducerId
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to add the new label `label` and the `producerId` to associate it with
     */
    _addLabelData = async (data) => {
      const { label, producerId } = data;
      this.__labelsToProducerId.set(label, { producerId });
      try {
        const autoConsume = Room_default.getInstance().autoConsume;
        const localPeer = LocalPeer_default.getInstance();
        if (autoConsume) {
          logger5.debug(
            "AUTO CONSUME IS ENABLED, CONSUMING THE PRODUCER'S STREAM"
          );
          localPeer.consume({
            appData: {},
            label,
            peerId: this.peerId
          });
        } else {
          this.emit("stream-available", {
            label,
            labelData: {
              producerId
            }
          });
        }
      } catch (error) {
        logger5.error("\u274C Error While Consuming", {
          label,
          peerId: this.peerId
        });
        logger5.error(error);
        this.emit("stream-available", {
          label,
          labelData: {
            producerId
          }
        });
      }
    };
    /**
     * @protected
     * Remove a Label from the Remote Peer and emit a `stream-closed` event
     *
     * `NOTE: This is used internally by the Peer`
     *
     * @param data - Data to remove the label from the Remote Peer
     */
    _removeLabelData = (label, reason) => {
      this.__labelsToProducerId.delete(label);
      this.emit("stream-closed", {
        label,
        reason
      });
    };
  };
  var RemotePeer_default = RemotePeer;

  // src/Consumer.ts
  var logger6 = mainLogger.createSubLogger("Consumer");
  var Consumer = class _Consumer extends EnhancedEventEmitter {
    /**
     * ProducerId of the Consumer, this is the id of the Media Entity which is responsible for producing the media in the room.
     */
    producerId;
    /**
     * PeerId of the Producer, this is the peerId of the Peer which is responsible for producing the media in the room.
     */
    producerPeerId;
    /**
     * Label of the Consumer, this is the label of the Media Entity which is responsible for producing the media in the room.
     */
    label;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     */
    __consuming = false;
    /**
     * Flag to check if the Consumer is consuming a media, if `true` then the Consumer is consuming a media.
     *
     * @default false
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consuming() {
      return this.__consuming;
    }
    /**
     * mediasoupConsumer instance, this is the instance of the mediasoupConsumer which is responsible for consuming the media in the room.
     * @remarks This is a private property and should not be accessed directly.
     *
     * Every Consumer is created without a mediasoupConsumer, when the peer starts to consume the media, the mediasoupConsumer is set.
     */
    #mediasoupConsumer = null;
    /**
     * Getter for the id for the mediaSoupConsumer, which is also the id of the Consumer for the RemotePeer.
     */
    get id() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     *
     * @param consumer Sets the mediasoupConsumer for the Consumer
     */
    setMediaSoupConsumer(consumer) {
      if (this.consuming) {
        throw new Error("Consumer is already consuming");
      }
      if (this.#mediasoupConsumer) {
        throw new Error("Consumer already has a mediasoupConsumer");
      }
      this.#mediasoupConsumer = consumer;
      this.__consuming = true;
    }
    /**
     * Getter for the mediasoupConsumer id, which is also the id of the Consumer for the RemotePeer. it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get consumerId() {
      return this.#mediasoupConsumer?.id;
    }
    /**
     * Get the Track of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get track() {
      return this.#mediasoupConsumer?.track;
    }
    /**
     * Get the kind of the Consumer, it is only available when the Consumer is consuming a media.
     *
     * @remarks
     * There are two ways a Peer can Consume any media produced in the room.
     * - Automatically consume the media streams of the remote peers by setting the `autoConsume` flag to `true` in the `Room`.
     * - Using the `consume` function inside the `LocalPeer` instance. `localPeer.consume({ peerId, label: "video", appData: {} });`
     */
    get kind() {
      return this.#mediasoupConsumer?.kind;
    }
    /**
     * If the Consumer is paused, it is only available when the Consumer is consuming a media.
     *
     * if paused the user is not consuming any media for the given producerId.
     */
    get paused() {
      return this.#mediasoupConsumer?.paused;
    }
    /**
     * AppData of the Consumer, it is only available when the Consumer is consuming a media.
     */
    get appData() {
      return this.#mediasoupConsumer?.appData;
    }
    /**
     * State of a Consumer is defined by the following:
     * - `playable` - The Consumer is ready to play the media.
     * - `unavailable` - The Consumer is not available to play the media. This can happen when the Consumer is closed or paused.
     * - `paused` - The Consumer is paused and is not playing the media.
     * - `available` - The Consumer is available to play the media. Peer can consume the media by using `localPeer.consume({ peerId, label: "video", appData: {} });` after which the state will change to `playable`.
     */
    get state() {
      if (this?.consuming)
        return "playable";
      if (this?.paused)
        return "paused";
      return "available";
    }
    /**
     * Get the stats of the Consumer, it is only available when the Consumer is consuming a media.
     * It generates the stats for the Consumer using the `getStats` method of the mediasoupConsumer.
     * @returns - RTCStatsReport | null
     */
    getStats = async () => {
      const stats = await this.#mediasoupConsumer?.getStats();
      return stats;
    };
    /**
     * Resume the consumer, if the state of the consumer is `paused`.
     */
    resume = () => {
      this.#mediasoupConsumer?.resume();
    };
    /**
     * Removes all the eventListeners attached to the Consumer.
     */
    removeListeners = () => {
      this.removeAllListeners();
    };
    /**
     * Creates a Consumer instance. This is a static method and should be called using `Consumer.create({ producerPeerId, producerId, label })`.
     */
    static create = (data) => {
      try {
        const consumer = new _Consumer(data);
        return consumer;
      } catch (error) {
        logger6.error(error);
        throw new Error("\u274C Error creating Consumer");
      }
    };
    close = () => {
      try {
        this.#mediasoupConsumer?.close();
        this.__consuming = false;
        this.emit("closed");
        this.removeAllListeners();
      } catch (error) {
        logger6.error("\u274C Error Closing Consumer");
        logger6.error({
          consumerId: this.consumerId,
          producerId: this.producerId
        });
      }
    };
    constructor(data) {
      super();
      this.producerPeerId = data.producerPeerId;
      this.producerId = data.producerId;
      this.label = data.label;
    }
  };
  var Consumer_default = Consumer;

  // src/helpers/index.ts
  var getMediaStreamKind = (stream) => {
    let kind = null;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === "audio") {
        kind = "audio";
        break;
      } else if (track.kind === "video") {
        kind = "video";
        break;
      }
    }
    if (!kind) {
      throw new Error("Stream Kind Not Found");
    }
    return kind;
  };
  var getMediaDeviceKind = (track) => {
    if (track.kind === "audio") {
      return "mic";
    } else if (track.kind === "video") {
      const settings = track.getSettings();
      if (settings.displaySurface) {
        return "screen";
      } else {
        return "cam";
      }
    }
    return "cam";
  };
  var getMediaTrack = (data) => {
    const { stream, kind } = data;
    const tracks = stream.getTracks();
    for (const track of tracks) {
      if (track.kind === kind) {
        return track;
      }
    }
    throw new Error("Track Not Found");
  };
  var estimateSize = (obj) => {
    const str = JSON.stringify(obj);
    return new TextEncoder().encode(str).length;
  };

  // src/common-js/EnhancedMap.ts
  var defaultCompareFn = (a, b) => {
    if (a < b) {
      return false;
    }
    if (a > b) {
      return true;
    }
    return false;
  };
  var EnhancedMap = class {
    map;
    compareFn;
    getKey = (a, b) => {
      const key = this.compareFn(a, b) ? `${a}_${b}` : `${b}_${a}`;
      return key;
    };
    get size() {
      return this.map.size;
    }
    get data() {
      return this.map;
    }
    get = (a, b) => {
      const key = this.getKey(a, b);
      const value = this.map.get(key);
      return value;
    };
    set = (a, b, value) => {
      const key = this.getKey(a, b);
      this.map.set(key, value);
      return value;
    };
    delete = (a, b) => {
      const key = this.getKey(a, b);
      return this.map.delete(key);
    };
    clear = () => {
      this.map.clear();
    };
    constructor(data) {
      this.map = /* @__PURE__ */ new Map();
      if (data.compareFn)
        this.compareFn = data.compareFn;
      else
        this.compareFn = defaultCompareFn;
    }
  };

  // src/helpers/ProtooParsing.ts
  var import_rtp_parameters_pb = __toESM(require_rtp_parameters_pb(), 1);
  var parseRouterRtpCapabilities = (rtpCapabilities) => {
    const parsedRouterRtpCapabilites = rtpCapabilities;
    if (parsedRouterRtpCapabilites.codecs)
      for (const codec of parsedRouterRtpCapabilites.codecs) {
        if (codec.parameters) {
          const keys = Object.keys(codec.parameters);
          for (const key of keys) {
            if (key === "apt") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "level-asymmetry-allowed") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "packetization-mode") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "x-google-start-bitrate") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
            if (key === "profile-id") {
              codec.parameters[key] = Number(codec.parameters[key]);
            }
          }
        }
      }
    return parsedRouterRtpCapabilites;
  };
  var parseRtpParameters = (rtpParameters) => {
    const parsedRtpParameters = rtpParameters;
    for (const codec of parsedRtpParameters.codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = Number(codec.parameters[key]);
          }
        }
      }
    }
    if (parsedRtpParameters.encodings) {
      for (const encoding of parsedRtpParameters.encodings) {
        encoding.dtx = false;
        encoding.ssrc = Number(encoding.ssrc);
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        if (encoding.rtx?.ssrc !== void 0) {
          if (Number(encoding.rtx.ssrc) === 0) {
            encoding.rtx = void 0;
          } else {
            encoding.rtx.ssrc = Number(encoding.rtx.ssrc);
          }
        } else {
          encoding.rtx = void 0;
        }
      }
    }
    const headerExtensions = parsedRtpParameters.headerExtensions;
    if (headerExtensions) {
      headerExtensions.map((headerExtension) => {
        headerExtension.encrypt = false;
        headerExtension.parameters = {};
      });
    }
    return parsedRtpParameters;
  };
  var parseToProtoRtpParameters = (rtpParameters) => {
    const protoEncodings = [];
    const codecs = rtpParameters.codecs;
    for (const codec of codecs) {
      if (codec.parameters) {
        const keys = Object.keys(codec.parameters);
        for (const key of keys) {
          if (key === "apt") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "level-asymmetry-allowed") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "packetization-mode") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "x-google-start-bitrate") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
          if (key === "profile-id") {
            codec.parameters[key] = String(codec.parameters[key]);
          }
        }
      }
    }
    const encodings = rtpParameters.encodings;
    if (encodings) {
      for (const encoding of encodings) {
        if (Number.isNaN(encoding.ssrc)) {
          encoding.ssrc = void 0;
        }
        const protoEncoding = new import_rtp_parameters_pb.ProtoEncodings({
          ssrc: encoding.ssrc ? BigInt(encoding.ssrc) : void 0,
          rid: encoding.rid,
          codecPayloadType: encoding.codecPayloadType,
          rtx: {
            ssrc: encoding.rtx?.ssrc ? BigInt(encoding.rtx.ssrc) : void 0
          },
          dtx: encoding.dtx,
          scalabilityMode: encoding.scalabilityMode,
          scaleResolutionDownBy: encoding.scaleResolutionDownBy,
          maxBitrate: encoding.maxBitrate
        });
        protoEncodings.push(protoEncoding);
      }
    }
    return rtpParameters;
  };

  // src/Transport.ts
  var logger7 = mainLogger.createSubLogger("Transport");
  var Transport = class _Transport extends EnhancedEventEmitter {
    /**
     * Peer Id, which handles the peer id.
     */
    peerId;
    /**
     *  MediaSoup Device Instance, which handles the browsers or mobile device init.
     */
    __device;
    /**
     * MediaSoup Transport Instance, which handles the media transport.
     */
    __mediasoupTransport;
    /**
     * Socket Instance, which handles the socket connection.
     */
    __socket;
    /**
     * Map of Producers, which handles the producers. ( Sending out Media Streams )
     *
     * `Mapped with {producerId => Producer}`
     */
    __producers = /* @__PURE__ */ new Map();
    /**
     * Map of DataProducers, which handles the dataProducers. ( Sending out Data )
     *
     * `Mapped with {label => DataProducer}`
     */
    __dataProducers = /* @__PURE__ */ new Map();
    /**
     * Map of DataConsumers, which handles the dataConsumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:label => DataConsumer}`
     */
    __dataConsumers = /* @__PURE__ */ new Map();
    /**
     * Map of Consumers, which handles the consumers. ( Receiving Media Streams )
     *
     * `Mapped with {label:RemotePeerId => Consumer}`
     */
    __consumers = new EnhancedMap({});
    /**
     * Map of Identifiers to Producer Ids, which handles the mapping of identifiers to producer ids.
     *
     * `identifiers` are the unique identifiers for the stream, which is used to identify the stream.
     */
    labelToProducerId = /* @__PURE__ */ new Map();
    /**
     * Transport Type, which handles the transport type. ( `send | recv` )
     */
    transportType;
    /**
     * Pending Producer Tasks, which handles the pending producer tasks.
     * callback function is necessary to be called when the producer is created
     * on the server as well as on the client side.
     */
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    /**
     * Debounce to handle concurrent request to restart Ice. Waits for some time before sending
     * more requests to restart ice.
     */
    __iceRestartDebounce = false;
    get device() {
      return this.__device;
    }
    get mediasoupTransport() {
      return this.__mediasoupTransport;
    }
    get connectionState() {
      return this.__mediasoupTransport.connectionState;
    }
    get producers() {
      return this.__producers;
    }
    get dataProducers() {
      return this.__dataProducers;
    }
    get dataConsumers() {
      return this.__dataConsumers;
    }
    get consumers() {
      return this.__consumers;
    }
    getProducerById(producerId) {
      const producer = this.__producers.get(producerId);
      if (!producer)
        throw new Error("Producer not found");
      return producer;
    }
    removeProducerById(producerId) {
      logger7.info(`\u{1F514} Removing Producer, id: ${producerId}`);
      return this.__producers.delete(producerId);
    }
    /**
     * Get the consumer by label and peerId
     * @param data
     * @returns Consumer | null; Returns null if consumer is not found
     */
    getConsumer = (data) => {
      const consumer = this.__consumers.get(data.label, data.peerId);
      if (!consumer)
        return null;
      return consumer;
    };
    get transport() {
      const transport = this.__mediasoupTransport;
      if (!transport)
        throw new Error("Transport Not Initialized");
      return transport;
    }
    addPendingProducerTask = (data) => {
      const key = `${data.peerId}-${data?.label}`;
      logger7.info("\u{1F514} Adding Pending Producer Task, key", key);
      if (this.__pendingProducerTasks.has(key)) {
        logger7.debug("\u{1F534} Producer Creation is Pending for key: ", key);
        return;
      }
      this.__pendingProducerTasks.set(key, data.callback);
    };
    resolvePendingProducerTask = (data) => {
      const key = `${data.peerId}-${data.label}`;
      logger7.info("\u{1F514} Resolving Pending Producer Task, key", key);
      const callback = this.__pendingProducerTasks.get(key);
      if (!callback) {
        logger7.error("\u{1F534} Producer Creation is not Pending for key: ", key);
        return;
      }
      callback({ id: data.id });
      this.__pendingProducerTasks.delete(key);
    };
    static create = (data) => {
      try {
        logger7.info(
          `\u{1F514} Creating Client Side Transport, type: ${data.transportType}`
        );
        const { transportType, device } = data;
        const payload = {
          id: data.sdpInfo.id,
          iceParameters: data.sdpInfo.iceParameters,
          iceCandidates: data.sdpInfo.iceCandidates,
          iceServers: data.iceServers,
          dtlsParameters: data.sdpInfo.dtlsParameters,
          sctpParameters: data.sdpInfo.sctpParameters,
          proprietaryConstraints: {},
          appData: {}
        };
        const mediasoupTransport = transportType === "send" ? device.createSendTransport(payload) : device.createRecvTransport(payload);
        const transport = new _Transport({
          peerId: data.peerId,
          device: data.device,
          transportType: data.transportType,
          mediasoupTransport
        });
        return transport;
      } catch (error) {
        logger7.error(`\u274C Transport.create(), type: ${data.transportType}`);
        logger7.error(error);
        throw error;
      }
    };
    constructor(data) {
      super();
      this.__socket = Socket_default.getInstance();
      this.__device = data.device;
      this.transportType = data.transportType;
      this.__mediasoupTransport = data.mediasoupTransport;
      this.__mediasoupTransport.on("connectionstatechange", (state) => {
        this.__connectionStateChangeHandler(state);
      });
      this.peerId = data.peerId;
      this.__listenTransportConnect();
      this.__listenTransportProduce();
      if (this.transportType === "send")
        this.__listenTransportDataProduce();
      logger7.info(`\u2705 ${data.transportType} Transport Initialized`);
    }
    __listenTransportConnect = () => {
      this.__mediasoupTransport.on(
        "connect",
        ({ dtlsParameters }, callback, errback) => {
          logger7.info("\u{1F514} Transport Connect Event Called");
          try {
            this.once("connectTransportResponse", () => {
              callback();
            });
            this.__socket.publish("connectTransport", {
              dtlsParameters,
              transportType: this.transportType
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Connect Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    __listenTransportProduce = () => {
      this.__mediasoupTransport.on(
        "produce",
        async ({ kind, rtpParameters, appData }, callback, errback) => {
          logger7.info(`\u{1F514} ${this.transportType} Produce Event Called`);
          try {
            const label = appData?.label;
            if (!label)
              throw new Error("\u{1F534} Stream Identifier Not Found");
            const parsedProtoRtpParameters = parseToProtoRtpParameters(rtpParameters);
            this.__socket.publish("produce", {
              rtpParameters: parsedProtoRtpParameters,
              kind,
              label,
              appData,
              paused: false
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Produce Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    __listenTransportDataProduce = () => {
      logger7.info(`\u{1F514} producedata: ${this.transportType} `);
      this.__mediasoupTransport.on(
        "producedata",
        async ({ label, appData, sctpStreamParameters, protocol }, callback, errback) => {
          logger7.info(`\u{1F514} ${this.transportType} Produce Data Event Called`);
          try {
            this.__socket.publish("produceData", {
              transportId: this.__mediasoupTransport.id,
              sctpStreamParameters,
              label,
              protocol,
              appData
            });
            this.addPendingProducerTask({
              peerId: this.peerId,
              label,
              callback
            });
          } catch (error) {
            logger7.error("\u274C Error Transport Produce Data Event");
            logger7.error(error);
            errback(error);
          }
        }
      );
    };
    produce = async (data) => {
      const kind = getMediaStreamKind(data.stream);
      const track = getMediaTrack({ stream: data.stream, kind });
      logger7.info(`\u{1F514} Produce Called for kind: ${kind}, label: ${data.label}`);
      try {
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        if (!this.__device.canProduce(kind)) {
          throw new Error(`Device Cannot produce ${kind}`);
        }
        if (this.transportType !== "send") {
          throw new Error(`Cannot produce on ${this.transportType} transport`);
        }
        const codecs = this.__device.rtpCapabilities?.codecs;
        if (!codecs) {
          throw new Error("\u274C Device RTP Capabilities not found");
        }
        const codecViaMediaType = {
          video: codecs.find(
            (codec) => codec.mimeType.toLowerCase() === "video/h264"
          ),
          "screen-share-video": codecs.find(
            (codec) => codec.mimeType.toLowerCase() === "video/h264"
          ),
          audio: void 0
        };
        const mediaType = data.label === "screen-share-video" ? "screen-share-video" : kind;
        const mediasoupProducer = await this.__mediasoupTransport.produce({
          track,
          encodings: encodingViaMediaType[mediaType],
          codecOptions: codecOptionsViaKind[kind],
          codec: codecViaMediaType[mediaType],
          stopTracks: data.stopTrackOnClose,
          zeroRtpOnPause: true,
          disableTrackOnPause: true,
          appData: {
            ...data.appData,
            producerPeerId: this.peerId
          }
        });
        this.__producers.set(mediasoupProducer.id, mediasoupProducer);
        this.labelToProducerId.set(data.label, mediasoupProducer.id);
        logger7.info(`\u{1F514} Producer Created sucessfully with label : ${data.label}`);
        return mediasoupProducer;
      } catch (error) {
        logger7.error("\u274C Error Transport Produce Event");
        logger7.error(error);
        throw error;
      }
    };
    produceData = async (data) => {
      logger7.info(`\u{1F514} Produce Data Called for label: ${data.label}`);
      try {
        if (this.transportType !== "send") {
          throw new Error(`Cannot produce on ${this.transportType} transport`);
        }
        const dataProducer = await this.__mediasoupTransport.produceData({
          label: data.label,
          appData: {
            ordered: true,
            ...data.appData,
            producerPeerId: this.peerId,
            label: data.label
          }
        });
        this.__dataProducers.set(dataProducer.label, dataProducer);
        return dataProducer;
      } catch (error) {
        logger7.error("\u274C Error Transport Produce Data Event");
        logger7.error(error);
        throw error;
      }
    };
    consume = async (data) => {
      const { label, producerPeerId, kind } = data;
      logger7.info(
        `\u{1F514} Consume Called for ${kind} from remote peer ${producerPeerId}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        const consumer = Consumer_default.create({
          producerId: data.producerId,
          producerPeerId,
          label
        });
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const parsedRtpParameters = parseRtpParameters(data.rtpParameters);
        const mediaSoupConsumer = await this.__mediasoupTransport.consume({
          id: data.consumerId,
          rtpParameters: parsedRtpParameters,
          kind: data.kind,
          producerId: data.producerId,
          appData: data.appData
        });
        mediaSoupConsumer.on("transportclose", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        mediaSoupConsumer.on("trackended", () => {
          this.closeConsumer({ label, peerId: producerPeerId });
        });
        this.__consumers.set(consumer.label, consumer.producerPeerId, consumer);
        consumer.setMediaSoupConsumer(mediaSoupConsumer);
        return { consumer, mediaSoupConsumer };
      } catch (error) {
        logger7.error(error);
        throw new Error("\u274C Error calling consume()");
      }
    };
    consumeData = async (data) => {
      const {
        label,
        appData,
        dataProducerId,
        protocol,
        id,
        peerId,
        sctpStreamParameters
      } = data;
      logger7.info(
        `\u{1F514} ConsumeData from producer ${peerId} consumerIdFromServer:${id}`
      );
      try {
        if (this.transportType !== "recv") {
          throw new Error(`Cannot consume on ${this.transportType} transport`);
        }
        if (!this.__device.loaded) {
          throw new Error("Device Not Loaded");
        }
        if (!this.__device.rtpCapabilities.codecs) {
          throw new Error("No Codecs Found");
        }
        const dataConsumer = await this.transport.consumeData({
          id,
          dataProducerId,
          sctpStreamParameters: {
            ...sctpStreamParameters,
            maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime === 0 ? void 0 : sctpStreamParameters.maxPacketLifeTime,
            maxRetransmits: sctpStreamParameters.maxRetransmits === 0 ? void 0 : sctpStreamParameters.maxRetransmits
          },
          label,
          protocol,
          appData
        });
        dataConsumer.on("open", () => {
          logger7.info(`\u2705 DataConsumer with ${label} opened`);
        });
        dataConsumer.on("close", () => {
          logger7.warn(`\u2705 DataConsumer with ${label} closed`);
          this.__dataConsumers.delete(label);
        });
        dataConsumer.on("error", (error) => {
          logger7.error(`\u2705 DataConsumer "error": ${error} closed`);
        });
        this.__dataConsumers.set(label, dataConsumer);
        return dataConsumer;
      } catch (error) {
        logger7.error(error);
        throw new Error("\u274C Error calling consumeData()");
      }
    };
    closeConsumer = (data) => {
      try {
        const consumer = this.getConsumer(data);
        if (!consumer) {
          throw new Error(
            `\u274C Consumer not found label: ${data.label}, peerId: ${data.peerId}`
          );
        }
        consumer.close();
        this.__consumers.delete(data.label, data.peerId);
      } catch (error) {
        logger7.error("\u274C Error closing consumer");
        logger7.error(error);
      }
    };
    close = async (data) => {
      try {
        if (data.retries <= 0) {
          logger7.error("\u274C Error closing transport, max retries exceeded");
          return;
        }
        logger7.info(`\u{1F514} Closing ${this.transportType} transport`);
        this.__mediasoupTransport.close();
        logger7.info(`\u2705 ${this.transportType} transport closed`);
      } catch (error) {
        logger7.error("\u274C Error closing transport");
        logger7.error(error);
        logger7.error("Retrying...");
        this.close({ retries: data.retries - 1 });
      }
    };
    __connectionStateChangeHandler = (state) => {
      try {
        logger7.debug(
          `\u{1F514} ${this.transportType} Transport Connection State Changed, state: ${state}`
        );
        const transportType = this.transportType;
        const handler = {
          connected: () => {
            logger7.debug(`\u{1F514} ${this.transportType} Transport Connected`);
          },
          disconnected: () => {
            if (this.__iceRestartDebounce)
              return;
            this.__iceRestartDebounce = true;
            this.__socket.publish("restartTransportIce", {
              transportId: this.__mediasoupTransport.id,
              transportType
            });
            setTimeout(() => {
              this.__iceRestartDebounce = false;
            }, 3e3);
            logger7.debug(`\u{1F514} ${transportType} Transport Disconnected`);
          },
          failed: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport Failed`);
          },
          connecting: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport Connecting`);
          },
          closed: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport closed`);
          },
          new: () => {
            logger7.debug(`\u{1F514} ${transportType} Transport new`);
          }
        };
        handler[state]();
      } catch (err) {
        logger7.error("\u274C Error in connectionStateChangeHandler");
        logger7.error(err);
      }
    };
  };
  var Transport_default = Transport;

  // src/ActiveSpeakers.ts
  var logger8 = mainLogger.createSubLogger("ActiveSpeakers");
  var ActiveSpeakers = class _ActiveSpeakers extends EnhancedEventEmitter {
    /**
     * Instance of the ActiveSpeakers Class; used for singleton pattern.
     */
    static __instance;
    /**
     * Get the instance of the ActiveSpeakers Class.
     * @returns ActiveSpeakers instance.
     */
    static getInstance() {
      if (!_ActiveSpeakers.__instance) {
        throw new Error("ActiveSpeakers not initialized");
      }
      return _ActiveSpeakers.__instance;
    }
    /**
     * Create the instance of the ActiveSpeakers Class.
     * @returns ActiveSpeakers instance.
     */
    static createInstance(data) {
      if (_ActiveSpeakers.__instance) {
        return _ActiveSpeakers.__instance;
      }
      _ActiveSpeakers.__instance = new _ActiveSpeakers(data);
      return _ActiveSpeakers.__instance;
    }
    /**
     * Room instance.
     */
    __room = Room_default.getInstance();
    /**
     * Bot instance which has the data producer connected directly to the room bot.
     * This is used to handle all the states of the room and its functionality.
     */
    __bot;
    /**
     * Is the notification active.
     */
    __active;
    /**
     * Is the notification active.
     */
    get active() {
      return this.__active;
    }
    /**
     * Maximum number of entries in the list.
     */
    MAX_SIZE = 20;
    /**
     * Size by which the active speakers list will be notified.
     * `note: default size is 8`
     */
    __size;
    /**
     * Size by which the active speakers list will be notified.
     */
    get size() {
      return this.__size;
    }
    /**
     * Array of ActiveSpeakers ordered by volume.
     */
    __activePeerIds = [];
    /**
     * Update the number of peerIds to notify.
     * @param size
     */
    updateSize = (size) => {
      logger8.info("\u{1F514} Updating Active Speaker Size to", size);
      if (size > this.MAX_SIZE) {
        logger8.error(
          "\u{1F514} Active Speaker Size cannot be greater than",
          this.MAX_SIZE
        );
        return;
      }
      this.__size = size;
    };
    /**
     * Handle all the events emitted by the bot.
     */
    __handleBotEvents = () => {
      if (this.__bot.listenerCount("active-speakers-change") === 0) {
        this.__bot.on("active-speakers-change", this.__handleActiveSpeakerChange);
      }
    };
    __handleClosingAllEvents = () => {
      this.on("close", () => {
        this.__active = false;
        this.__bot.off(
          "active-speakers-change",
          this.__handleActiveSpeakerChange
        );
      });
    };
    __handleActiveSpeakerChange = (data) => {
      try {
        const { peerIds } = data;
        this.__activePeerIds = peerIds;
        logger8.debug("\u{1F514} Active Speakers Change", this.__activePeerIds);
        const slicedPeerData = peerIds.slice(0, this.__size);
        this.__room.emit("active-speakers-change", {
          peerIds: slicedPeerData ?? [],
          dominantSpeaker: peerIds?.[0] ?? ""
        });
      } catch (error) {
        logger8.error("Error: Handling New Active Speakers Notification", error);
        logger8.error(error);
      }
    };
    constructor(data) {
      super();
      this.__bot = data.bot;
      this.__size = data?.size ?? 8;
      this.__active = true;
      this.__handleBotEvents();
      this.__handleClosingAllEvents();
    }
  };
  var ActiveSpeakers_default = ActiveSpeakers;

  // src/Bot.ts
  var logger9 = mainLogger.createSubLogger("Bot");
  var Bot = class _Bot extends EnhancedEventEmitter {
    /**
     * Instance of the Bot Class; used for singleton pattern.
     */
    static __instance;
    /**
     * Bot Data Consumer
     */
    __botDataConsumer = null;
    /**
     * Get the instance of the Bot Class.
     * @returns Bot instance.
     */
    static getInstance() {
      if (!_Bot.__instance) {
        _Bot.__instance = new _Bot();
        return _Bot.__instance;
      }
      return _Bot.__instance;
    }
    constructor() {
      super();
    }
    setDataConsumer = (dataConsumer) => {
      logger9.debug("\u{1F514} Setting a new data consumer");
      try {
        this.__botDataConsumer?.close();
        this.__botDataConsumer = dataConsumer;
        this.__botDataConsumer.on("message", (message) => {
          try {
            logger9.debug("\u{1F514} Bot Data Message", message);
            const parsedJsonData = JSON.parse(message);
            if (parsedJsonData.label === "lastN") {
              this.emit("active-speakers-change", {
                peerIds: parsedJsonData?.payload?.activeSpeakers ?? []
              });
            }
          } catch (error) {
            logger9.error("\u274C Error in bot data consumer message", error);
          }
        });
      } catch (error) {
        logger9.error("Error in setting data consumer", error);
      }
    };
  };
  var Bot_default = Bot;

  // src/LocalPeer.ts
  var logger10 = mainLogger.createSubLogger("LocalPeer");
  var MAX_DATA_MESSAGE_SIZE = 1 * 1024;
  var LocalPeer = class _LocalPeer extends EnhancedEventEmitter {
    /**
     * LocalPeer Instance, Singleton class, only one instance of this class can be created
     */
    static __instance = null;
    /**
     * PeerId of the current client, specific to the Local Peer who joined the meeting
     *
     * `NOTE: Until you dont join the room, this will be *null*`
     */
    peerId = null;
    /**
     * Current Devices of the current client
     * e.g. Chrome, Firefox, Safari, ReactNative
     */
    __device = null;
    /**
     * SendTransport handles the sending of media from the client to the server
     */
    __sendTransport = null;
    /**
     * RecvTransport handles the receiving of media from the server to the client
     */
    __recvTransport = null;
    /**
     * Returns the room instance, throws an error if the room is not created
     *
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room in the LocalPeer
     */
    get room() {
      const room = Room_default.getInstance();
      if (!room)
        throw new Error("\u274C Room Not Initialized");
      return room;
    }
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      const socket = Socket_default.getInstance();
      if (!socket)
        throw new Error("\u274C Socket Not Initialized");
      return socket;
    }
    /**
     * Remote Peers Map, Stores all the remote peers
     */
    get __remotePeers() {
      return this.room.remotePeers;
    }
    /**
     * Turn Server used for this client
     */
    __turn = [
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=udp",
        credential: "test-turn"
      },
      {
        username: "test-turn",
        urls: "turn:turn.huddle01.com:443?transport=tcp",
        credential: "test-turn"
      }
    ];
    /**
     * Get the current device ( chrome, firefox, safari, reactnative ) for this client
     *
     * @throws { Error } If the device is not initialized
     */
    get device() {
      if (!this.__device)
        throw new Error("Device Not Initialized");
      const loaded = this.__device.loaded;
      if (!loaded)
        throw new Error("Device Not Loaded");
      return this.__device;
    }
    // !important
    // Consumer creation tasks awaiting to be processed.
    // Stores the lables of the pending consumers { producerId: string ==> Promise<Consumer> }
    __pendingConsumerTasks = /* @__PURE__ */ new Map();
    // !important
    // Producer creation tasks awaiting to be processed.
    // Stores the lables of the pending producers { label: string }
    // Used to handle transport callbacks most important;
    __pendingProducerTasks = /* @__PURE__ */ new Map();
    // !important
    // Map to store pending tasks, Stores the label and the promise of the task
    __pendingTasks = /* @__PURE__ */ new Map();
    /**
     * Pending Transport Tasks, Stores the transportType and the promise of the transport
     *
     * `NOTE: Useful to check if the transport is already being created and pause all producing
     * and consuming until the transport is created`
     */
    __pendingTransportTasks = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending fetching stream tasks which are awaiting to be processed
     * If fetching called multiple times at once, it will handle the concurrency issues
     */
    __pendingFetchingStream = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending produce tasks which are awaiting to be processed
     * Mostly used when the room is not joined and produce functionality needs to be handled
     *
     * Cases such as socket experiencing a reconnect and produce is called.
     * Or in the cases where room is not joined and enableVideo or enableAudio is called
     */
    __waitingToProduce = /* @__PURE__ */ new Map();
    /**
     * Stores all the pending consume tasks which are waiting for recv transport to be re-connected
     */
    __waitingToConsume = [];
    /**
     * DeviceHandler Instance, Handles the media devices for this client
     * e.g. Camera, Microphone
     */
    deviceHandler = new DeviceHandler_default();
    /**
     * ActiveStream Map holds MediaStream as Value and Key as Label
     */
    __activeStreams = /* @__PURE__ */ new Map();
    /**
     * Handle the Client Side Permission for the Local Peer.
     */
    __permissions = Permissions_default.createInstance();
    /**
     * Stores the Metadata for the Local Peer.
     */
    __metadata = null;
    /**
     * Variable to check if the user has joined the room
     */
    joined = false;
    /**
     * Return the labels of the Media Stream that the Local Peer is producing to the room
     */
    get labels() {
      const sendTransport = this.__sendTransport;
      if (sendTransport) {
        const labels = Array.from(sendTransport.labelToProducerId.keys());
        return labels;
      }
      return [];
    }
    /**
     * Get the Permissions of the Local Peer. (e.g canProduce, canConsume, canSendData, canRecvData etc)
     */
    get permissions() {
      const acl = this.__permissions.acl;
      return acl;
    }
    /**
     * Get the Role of the Local Peer.
     */
    get role() {
      return this.__permissions.role;
    }
    /**
     * Returns the token of the current socket connection, specific to the Local Peer who joined the meeting
     */
    get token() {
      return this.socket.token;
    }
    /**
     * Returns the roomId of the current joined room.
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Returns the SendTransport
     * @returns { Transport } SendTransport
     * @throws { Error } If the SendTransport is not initialized
     */
    get sendTransport() {
      if (!this.__sendTransport)
        throw new Error("Send Transport Not Initialized");
      return this.__sendTransport;
    }
    /**
     * Returns the recvTransport
     * @returns { Transport } recvTransport
     * @throws { Error } If the recvTransport is not initialized
     */
    get recvTransport() {
      if (!this.__recvTransport)
        throw new Error("Recv Transport Not Initialized");
      return this.__recvTransport;
    }
    /**
     * Returns the metadata associated to the LocalPeer
     */
    getMetadata() {
      const data = JSON.parse(this.__metadata || "{}");
      return data;
    }
    /**
     * getStream returns the stream with the given label
     */
    getStream = (data) => {
      const stream = this.__activeStreams.get(data.label);
      if (stream === void 0) {
        return null;
      }
      return stream;
    };
    /**
     * Updates the metadata associated to the LocalPeer, Triggers the `metadata-updated` event
     * @param metadata
     */
    __updateMetadata = (metadata) => {
      this.__metadata = metadata;
      const parse = JSON.parse(metadata);
      this.emit("metadata-updated", {
        metadata: parse
      });
    };
    /**
     * Returns the producer with the given label
     * @param label - Identifier of the producer
     * @returns { Producer } Producer
     * @returns { null } If the producer is not found
     */
    getProducerWithLabel = (label) => {
      try {
        const producerId = this.__sendTransport?.labelToProducerId.get(label);
        if (producerId) {
          const producer = this.sendTransport.getProducerById(producerId);
          return producer;
        }
        return null;
      } catch (error) {
        logger10.error("\u274C Cannot Find Producer With Identifier: ", label);
        logger10.error(error);
        return null;
      }
    };
    /**
     * Registers the event handlers for the socket connection
     * @param socket - Socket Instance
     */
    __registerHandlerEvents = (socket) => {
      let cnt = 0;
      const keys = Object.keys(this.__handler);
      for (const key of keys) {
        try {
          const fn = this.__handler[key];
          if (fn)
            socket.subscribe(key, fn);
        } catch (error) {
          logger10.error(`\u274C Error Registered For Event: ${key}`);
          logger10.error(error);
        }
        cnt++;
      }
      logger10.info("\u2705 LocalPeerEventHandler Registered");
    };
    /**
     * Can be used to check which `direction` of webRTC connection is currently active for the peer.
     *
     * **NOTE: Peers with role as Bot will not have `recv` transport;**
     * @param transportType
     */
    transportExists = (transportType) => {
      if (transportType === "recv") {
        return this.__recvTransport;
      }
      return this.__sendTransport;
    };
    static create() {
      if (_LocalPeer.__instance) {
        return _LocalPeer.__instance;
      }
      _LocalPeer.__instance = new _LocalPeer();
      return _LocalPeer.__instance;
    }
    static getInstance() {
      if (!_LocalPeer.__instance) {
        throw new Error("LocalPeer not initialized");
      }
      return _LocalPeer.__instance;
    }
    constructor() {
      super();
      this.__registerHandlerEvents(this.socket);
      this.socket.on("reconnected", () => {
        logger10.info("\u{1F514} LocalPeer Reconnected, Syncing Meeting States");
        this.socket.publish("syncMeetingState", void 0);
        if (this.__sendTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__sendTransport.mediasoupTransport.id,
            transportType: "send"
          });
        }
        if (this.__recvTransport) {
          this.socket.publish("restartTransportIce", {
            transportId: this.__recvTransport.mediasoupTransport.id,
            transportType: "recv"
          });
        }
      });
    }
    /**
     * Destroy the current peer, closes all the transports, producers and consumers
     *
     * @param code - Close Code
     */
    close = () => {
      this.__device = null;
      navigator.mediaDevices.ondevicechange = null;
      this.__pendingConsumerTasks.clear();
      this.__pendingProducerTasks.clear();
      this.__pendingTransportTasks.clear();
      this.__pendingFetchingStream.clear();
      this.__waitingToProduce.clear();
      for (const stream of this.__activeStreams.values()) {
        for (const track of stream.getTracks())
          track.stop();
      }
      this.joined = false;
      this.deviceHandler.destroy();
      if (this.__sendTransport) {
        this.__sendTransport.close({ retries: 3 });
      }
      if (this.__recvTransport) {
        this.__recvTransport.close({ retries: 3 });
      }
      this.__sendTransport = null;
      this.__recvTransport = null;
      this.__permissions.reset();
      this.emit("permissions-updated", {
        permissions: this.permissions,
        role: this.role ?? ""
      });
    };
    /**
     * LocalPeer Handler Functions Begins Here 👇
     */
    /**
     * Produce a stream with a given label and appData to all the Remote Peers
     *
     * `canProduce must be true to produce a stream`
     *
     * `NOTE: This will notify all the RemotePeers that this producer has started producing and they should start consuming it if they want to`
     *
     * @param data - Data to produce a stream
     *  - `label` - Unique Identifier for the stream ( string )
     *  - `stream` - MediaStream to produce ( MediaStream )
     *  - `stopTrackOnClose` - If true, it will stop the track when the producer is closed using stopProducing ( boolean )
     *  - `appData` - Application level custom data which can be added to the producer for the LocalPeer, this data will be available in the producer object and can be used only by the LocalPeer. ( Unknown Object )
     *
     * @summary This function is used to produce a stream with a given label and appData to all the Remote Peers if the send transport is not initialised
     * it will create a send transport and then produce the stream with the given label and appData to all the Remote Peers
     *
     * Send Transport is a secure channel which is used to send media from LocalPeer to all the RemotePeers in the room
     *
     * `localPeer.on('new-producer', ({label: string; producer: Producer}) => {})`
     */
    produce = checkPermissions({
      canProduce: true
    }).validate(
      async (data) => {
        const track = data.stream.getTracks()[0];
        if (track) {
          track.addEventListener("ended", () => {
            this.stopProducing({ label: data.label });
          });
        }
        if (!this.joined || this.__sendTransport && this.__sendTransport?.connectionState !== "connected") {
          return new Promise((resolve) => {
            const fn = async () => {
              const producer2 = await this.produce(data).then((data2) => {
                resolve(data2);
                return data2;
              }).finally(() => {
                this.__pendingProducerTasks.delete(data.label);
              });
              return producer2;
            };
            this.__waitingToProduce.set(data.label, fn);
          });
        }
        const { stream } = data;
        const producerPromise = this.__pendingProducerTasks.get(data.label);
        if (producerPromise) {
          logger10.info(
            "\u{1F514} Producer Task Already Pending for this label ",
            data.label
          );
          const producer2 = await producerPromise;
          return producer2;
        }
        if (!this.__sendTransport) {
          await this.__createTransportOnServer({
            transportType: "send"
          });
        }
        const ongoingPromise = this.__pendingProducerTasks.get(data.label);
        if (ongoingPromise) {
          const producer2 = await ongoingPromise;
          return producer2;
        }
        const promise = this.__createProducer({
          stream,
          label: data.label,
          appData: { ...data.appData, label: data.label }
        });
        this.__pendingProducerTasks.set(data.label, promise);
        const producer = await promise.catch(() => {
          logger10.error("\u274C Error Create Producer Failed");
          throw new Error("\u274C Error Create Producer Failed");
        }).finally(() => {
          this.__pendingProducerTasks.delete(data.label);
        });
        return producer;
      }
    );
    /**
     * Enables the local web cam and starts producing the stream with the label `video`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local web cam fetches the stream opens you web cam indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `video` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using disableVideo it will stop the local track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     * `NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will throw an error`
     *
     * @throws { Error } If the stream is not found
     */
    enableVideo = checkPermissions({
      canProduce: true
    }).validate(async (customVideoStream) => {
      try {
        if (!this.permissions.canProduceSources.cam) {
          logger10.error("\u274C Cannot Enable Video, Permission Denied");
          throw new Error("\u274C Cannot Enable Video, Permission Denied");
        }
        const existingStream = this.__activeStreams.get("video");
        if (existingStream) {
          logger10.warn("\u{1F514} Cam Stream Already Enabled");
          return;
        }
        let stream;
        if (customVideoStream) {
          stream = customVideoStream;
        } else {
          const ongoingStreamPromise = this.__pendingFetchingStream.get("cam");
          if (ongoingStreamPromise) {
            await ongoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchStream({
              mediaDeviceKind: "cam"
            });
            this.__pendingFetchingStream.set("cam", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("cam");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Promise Not Found");
            return;
          }
          const { stream: fetchedStream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Stream From Device");
          }
          if (!fetchedStream) {
            logger10.error("\u274C Stream Not Found, cannot do enableVideo");
            throw new Error("\u274C Stream Not Found");
          }
          stream = fetchedStream;
        }
        this.__activeStreams.set("video", stream);
        this.emit("stream-fetched", {
          mediaKind: "cam",
          label: "video",
          stream
        });
        this.produce({
          label: "video",
          stream,
          appData: {
            producerPeerId: this.peerId
          },
          stopTrackOnClose: true
        }).then(() => {
          this.__pendingProducerTasks.delete("video");
        }).catch((error) => {
          logger10.error("\u274C Error Producing Video");
          this.deviceHandler.stopStream(this.__activeStreams.get("video"));
          this.__activeStreams.delete("video");
          this.__pendingFetchingStream.delete("cam");
          logger10.error(error);
        });
        this.__pendingFetchingStream.delete("cam");
        return stream;
      } catch (error) {
        logger10.error("\u274C Error Enabling Video");
        logger10.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("video"));
        this.__activeStreams.delete("video");
        this.__pendingFetchingStream.delete("cam");
        throw error;
      }
    });
    /**
     * Enables the local screen share  and starts producing the screen sharing stream
     *
     *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     *
     *
     */
    startScreenShare = checkPermissions({ canProduce: true }).validate(
      async () => {
        try {
          if (!this.permissions.canProduceSources.screen) {
            logger10.error("\u274C Cannot Enable Screen Share, Permission Denied");
            throw new Error("\u274C Cannot Enable Screen Share, Permission Denied");
          }
          const existingStream = this.__activeStreams.get("screen-share");
          if (existingStream) {
            logger10.warn("\u{1F514} Screen Stream Already Enabled");
            return;
          }
          const onGoingStreamPromise = this.__pendingFetchingStream.get("screen-share");
          if (onGoingStreamPromise) {
            await onGoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchScreen();
            this.__pendingFetchingStream.set("screen-share", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("screen-share");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Screen Share Promise Not Found");
            return;
          }
          const { stream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Screen Share Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Screen ShareStream From Device");
          }
          if (!stream) {
            logger10.error("\u274C Stream Not Found, cannot do startScreenShare");
            throw new Error("\u274C Stream Not Found, cannot do startScreenShare");
          }
          this.__activeStreams.set("screen-share", stream);
          this.emit("stream-fetched", {
            mediaKind: "screen",
            label: "screen-share",
            stream
          });
          const videoTrack = stream.getVideoTracks()?.[0];
          const audioTrack = stream.getAudioTracks()?.[0];
          const videoProduce = async () => {
            return this.produce({
              label: "screen-share-video",
              stream: new MediaStream([videoTrack]),
              appData: {
                producerPeerId: this.peerId
              },
              stopTrackOnClose: true
            });
          };
          const audioProduce = async () => {
            return this.produce({
              label: "screen-share-audio",
              stream: new MediaStream([audioTrack]),
              appData: {
                producerPeerId: this.peerId
              },
              stopTrackOnClose: true
            });
          };
          if (videoTrack) {
            videoProduce().then(() => {
              this.__pendingProducerTasks.delete("screen-share-video");
            }).catch((error2) => {
              logger10.error("\u274C Error Producing Screen Share Video");
              this.deviceHandler.stopStream(
                this.__activeStreams.get("screen-share")
              );
              this.__activeStreams.delete("screen-share");
              logger10.error(error2);
            });
          }
          if (audioTrack) {
            audioProduce().then(() => {
              this.__pendingProducerTasks.delete("screen-share-audio");
            }).catch((error2) => {
              logger10.error("\u274C Error Producing Audio");
              this.deviceHandler.stopStream(
                this.__activeStreams.get("screen-share")
              );
              this.__activeStreams.delete("screen-share");
              logger10.error(error2);
            });
          }
          this.__pendingFetchingStream.delete("screen-share");
          return stream;
        } catch (error) {
          logger10.error("\u274C Error Enabling Screen Share");
          logger10.error(error);
          this.deviceHandler.stopStream(this.__activeStreams.get("screen-share"));
          this.__activeStreams.delete("screen-share");
          this.__pendingFetchingStream.delete("screen-share");
          throw error;
        }
      }
    );
    /**
     * Enables the local mic and starts producing the stream with the label `audio`
     *
     *`NOTE: You can only produce to a room when you have joined the room, if you try to produce before joining the room it will fetch the stream and start producing when you join the room`
     *
     * @summary This functions handle the producing of media streams to all the remote peers in the room.
     * it enables the local mic fetches the stream opens you mic active indicator light on the device
     * upon successfull fetching of the stream it produces the stream with the label `audio` and `stopTrackOnClose: true` to all the remote peers in the room.
     * when closing using `disableAudio` it will stop the local audio track and close the producer which will notify all the RemotePeers that this producer has stopped producing
     * and they should stop consuming it.
     */
    enableAudio = checkPermissions({
      canProduce: true
    }).validate(async (customAudioStream) => {
      try {
        if (!this.permissions.canProduceSources.mic) {
          logger10.error("\u274C Cannot Enable Audio, Permission Denied");
          throw new Error("\u274C Cannot Enable Audio, Permission Denied");
        }
        const existingStream = this.__activeStreams.get("audio");
        if (existingStream) {
          logger10.warn("\u{1F514} Mic Stream Already Enabled");
          return;
        }
        let stream;
        if (customAudioStream) {
          stream = customAudioStream;
        } else {
          const ongoingStreamPromise = this.__pendingFetchingStream.get("mic");
          if (ongoingStreamPromise) {
            await ongoingStreamPromise;
          } else {
            const streamPromise = this.deviceHandler.fetchStream({
              mediaDeviceKind: "mic"
            });
            this.__pendingFetchingStream.set("mic", streamPromise);
          }
          const pendingPromise = this.__pendingFetchingStream.get("mic");
          if (!pendingPromise) {
            logger10.info("\u{1F514} Pending Mic Promise Not Found");
            return;
          }
          const { stream: fetchedStream, error } = await pendingPromise;
          if (error) {
            logger10.error("\u274C Error Fetching Stream From Device");
            logger10.error(error);
            throw new Error("\u274C Error Fetching Stream From Device");
          }
          if (!fetchedStream) {
            logger10.error("\u274C Stream Not Found, cannot do enableAudio");
            throw new Error("\u274C Stream Not Found");
          }
          stream = fetchedStream;
        }
        this.__activeStreams.set("audio", stream);
        this.emit("stream-fetched", {
          mediaKind: "mic",
          stream,
          label: "audio"
        });
        this.produce({
          label: "audio",
          stream,
          appData: {
            producerPeerId: this.peerId
          },
          stopTrackOnClose: true
        }).then(() => {
          this.__pendingProducerTasks.delete("audio");
        }).catch((error) => {
          logger10.error("\u274C Error Producing Audio");
          this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
          this.__activeStreams.delete("audio");
          logger10.error(error);
        });
        this.__pendingFetchingStream.delete("mic");
        return stream;
      } catch (error) {
        logger10.error("\u274C Error Enabling Audio");
        logger10.error(error);
        this.deviceHandler.stopStream(this.__activeStreams.get("audio"));
        this.__activeStreams.delete("audio");
        this.__pendingFetchingStream.delete("mic");
        throw error;
      }
    });
    /**
     * Stops the underlying producing of a stream for a particular label
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     *
     * @param data Data to stop producing { label: string }
     */
    stopProducing = (data) => {
      this.__waitingToProduce.delete(data.label);
      this.__pendingProducerTasks.delete(data.label);
      let closedStream = false;
      const producer = this.getProducerWithLabel(data.label);
      if (producer) {
        logger10.info("\u{1F514} Closing Producer", {
          label: data.label,
          producerId: producer.id
        });
        producer.close();
        producer.on("trackended", () => {
          console.debug("\u{1F514} Track Ended For the Producer");
        });
        this.__sendTransport?.removeProducerById(producer.id);
        closedStream = true;
        this.socket.publish("closeProducer", {
          producerId: producer.id
        });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const stream = this.__activeStreams.get(closedStreamLabel);
      if (stream) {
        this.deviceHandler.stopStream(stream);
        this.__activeStreams.delete(closedStreamLabel);
        closedStream = true;
      }
      if (closedStream) {
        this.emit("stream-closed", {
          label: data.label,
          reason: {
            code: 1200,
            tag: "STREAM_CLOSED",
            message: "Stopped Streaming"
          }
        });
      }
    };
    /**
     * Stops the underlying producing of a camera stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     *
     * @param data Data to stop producing { label: string }
     */
    disableVideo = async () => {
      this.stopProducing({
        label: "video"
      });
    };
    /**
     * Replaces the current video stream with the new stream
     *
     * if you have produced a stream with label `video` or used the default function `enableVideo` and you want to replace it with a new stream
     * @param stream - New Video Stream
     */
    replaceVideoStream = async (stream) => {
      await this.replaceStream({
        label: "video",
        newStream: stream
      });
    };
    /**
     * Changes the Video source to the given deviceId, sets the preferred cam device as the given deviceId
     * @param deviceId
     */
    changeVideoSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "cam"
      });
      const stream = this.__activeStreams.get("video");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "cam"
      });
      if (!newStream)
        return;
      await this.replaceVideoStream(newStream);
    };
    /**
     * Replaces the current audio stream with the new stream
     * if you have produced a stream with label `audio` or used the default function `enableAudio` and you want to replace it with a new stream
     * @param stream - New Audio Stream
     *
     */
    replaceAudioStream = async (stream) => {
      await this.replaceStream({
        label: "audio",
        newStream: stream
      });
    };
    /**
     * Replace the current stream with the new stream based on the label used to produce the stream
     *
     * @example
     * For Video
     * await localPeer.replaceStream({
     *  label: 'video',
     *  newStream: newStream
     * })
     *
     * For Screen-Share
     * await localPeer.replaceStream({
     *  label: 'screen-share-video',
     *  newStream: newStream
     * })
     *
     * If any custom label used
     * await localPeer.replaceStream({
     *  label: 'custom',
     *  newStream: newStream
     * })
     *
     * @param data - { label: string, newStream: MediaStream }
     */
    replaceStream = async (data) => {
      logger10.info(`\u{1F514} Replacing ${data.label} Stream `);
      const producer = this.getProducerWithLabel(data.label);
      const track = data.newStream.getTracks()[0];
      if (track) {
        track.addEventListener("ended", () => {
          this.stopProducing({ label: data.label });
        });
      }
      if (producer) {
        await producer.replaceTrack({ track });
      }
      const closedStreamLabel = data.label.startsWith("screen-share") ? "screen-share" : data.label;
      const prevStream = this.__activeStreams.get(closedStreamLabel);
      if (prevStream && !this.__waitingToProduce.has(closedStreamLabel)) {
        this.deviceHandler.stopStream(prevStream);
        this.__activeStreams.delete(closedStreamLabel);
        this.__activeStreams.set(closedStreamLabel, data.newStream);
      } else if (prevStream && this.__waitingToProduce.has(closedStreamLabel)) {
        for (const track2 of prevStream.getTracks()) {
          prevStream.removeTrack(track2);
          track2.stop();
        }
        for (const track2 of data.newStream.getTracks()) {
          prevStream.addTrack(track2);
        }
      }
      const mediaDeviceKind = getMediaDeviceKind(track);
      this.emit("stream-fetched", {
        label: data.label,
        stream: data.newStream,
        mediaKind: mediaDeviceKind
      });
    };
    /**
     * Changes the Audio source to the given deviceId, sets the preferred mic device as the given deviceId
     * @param deviceId
     */
    changeAudioSource = async (deviceId) => {
      this.deviceHandler.setPreferredDevice({
        deviceId,
        deviceKind: "mic"
      });
      const stream = this.__activeStreams.get("audio");
      if (!stream) {
        return;
      }
      const { stream: newStream } = await this.deviceHandler.fetchStream({
        mediaDeviceKind: "mic"
      });
      if (!newStream)
        return;
      await this.replaceAudioStream(newStream);
    };
    /**
     * Stops the underlying producing of a microphone stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it.`
     */
    disableAudio = async () => {
      this.stopProducing({
        label: "audio"
      });
    };
    /**
     * Stops the underlying producing of a screen-share stream, stops the local track and closes the producer
     *
     * `NOTE: This will notify all the RemotePeers that this producer has stopped producing and they should stop consuming it. if you have joined the room, else it will just close the stream`
     */
    stopScreenShare = async () => {
      try {
        this.stopProducing({
          label: "screen-share-video"
        });
        this.stopProducing({
          label: "screen-share-audio"
        });
      } catch (error) {
        logger10.error(error);
        logger10.error("Error Disabling Screen Share");
      }
    };
    /**
     * Consumes a stream with the producerId and peerId of the RemotePeer, appData is application level custom data which
     * can be added to the consumer for the LocalPeer, this data will be available in the consumer object and can be used only by the LocalPeer.
     *
     * `NOTE: This will not notify the RemotePeers that you are consuming a stream, you have to notify them manually`
     * @summary Every time a RemotePeer is producing a Media in the Room, LocalPeer will be notified about it and it will be able to consume it.
     * Consuming is a process where the media is received from the RemotePeer and the stream can be played on the LocalPeers device.
     *
     * To get the consumer back you can use
     *
     * const remotePeer = this.room.getRemotePeerById(data.peerId);
     *
     * `remotePeer.on('stream-playable', ({ label: string; consumer: Consumer }) => {})`
     *
     * @param data - {peerId: string, label: string, appData: Record<string, unknown>}
     *
     */
    consume = checkPermissions({
      canConsume: true
    }).validate(
      async (data) => {
        const remotePeer = this.__remotePeers.get(data.peerId);
        if (!remotePeer) {
          throw new Error(`Remote Peer Not Found with PeerId ${data.peerId}`);
        }
        const labelData = remotePeer.getLabelData(data.label);
        if (!labelData) {
          throw new Error(
            `Remote Peer is not producing with Label ${data.label}`
          );
        }
        const consumerExists = remotePeer.getConsumer(data.label);
        if (consumerExists?.consuming) {
          logger10.warn("\u{1F514} Consumer Already Exists with label ", data.label);
          return consumerExists;
        }
        const pendingPromise = this.__pendingConsumerTasks.get(
          labelData?.producerId
        );
        if (pendingPromise) {
          logger10.warn(
            `\u{1F514} Consumer Task Pending to be Consumed with label ${data.label}, Returning`
          );
          const consumer2 = await pendingPromise;
          return consumer2;
        }
        logger10.info("\u{1F514} Consuming Stream with label ", data.label);
        if (!this.__recvTransport) {
          logger10.info(
            "\u{1F514} Recv Transport Not Initialized, Creaitng RecvTransport"
          );
          await this.__createTransportOnServer({
            transportType: "recv"
          });
        }
        const consumerPromise = new Promise((resolve) => {
          const handleStreamPlayable = (streamData) => {
            if (streamData.label === data.label) {
              remotePeer.off("stream-playable", handleStreamPlayable);
              resolve(streamData.consumer);
            }
          };
          remotePeer.once("stream-playable", handleStreamPlayable);
          this.socket.publish("consume", {
            appData: data.appData,
            producerId: labelData.producerId,
            producerPeerId: data.peerId
          });
        });
        this.__pendingConsumerTasks.set(labelData.producerId, consumerPromise);
        const consumer = await consumerPromise.catch((error) => {
          logger10.error("\u274C Error Consuming Stream");
          logger10.error(error);
          throw error;
        }).finally(() => {
          this.__pendingConsumerTasks.delete(labelData.producerId);
        });
        return consumer;
      }
    );
    /**
     * Stops the underlying consuming of a stream for a particular label
     *
     * `NOTE: This does not notify the remote peers that you are not consuming a stream`
     *
     * @param data
     */
    stopConsuming = (data) => {
      const remotePeer = this.room.getRemotePeerById(data.peerId);
      if (!remotePeer.hasLabel(data.label)) {
        logger10.error(
          `\u274C Remote Peer is not producing anything with label: ${data.label}`
        );
        return;
      }
      const consumer = this.recvTransport.getConsumer(data);
      if (!consumer) {
        logger10.error("\u274C Consumer Not Found", data);
        return;
      }
      if (!consumer.consuming) {
        logger10.error("\u274C You are not Consuming any Stream, Consumer Not Found");
        return;
      }
      const consumerId = consumer.id;
      if (!consumerId) {
        logger10.error("\u274C ConsumerId Not Found");
        return;
      }
      this.socket.publish("closeConsumer", {
        consumerId: consumer.id
      });
      remotePeer.emit("stream-closed", {
        label: data.label
      });
      this.recvTransport.closeConsumer(data);
    };
    /**
     * Activate Getting Active Speaker of the Remote Peers in the Room in decreasing order.
     * i.e. Speaker who are speaking the most in the room.
     *
     * if autoConsume is false, you have to manually consume speaker to get there notification
     */
    activateActiveSpeakersNotification = async (size) => {
      try {
        logger10.info("\u{1F514} Activating Speakers Notification Functionality");
        if (this.room.activeSpeakers) {
          logger10.info("\u{1F514} Speakers Notification Functionality Already Activated");
          return;
        }
        const botDataConsume = this.__sendTransport?.dataConsumers.get("bot");
        if (botDataConsume) {
          logger10.debug("\u{1F514} Bot Data Consumer Already Exists");
          return;
        }
        const ongoingActiveSpeakerPromise = this.__pendingTasks.get("bot");
        if (ongoingActiveSpeakerPromise) {
          logger10.debug("\u{1F514} Bot Data Consumer Task Pending");
          await ongoingActiveSpeakerPromise;
        } else {
          const fn = async () => {
            if (!this.__recvTransport) {
              logger10.debug(
                "\u{1F514} Recv Transport Not Initialized, Creating RecvTransport"
              );
              await this.__createTransportOnServer({
                transportType: "recv"
              });
            }
            this.socket.publish("createDataConsumer", {
              label: "bot"
            });
            return size ?? 8;
          };
          const promise = fn();
          this.__pendingTasks.set("bot", promise);
          await promise;
        }
      } catch (error) {
        logger10.error(
          "\u274C Error Activating Speakers Notification Functionality",
          error
        );
      }
    };
    sendData = checkPermissions({
      canSendData: true
    }).validate(
      (data) => {
        if (estimateSize(data.payload) > MAX_DATA_MESSAGE_SIZE) {
          logger10.error("\u274C Data message exceeds 1kb in size");
          return;
        }
        const parsedTo = data.to === "*" ? ["*"] : data.to;
        this.socket.publish("sendData", {
          to: parsedTo,
          payload: data.payload,
          label: data.label
        });
      }
    );
    produceData = () => {
      logger10.info("\u{1F514} Producing Data,");
    };
    /**
     * Send Message to update the metadata of the Local Peer
     *
     * `NOTE: This will notify every user in the room about the metadata update`
     */
    updateMetadata = checkPermissions({
      canUpdateMetadata: true
    }).validate((data) => {
      if (!this.joined) {
        logger10.error(
          "\u274C Cannot Update Metadata, You have not joined the room yet"
        );
        return;
      }
      const peerId = this.peerId;
      if (!peerId) {
        logger10.error("\u274C Cannot Update Metadata, PeerId Not Found");
        return;
      }
      const newMetadata = JSON.stringify(data);
      this.socket.publish("updatePeerMetadata", {
        peerId,
        metadata: newMetadata
      });
    });
    /**
     * Update the role of the Remote Peer in the Room, this will emit an event `updated` with the updated role.
     */
    updateRole = (data) => {
      try {
        if (!this.joined) {
          throw new Error(
            "\u274C Cannot Update Role, You have not joined the room yet"
          );
        }
        if (data.role === this.role) {
          logger10.warn("\u{1F514} Peer Role is already set to", data.role);
          return;
        }
        if (!this.peerId) {
          logger10.error(
            "\u274C Cannot Update Role, PeerId Not Found, (You have not joined the room yet)"
          );
          return;
        }
        this.socket.publish("updatePeerRole", {
          peerId: this.peerId,
          role: data.role
        });
      } catch (error) {
        logger10.error("\u{1F514} Error Updating Role", data);
        logger10.error(error);
      }
    };
    __handler = {
      error: (data) => {
        logger10.error("\u274C Error Event");
        logger10.error(data);
      },
      /**
       * When Huddle01 Node has successfully accepted the connection request
       * it sents back some usefull metadata for the client to use
       * at this point the socket is assumed to the connected and the localPeer is ready to join the room
       *
       * @param data - Data from server { peerId }
       */
      hello: (data) => {
        logger10.info("\u2705 Hello From Server, Connection Success", data);
        const { acl, peerId } = data;
        this.peerId = peerId;
        this.room.sessionId = data.sessionId;
        this.__permissions.updatePermissions(data.acl);
        if (data?.role)
          this.__permissions.role = data.role;
        this.emit("permissions-updated", {
          permissions: acl,
          role: data.role
        });
        if (data.metadata) {
          this.__updateMetadata(data.metadata);
        }
      },
      waitingRoom: (data) => {
        logger10.info("\u{1F514} Waiting Room", data);
        this.room.emit("room-waiting", data);
      },
      /**
       * @description Uponn successful joining of the room, the server sends back some usefull metadata such as remotePeers in the room.
       * @emits "room-joined" - When the client has successfully joined the room.
       * @emits "join-error" - When the client has failed to join the room.
       * @param data - Data from server { roomId, roomInfo, routerRTPCapabilities, turnServer }
       */
      connectRoomResponse: async (data) => {
        logger10.info("\u2705 Join Success Event");
        try {
          const { roomInfo, routerRTPCapabilities, turnServers } = data;
          this.room.config = roomInfo.config;
          this.room.metadata = roomInfo.metadata ?? "{}";
          this.room.stats.startTime = roomInfo.startTime;
          const deviceType = (0, import_mediasoup_client.detectDevice)();
          if (!deviceType) {
            logger10.error(
              "\u274C Device is not supported, valid devices are : 'Chrome111' | 'Chrome74' | 'Chrome70' | 'Chrome67' | 'Chrome55' | 'Firefox60' | 'Safari12' | 'Safari11' | 'Edge11' | 'ReactNativeUnifiedPlan' | 'ReactNative'"
            );
            throw new Error("\u274C Device is not supported");
          }
          this.__device = new import_mediasoup_client.Device({ handlerName: deviceType });
          const parsedRouterRtpCapabilites = parseRouterRtpCapabilities({
            codecs: routerRTPCapabilities.codecs,
            headerExtensions: routerRTPCapabilities.headerExtensions
          });
          await this.__device.load({
            routerRtpCapabilities: parsedRouterRtpCapabilites
          });
          if (!this.device.loaded) {
            throw new Error("\u274C Cannot Load Device");
          }
          this.emit("device-created", { device: this.__device });
          this.__setRemotePeers(roomInfo);
          this.__setLobbyPeers(roomInfo);
          if (turnServers?.length) {
            logger10.info("\u{1F514} Setting Turn Server", turnServers);
            this.__turn = [...turnServers, ...this.__turn];
          }
          this.room.state = "connected";
          this.joined = true;
          this.room.emit("room-joined");
        } catch (error) {
          logger10.error("\u274C Error Joining Room");
          logger10.error(error);
          this.room.emit("room-joined-failed", {
            message: "\u274C Error Joining Room",
            status: "ROOM_ERRORED"
          });
        }
        this.__handleWaitingToProduce();
      },
      /**
       * @description update the remote peers in the room , remove the remote peers which are not in the room anymore
       * @param roomInfo
       */
      syncMeetingStateResponse: async (data) => {
        try {
          logger10.info("\u2705 Client recovered after reconnecting", data);
          const { peers: latestPeers } = data.roomInfo;
          const latestPeersSet = new Set(latestPeers.map((p) => p.peerId));
          for (const [peerId, peer] of this.__remotePeers.entries()) {
            if (!latestPeersSet.has(peerId)) {
              for (const label of peer.labels) {
                this.__closeRemotePeerConsumer({
                  peerId,
                  label
                });
              }
              peer.close();
              this.__remotePeers.delete(peerId);
              this.room.emit("peer-left", peerId);
              continue;
            }
            const latestPeerInfo = latestPeers.find((p) => p.peerId === peerId);
            if (!latestPeerInfo)
              continue;
            const newProducerSet = new Set(
              latestPeerInfo.producers.map((p) => p.label)
            );
            for (const label of peer.labels) {
              if (!newProducerSet.has(label)) {
                this.__closeRemotePeerConsumer({ peerId, label });
              }
            }
            const currentProducerSet = new Set(peer.producerIds);
            for (const producer of latestPeerInfo.producers) {
              if (!currentProducerSet.has(producer.id)) {
                if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                  peer._addLabelData({
                    producerId: producer.id,
                    label: producer.label
                  });
                } else {
                  this.__waitingToConsume.push(
                    () => peer._addLabelData({
                      producerId: producer.id,
                      label: producer.label
                    })
                  );
                }
              }
            }
          }
          const filteredPeers = latestPeers.filter(
            (latestPeer) => !this.__remotePeers.has(latestPeer.peerId) && latestPeer.peerId !== this.peerId
          ).values();
          for (const latestPeer of filteredPeers) {
            const remotePeer = new RemotePeer_default({
              peerId: latestPeer.peerId,
              role: latestPeer.role,
              metadata: latestPeer.metadata
            });
            this.__remotePeers.set(latestPeer.peerId, remotePeer);
            const remoteProducers = latestPeer.producers;
            for (const p of remoteProducers) {
              if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
                remotePeer._addLabelData({ producerId: p.id, label: p.label });
              } else {
                this.__waitingToConsume.push(
                  () => remotePeer._addLabelData({
                    producerId: p.id,
                    label: p.label
                  })
                );
              }
            }
            this.room.emit("new-peer-joined", { peer: remotePeer });
          }
        } catch (error) {
          logger10.error("\u274C Error Syncing Meeting State, Can't Recover");
          logger10.error(error);
        }
      },
      /**
       * Upon creation of server side transport, the server sends back some usefull metadata for the client to use
       * to create a client side transport, i.e. `send | recv` Transport.
       * @param data - Data from server { transportSDPInfo, transportType }
       */
      createTransportOnClient: async (data) => {
        try {
          const device = this.device;
          if (!this.peerId) {
            throw new Error(
              "\u274C Cannot Create Transport, No PeerId Found for the user."
            );
          }
          const transport = Transport_default.create({
            device,
            peerId: this.peerId,
            socket: this.socket,
            sdpInfo: data.transportSDPInfo,
            iceServers: this.__turn,
            transportType: data.transportType
          });
          if (transport.transportType === "send") {
            this.__sendTransport = transport;
            this.__sendTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToProduce();
                }
              }
            );
            this.emit("new-send-transport", {
              transport
            });
          }
          if (transport.transportType === "recv") {
            this.__recvTransport = transport;
            this.__recvTransport.mediasoupTransport.on(
              "connectionstatechange",
              (connectionState) => {
                if (connectionState === "connected") {
                  this.__handleWaitingToConsume();
                }
              }
            );
            this.emit("new-recv-transport", {
              transport
            });
          }
        } catch (error) {
          logger10.error(
            "\u274C Error Creating MediasoupTransport On Client, transportType",
            data.transportType
          );
          logger10.error(error);
        }
      },
      /**
       * !Important
       * When the server has successfully connected the transport, it sends a ack back to the client
       * which handles the callback() function which triggers the process of creation of producer and consumer
       * for reference see: packages/nezuko/src/Transport.ts
       * @param data
       */
      connectTransportResponse: async (data) => {
        logger10.info(
          `\u2705 Connect ${data.transportType} Transport On Server Response`
        );
        try {
          const transportType = data.transportType;
          const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
          if (!transport) {
            throw new Error(`${transportType} Transport Not Initialized`);
          }
          transport.emit("connectTransportResponse");
        } catch (error) {
          logger10.error("\u274C Error Connecting Transport On Server Response");
          logger10.error(error);
        }
      },
      produceResponse: async (data) => {
        logger10.info("\u2705 Produce Response");
        logger10.info(data);
        try {
          const { peerId, producerId, label } = data;
          if (!producerId || !label || !peerId) {
            logger10.error("\u274C ProducerId or Label or PeerId Not Found");
            return;
          }
          if (peerId === this.peerId) {
            this.sendTransport.resolvePendingProducerTask({
              id: producerId,
              label,
              peerId
            });
          } else {
            const remotePeer = this.room.getRemotePeerById(peerId);
            if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
              remotePeer._addLabelData({
                producerId,
                label
              });
            } else {
              this.__waitingToConsume.push(
                () => remotePeer._addLabelData({
                  producerId,
                  label
                })
              );
            }
          }
        } catch (error) {
          logger10.error("\u274C Error Produce Response");
          logger10.error(error);
        }
      },
      consumeDataResponse: async (data) => {
        logger10.debug("\u2705 Consume Data Response, label", data.label);
        try {
          const {
            id,
            peerId,
            dataProducerId,
            label,
            protocol,
            sctpStreamParameters
          } = data;
          if (label !== "bot") {
            logger10.warn("\u{1F514} Consume Data Response, label is not bot, returning");
            return;
          }
          if (label === "bot") {
            const botDataConsumer = this.recvTransport.dataConsumers.get(label);
            if (botDataConsumer) {
              logger10.error("\u274C Bot Data Consumer Already Exists, Can't Create", {
                label
              });
              return;
            }
            const dataConsumer = await this.recvTransport.consumeData({
              id,
              dataProducerId,
              label,
              peerId,
              protocol,
              sctpStreamParameters,
              appData: {}
            });
            const bot = Bot_default.getInstance();
            bot.setDataConsumer(dataConsumer);
            const pendingTask = await this.__pendingTasks.get("bot");
            const activeSpeakers = this.room.activeSpeakers;
            let size = 8;
            if (typeof pendingTask === "number" && pendingTask > 0) {
              size = pendingTask;
            }
            if (!activeSpeakers) {
              this.room.activeSpeakers = ActiveSpeakers_default.createInstance({
                bot,
                size
              });
            }
            this.__pendingTasks.delete("bot");
          }
        } catch (error) {
          logger10.error("\u274C Error: Consume Data Response", error);
        }
      },
      produceDataResponse: async (data) => {
        logger10.debug("\u2705 Produce Data Response consumerIdFromServer", data.id);
        try {
          const {
            id,
            peerId,
            dataProducerId,
            label,
            protocol,
            sctpStreamParameters
          } = data;
          if (peerId === this.peerId && label !== "bot") {
            this.sendTransport.resolvePendingProducerTask({
              id: dataProducerId,
              label,
              peerId
            });
          }
          const botDataConsumer = this.recvTransport.dataConsumers.get(label);
          if (botDataConsumer) {
            logger10.error("\u274C Bot Data Consumer Already Exists, Can't Create", {
              label
            });
            return;
          }
          const dataConsumer = await this.recvTransport.consumeData({
            id,
            dataProducerId,
            label,
            peerId,
            protocol,
            sctpStreamParameters,
            appData: {}
          });
          dataConsumer.on("message", (message) => {
            const parsedJsonData = JSON.parse(message);
            const result = VolatileDataMessageSchema.safeParse(parsedJsonData);
            if (result.success) {
              this.emit("receive-volatile-data", result.data);
            } else {
              throw new Error(
                "\u274C Data Consumer Message Schema Validation Failed"
              );
            }
          });
          if (label === "bot") {
            this.__pendingTasks.delete("bot");
          }
        } catch (error) {
          logger10.error("\u274C Error Produce Data Response");
          logger10.error({ error });
        }
      },
      consumeResponse: async (data) => {
        logger10.info("\u2705 Consume Response", data);
        try {
          const remotePeer = this.room.getRemotePeerById(data.producerPeerId);
          if (!remotePeer.hasLabel(data.label)) {
            logger10.error("\u274C Remote Peer is not producing this label", {
              label: data.label
            });
            throw new Error(
              `\u274C Remote Peer is not producing this label: ${data.label}`
            );
          }
          const { consumer, mediaSoupConsumer } = await this.recvTransport.consume({
            ...data,
            kind: data.kind,
            rtpParameters: {
              codecs: data.rtpParameters.codecs,
              mid: data.rtpParameters.mid,
              encodings: data.rtpParameters.encodings,
              headerExtensions: data.rtpParameters.headerExtensions,
              rtcp: data.rtpParameters.rtcp
            }
          });
          remotePeer.emit("stream-playable", {
            consumer,
            label: consumer.label
          });
          this.room.emit("stream-added", {
            label: consumer.label,
            peerId: data.producerPeerId
          });
          this.socket.publish("resumeConsumer", {
            consumerId: data.consumerId,
            producerPeerId: data.producerPeerId
          });
          mediaSoupConsumer.resume();
        } catch (error) {
          logger10.error("\u274C Error Consume Response");
          logger10.error(error);
          this.__pendingConsumerTasks.delete(data.producerId);
        }
      },
      closeProducerSuccess: async (data) => {
        logger10.info("\u2705 Producer Closed", data);
        if (this.peerId === data.peerId)
          return;
        const { peerId, label } = data;
        try {
          this.__closeRemotePeerConsumer({
            peerId,
            label
          });
        } catch (err) {
          logger10.error("\u274C Error Closing Producer");
          logger10.error(err);
        }
      },
      closeConsumerSuccess: async (data) => {
        logger10.info("\u2705 Consumer Closed, ", data);
      },
      restartTransportIceResponse: async (data) => {
        const { transportType, iceParameters } = data;
        logger10.info("\u2705 Restart Transport Ice Response ", transportType);
        const transport = transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (!transport) {
          logger10.error(`\u274C ${transportType} Transport Not Found`);
          return;
        }
        try {
          await transport.mediasoupTransport.restartIce({
            iceParameters
          });
          logger10.info("\u2705 Restarted Ice for type: ", transportType);
        } catch (error) {
          logger10.error("\u274C Error Restarting Ice for type: ", transportType);
          logger10.error(error);
        }
      },
      newPeerJoined: (data) => {
        if (this.peerId === data.peerId)
          return;
        logger10.info("\u2705 New Peer Joined", { data });
        try {
          const { peerId, role, metadata } = data;
          if (!peerId) {
            return;
          }
          const remotePeer = new RemotePeer_default({
            peerId,
            role,
            metadata
          });
          this.__remotePeers.set(peerId, remotePeer);
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
          this.room.emit("new-peer-joined", { peer: remotePeer });
        } catch (error) {
          logger10.error("\u274C Error New Peer Joined");
          logger10.error(error);
        }
      },
      newLobbyPeer: (data) => {
        try {
          logger10.info("\u2705 New Lobby Peer", { data });
          const parsedData = data;
          this.room.newlobbyPeers = [parsedData];
        } catch (error) {
          logger10.error("\u274C Error New Lobby Peer");
          logger10.error(error);
        }
      },
      newPermissions: (data) => {
        try {
          const parsedData = data.acl;
          this.__permissions.updatePermissions(parsedData);
          this.emit("permissions-updated", {
            permissions: this.permissions
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Permissions");
          logger10.error(error);
        }
      },
      newRoomControls: (data) => {
        logger10.info("\u2705 Received New Room Controls", { data });
        try {
          const { controls } = data;
          this.room.config = controls;
          this.room.emit("room-controls-updated");
        } catch (error) {
          logger10.error("\u274C Error Updating Room Controls");
          logger10.error(error);
        }
      },
      newPeerRole: (data) => {
        logger10.info("\u2705 Received New Peer's Role", { data });
        try {
          const { peerId, role } = data;
          if (peerId === this.peerId) {
            logger10.info("\u2705 Updating Local Peer's Role");
            this.__permissions.role = role;
            this.emit("role-updated", {
              role
            });
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          const prevRole = remotePeer.role ?? "";
          remotePeer.role = role;
          this.room.emit("room-role-updated", {
            peerId,
            newRole: role,
            prevRole
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Peer's Role");
          logger10.error(error);
        }
      },
      roomClosedProducers: (data) => {
        logger10.info("\u2705 Received Room's Closed Producers", { data });
        try {
          const { producers, reason } = data;
          for (const producer of producers) {
            const { label, peerId } = producer;
            if (peerId === this.peerId && label) {
              this.stopProducing({ label });
              continue;
            }
            try {
              const remotePeer = this.room.getRemotePeerById(peerId);
              const consumer = this.recvTransport.getConsumer({
                label,
                peerId
              });
              if (consumer) {
                this.recvTransport.closeConsumer({ label, peerId });
                remotePeer._removeLabelData(label);
                this.room.emit("stream-closed", {
                  label,
                  peerId
                });
              }
            } catch (error) {
              logger10.error("\u274C Error Closing Producer");
              logger10.error(error);
            }
          }
          this.room.emit("room-notification", {
            code: reason?.code ?? 4004,
            message: reason?.message ?? "Room Closed",
            tag: reason?.tag ?? "ROOM_CLOSED"
          });
        } catch (error) {
          logger10.error("\u274C Error Updating Room's Closed Producers");
          logger10.error(error);
        }
      },
      receiveData: (data) => {
        logger10.info("\u2705 Received Data", { data });
        try {
          const { from, label, payload } = data;
          this.emit("receive-data", {
            from,
            label,
            payload
          });
        } catch (error) {
          logger10.error("\u274C Error Receive Data");
          logger10.error(error);
        }
      },
      peerMetadataUpdated: (data) => {
        try {
          logger10.info("\u2705 Metadata Updated", { data });
          const { peerId, metadata } = data;
          if (this.peerId === peerId) {
            this.__updateMetadata(metadata);
            return;
          }
          const remotePeer = this.room.getRemotePeerById(peerId);
          remotePeer.metadata = JSON.parse(metadata);
        } catch (error) {
          logger10.error("\u274C Error Updating Metadata");
          logger10.error(error);
        }
      },
      roomMetadataUpdated: (data) => {
        logger10.info("\u2705 Room Metadata Updated", { data });
        try {
          const { metadata } = data;
          this.room.metadata = metadata;
        } catch (error) {
          logger10.error("\u274C Error Updating Room Metadata");
          logger10.error(error);
        }
      },
      peerLeft: (data) => {
        logger10.info("\u2705 Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const remotePeer = this.room.getRemotePeerById(peerId);
          const labels = remotePeer.labels;
          for (const label of labels) {
            this.__closeRemotePeerConsumer({
              peerId: remotePeer.peerId,
              label
            });
          }
          remotePeer.close();
          this.__remotePeers.delete(peerId);
          this.room.emit("peer-left", peerId);
        } catch (error) {
          logger10.error("\u274C Error Peer Left");
          logger10.error(error);
        }
      },
      lobbyPeerLeft: (data) => {
        logger10.info("\u2705 Lobby Peer Left", { peerId: data.peerId });
        try {
          const { peerId } = data;
          const lobbyPeers = this.room.lobbyPeersMap;
          if (lobbyPeers.has(peerId)) {
            lobbyPeers.delete(peerId);
            this.room.lobbyPeersMap = lobbyPeers;
          }
        } catch (error) {
          logger10.error("\u274C Error Lobby Peer's Left");
          logger10.error(error);
        }
      }
    };
    /**
     * @description Creates a Producer, if send transport is not initialized, it creates one and then creates a producer
     * @param data - Data to create a producer { label, stream, stopTrackOnClose, appData }
     * @returns - Producer
     */
    __createProducer = async (data) => {
      if (!this.__sendTransport) {
        throw new Error("\u274C Send Transport Not Initialized, Internal Error");
      }
      const producer = await this.__sendTransport.produce({
        stream: data.stream,
        stopTrackOnClose: data.stopTrackOnClose ?? true,
        label: data.label,
        appData: {
          ...data.appData,
          label: data.label
        }
      });
      producer.on("transportclose", () => {
        this.stopProducing({ label: data.label });
      });
      this.emit("stream-playable", {
        label: data.label,
        producer
      });
      return producer;
    };
    __createTransportOnServer = async (data) => {
      const pendingPromise = this.__pendingTransportTasks.get(data.transportType);
      if (pendingPromise) {
        logger10.info(
          `\u{1F514} Transport Task Already Pending for this transportType ${data.transportType}`
        );
        return pendingPromise;
      }
      const { transportType } = data;
      const promise = new Promise((resolve, reject) => {
        const handleNewTransport = (data2) => {
          if (data2.transport.transportType === transportType) {
            this.__pendingTransportTasks.delete(transportType);
            resolve(data2.transport);
          }
        };
        if (transportType === "send") {
          this.once("new-send-transport", handleNewTransport);
        }
        if (transportType === "recv") {
          this.once("new-recv-transport", handleNewTransport);
        }
        const device = this.device;
        const transport = data.transportType === "send" ? this.__sendTransport : this.__recvTransport;
        if (transport) {
          reject(
            new Error(`\u274C Transport Already Initialized, type: ${transportType}`)
          );
        }
        logger10.info(`\u{1F514} Creating ${data.transportType} Transport On Server`);
        this.socket.publish("createTransport", {
          sctpCapabilities: device.sctpCapabilities,
          transportType: data.transportType
        });
      });
      this.__pendingTransportTasks.set(data.transportType, promise);
      return promise;
    };
    /**
     * Sets the Remote Peers in the Room
     * @param roomInfo
     */
    __setRemotePeers = (roomInfo) => {
      const { peers } = roomInfo;
      for (const peer of peers) {
        if (peer.peerId === this.peerId)
          continue;
        const remotePeer = new RemotePeer_default({
          peerId: peer.peerId,
          metadata: peer.metadata,
          role: peer.role
        });
        const producers = peer.producers;
        this.__remotePeers.set(peer.peerId, remotePeer);
        producers.map((p) => {
          if (!this.__recvTransport || this.__recvTransport.connectionState === "new" || this.__recvTransport.connectionState === "connected") {
            remotePeer._addLabelData({
              producerId: p.id,
              label: p.label
            });
          } else {
            this.__waitingToConsume.push(
              () => remotePeer._addLabelData({
                producerId: p.id,
                label: p.label
              })
            );
          }
        });
      }
    };
    /**
     * Sets the Lobby Peers in the Room
     * @param roomInfo - RoomInfo
     */
    __setLobbyPeers = (roomInfo) => {
      const { lobbyPeers } = roomInfo;
      this.room.newlobbyPeers = lobbyPeers;
    };
    /**
     * Helper Function to close the consumer of a remote peer
     * @param data - Data to close the consumer { peerId, label }
     */
    __closeRemotePeerConsumer = (data) => {
      try {
        const { peerId, label } = data;
        const remotePeer = this.room.getRemotePeerById(peerId);
        const consumer = this.recvTransport.getConsumer({
          label,
          peerId
        });
        if (consumer) {
          this.recvTransport.closeConsumer({ label, peerId });
          remotePeer._removeLabelData(label);
        }
        this.room.emit("stream-closed", {
          label,
          peerId: data.peerId
        });
      } catch (error) {
        logger10.error("\u274C Error Closing Remote Peer's Consumer");
        logger10.error(error);
      }
    };
    /**
     * !important
     * Handler Function to handle the waiting to produce tasks when user is joining
     * the room with active stream, check if the user has valid permissions and based on
     * that allows the user to produce the stream
     */
    __handleWaitingToProduce = () => {
      try {
        const permissions = this.permissions;
        const closeStream = (label) => {
          const stream = this.__activeStreams.get(label);
          if (stream) {
            this.deviceHandler.stopStream(stream);
            this.__activeStreams.delete(label);
            this.emit("stream-closed", {
              label,
              reason: {
                code: 4444,
                message: "User's Permissions Denied",
                tag: "CLOSED_BY_ADMIN"
              }
            });
          }
          this.__waitingToProduce.delete(label);
        };
        if (!permissions.canProduce) {
          for (const [label, _] of this.__waitingToProduce) {
            closeStream(label);
          }
          this.__waitingToProduce.clear();
          return;
        }
        for (const [label, pendingStreamTask] of this.__waitingToProduce) {
          if (label === "video" && !permissions.canProduceSources.cam) {
            closeStream(label);
            continue;
          }
          if (label === "audio" && !permissions.canProduceSources.mic) {
            closeStream(label);
            continue;
          }
          pendingStreamTask().catch((error) => {
            logger10.error(
              "\u274C Error Producing Stream which was waiting to be produced with label :",
              label
            );
            logger10.error(error);
            closeStream(label);
          });
        }
        this.__waitingToProduce.clear();
      } catch (error) {
        logger10.error("\u274C Error Handling Waiting To Produce");
        logger10.error(error);
      }
    };
    __handleWaitingToConsume = () => {
      for (const consumeTask of this.__waitingToConsume) {
        consumeTask().catch(() => {
          logger10.error("Unable to Consume after ice restart");
        });
      }
      this.__waitingToConsume = [];
    };
  };
  var LocalPeer_default = LocalPeer;

  // src/HuddleClient.ts
  var import_socket2 = __toESM(require_socket_types(), 1);
  var logger11 = mainLogger.createSubLogger("HuddleClient");
  var HuddleClient = class {
    /**
     * Connection Manager Instance, Hanlder socket connection and stores information about the connection
     */
    __socket;
    /**
     * Room Instance, Handles the room and its connection
     */
    __room;
    /**
     * Local Peer Instance, Handles the local peer and its connection
     */
    __localPeer;
    /**
     * Project Id of the Huddle01 Project
     */
    projectId;
    /**
     * Returns the underlying socket connection
     * @throws { Error } If the socket connection is not initialized
     */
    get socket() {
      if (!this.__socket) {
        throw new Error(
          "Socket Is Not Initialized, You need to connect to the Huddle01 Socket Servers first"
        );
      }
      return this.__socket;
    }
    /**
     * Returns the room instance, throws an error if the room is not created
     * @throws { Error } If the room is not created, Call createRoom() method before you can access the room
     */
    get room() {
      return this.__room;
    }
    get localPeer() {
      return this.__localPeer;
    }
    /**
     * Room Id of the current room
     */
    get roomId() {
      return this.room.roomId;
    }
    /**
     * Set a new region for the Huddle01 Media Servers
     */
    setRegion = (region) => {
      logger11.info("Setting a new region, ", region);
      this.socket.setRegion(region);
    };
    constructor(data) {
      if (data.options?.logging) {
        setLogLevel("trace");
      }
      logger11.info("\u2705 Initializing HuddleClient");
      this.projectId = data.projectId;
      this.__socket = Socket_default.create();
      this.__room = Room_default.create({
        autoConsume: data.options?.autoConsume
      });
      this.__localPeer = LocalPeer_default.create();
      const isLocalDev = this.projectId === "development";
      if (isLocalDev) {
        logger11.info("\u{1F534} Local Development Mode");
        this.socket.enableLocalDev();
      }
      this.__socket.on("closed", (code) => {
        logger11.info(
          "\u{1F50C} Socket Connection closed, closing the room and LocalPeer"
        );
        if (code === import_socket2.ESocketCloseCode.ROOM_CLOSED) {
          this.room.close("CLOSED");
        } else if (code === import_socket2.ESocketCloseCode.ROOM_ENTRY_DENIED) {
          this.room.close("DENIED");
        } else if (code === import_socket2.ESocketCloseCode.CONNECTION_EXPIRED) {
          logger11.info("\u{1F514} Room closed due to connection expired");
          this.room.close();
        } else if (code === import_socket2.ESocketCloseCode.KICKED) {
          this.room.close("KICKED");
        } else {
          this.room.close();
        }
        this.localPeer.close();
      });
      if (data.options?.activeSpeakers?.size) {
        this.__room.once("room-joined", () => {
          this.localPeer.activateActiveSpeakersNotification(
            data.options?.activeSpeakers?.size
          ).catch((error) => {
            logger11.error(
              "\u{1F534} Error while activating active speakers notification",
              error
            );
          });
        });
      }
    }
    /**
     * Default method to connect to the Huddle01 Media Room.
     *
     * This method connects to socket, creates a room, and then connects to the room;
     */
    joinRoom = async (data) => {
      logger11.info("\u{1F514} Joining the room with roomId,", data.roomId);
      if (this.socket.connectionState === "connecting") {
        logger11.warn(
          "\u{1F514} Socket is already connecting, waiting for the connection to be established"
        );
        return this.room;
      }
      if (this.room.state === "connecting") {
        logger11.warn("\u{1F514} Room join already in progress");
        return this.room;
      }
      if (this.localPeer.joined) {
        logger11.warn("\u{1F514} Already joined the room");
        return this.room;
      }
      try {
        await this.socket.connect({ token: data.token });
        logger11.debug("\u{1F680} Connecting to Room");
        this.room.roomId = data.roomId;
        const room = this.room.connect();
        return room;
      } catch (error) {
        logger11.error("\u{1F534} Error While Joining the Room");
        logger11.error(error);
        throw error;
      }
    };
    /**
     * Leave the room and disconnect from the socket
     */
    leaveRoom = () => {
      logger11.info("Leaving the room");
      this.socket.close(import_socket2.ESocketCloseCode.NORMAL_CLOSURE);
    };
    /**
     * Close the room and disconnect from the socket
     */
    closeRoom = () => {
      logger11.info("Closing the room");
      this.socket.publish("closeRoom", void 0);
    };
  };
  var HuddleClient_default = HuddleClient;
  return __toCommonJS(src_exports);
})();
/*! Bundled license information:

queue-microtask/index.js:
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
function Pointer_stringify(s,len){warnOnce("The JavaScript function 'Pointer_stringify(ptrToSomeCString)' is obsoleted and will be removed in a future Unity version. Please call 'UTF8ToString(ptrToSomeCString)' instead.");return UTF8ToString(s,len)}Module["Pointer_stringify"]=Pointer_stringify;var stackTraceReference="(^|\\n)(\\s+at\\s+|)jsStackTrace(\\s+\\(|@)([^\\n]+):\\d+:\\d+(\\)|)(\\n|$)";var stackTraceReferenceMatch=jsStackTrace().match(new RegExp(stackTraceReference));if(stackTraceReferenceMatch)Module.stackTraceRegExp=new RegExp(stackTraceReference.replace("([^\\n]+)",stackTraceReferenceMatch[4].replace(/[\\^${}[\]().*+?|]/g,"\\$&")).replace("jsStackTrace","[^\\n]+"));var abort=function(what){if(ABORT)return;ABORT=true;EXITSTATUS=1;if(typeof ENVIRONMENT_IS_PTHREAD!=="undefined"&&ENVIRONMENT_IS_PTHREAD)console.error("Pthread aborting at "+(new Error).stack);if(what!==undefined){out(what);err(what);what=JSON.stringify(what)}else{what=""}var message="abort("+what+") at "+stackTrace();if(Module.abortHandler&&Module.abortHandler(message))return;throw message};Module["SetFullscreen"]=function(fullscreen){if(typeof runtimeInitialized==="undefined"||!runtimeInitialized){console.log("Runtime not initialized yet.")}else if(typeof JSEvents==="undefined"){console.log("Player not loaded yet.")}else{var tmp=JSEvents.canPerformEventHandlerRequests;JSEvents.canPerformEventHandlerRequests=function(){return 1};Module.ccall("SetFullscreen",null,["number"],[fullscreen]);JSEvents.canPerformEventHandlerRequests=tmp}};if(!Module["ENVIRONMENT_IS_PTHREAD"]){Module["preRun"].push(function(){var unityFileSystemInit=Module["unityFileSystemInit"]||function(){FS.mkdir("/idbfs");FS.mount(IDBFS,{},"/idbfs");Module.addRunDependency("JS_FileSystem_Mount");FS.syncfs(true,function(err){if(err)console.log("IndexedDB is not available. Data will not persist in cache and PlayerPrefs will not be saved.");Module.removeRunDependency("JS_FileSystem_Mount")})};unityFileSystemInit()})}var videoInputDevices=[];var videoInputDevicesEnumerated=false;var removeEnumerateMediaDevicesRunDependency;var enumerateWatchdog=null;function matchToOldDevice(newDevice){var oldDevices=Object.keys(videoInputDevices);for(var i=0;i<oldDevices.length;++i){var old=videoInputDevices[oldDevices[i]];if(old.deviceId&&old.deviceId==newDevice.deviceId)return old}for(var i=0;i<oldDevices.length;++i){var old=videoInputDevices[oldDevices[i]];if(old==newDevice)return old}for(var i=0;i<oldDevices.length;++i){var old=videoInputDevices[oldDevices[i]];if(old.label&&old.label==newDevice.label)return old}for(var i=0;i<oldDevices.length;++i){var old=videoInputDevices[oldDevices[i]];if(old.groupId&&old.kind&&old.groupId==newDevice.groupId&&old.kind==newDevice.kind)return old}}function assignNewVideoInputId(){for(var i=0;;++i){if(!videoInputDevices[i])return i}}function updateVideoInputDevices(devices){removeEnumerateMediaDevicesRunDependency();videoInputDevices=[];var retainedDevices={};var newDevices=[];devices.forEach(function(device){if(device.kind==="videoinput"){var oldDevice=matchToOldDevice(device);if(oldDevice){retainedDevices[oldDevice.id]=oldDevice}else{newDevices.push(device)}}});videoInputDevices=retainedDevices;newDevices.forEach(function(device){if(!device.id){device.id=assignNewVideoInputId();device.name=device.label||"Video input #"+(device.id+1);device.isFrontFacing=device.name.toLowerCase().includes("front")||!device.name.toLowerCase().includes("front")&&!device.name.toLowerCase().includes("back");videoInputDevices[device.id]=device}})}function enumerateMediaDeviceList(){if(!videoInputDevices)return;navigator.mediaDevices.enumerateDevices().then(function(devices){updateVideoInputDevices(devices);videoInputDevicesEnumerated=true}).catch(function(e){console.warn("Unable to enumerate media devices: "+e+"\nWebcams will not be available.");disableAccessToMediaDevices()});if(/Firefox/.test(navigator.userAgent)){setTimeout(enumerateMediaDeviceList,6e4);warnOnce("Applying workaround to Firefox bug https://bugzilla.mozilla.org/show_bug.cgi?id=1397977")}}function disableAccessToMediaDevices(){if(navigator.mediaDevices&&navigator.mediaDevices.removeEventListener){navigator.mediaDevices.removeEventListener("devicechange",enumerateMediaDeviceList)}videoInputDevices=null}Module["disableAccessToMediaDevices"]=disableAccessToMediaDevices;if(!navigator.mediaDevices){console.warn("navigator.mediaDevices not supported by this browser. Webcam access will not be available."+(location.protocol=="https:"?"":" Try hosting the page over HTTPS, because some browsers disable webcam access when insecure HTTP is being used."));disableAccessToMediaDevices()}else if(typeof ENVIRONMENT_IS_PTHREAD==="undefined"||!ENVIRONMENT_IS_PTHREAD)setTimeout(function(){try{addRunDependency("enumerateMediaDevices");removeEnumerateMediaDevicesRunDependency=function(){if(enumerateWatchdog!==null)clearTimeout(enumerateWatchdog);removeRunDependency("enumerateMediaDevices");if(navigator.mediaDevices)console.log("navigator.mediaDevices support available");removeEnumerateMediaDevicesRunDependency=function(){}};enumerateMediaDeviceList();enumerateWatchdog=setTimeout(removeEnumerateMediaDevicesRunDependency,1e3);navigator.mediaDevices.addEventListener("devicechange",enumerateMediaDeviceList)}catch(e){console.warn("Unable to enumerate media devices: "+e);disableAccessToMediaDevices()}},0);function SendMessage(gameObject,func,param){var func_cstr=stringToNewUTF8(func);var gameObject_cstr=stringToNewUTF8(gameObject);var param_cstr=0;try{if(param===undefined)_SendMessage(gameObject_cstr,func_cstr);else if(typeof param==="string"){param_cstr=stringToNewUTF8(param);_SendMessageString(gameObject_cstr,func_cstr,param_cstr)}else if(typeof param==="number")_SendMessageFloat(gameObject_cstr,func_cstr,param);else throw""+param+" is does not have a type which is supported by SendMessage."}finally{_free(param_cstr);_free(gameObject_cstr);_free(func_cstr)}}Module["SendMessage"]=SendMessage;var moduleOverrides=Object.assign({},Module);var arguments_=[];var thisProgram="./this.program";var quit_=(status,toThrow)=>{throw toThrow};var ENVIRONMENT_IS_WEB=typeof window=="object";var ENVIRONMENT_IS_WORKER=typeof importScripts=="function";var ENVIRONMENT_IS_NODE=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string";var scriptDirectory="";function locateFile(path){if(Module["locateFile"]){return Module["locateFile"](path,scriptDirectory)}return scriptDirectory+path}var read_,readAsync,readBinary,setWindowTitle;function logExceptionOnExit(e){if(e instanceof ExitStatus)return;let toLog=e;err("exiting due to exception: "+toLog)}var fs;var nodePath;var requireNodeFS;if(ENVIRONMENT_IS_NODE){if(ENVIRONMENT_IS_WORKER){scriptDirectory=require("path").dirname(scriptDirectory)+"/"}else{scriptDirectory=__dirname+"/"}requireNodeFS=(()=>{if(!nodePath){fs=require("fs");nodePath=require("path")}});read_=function shell_read(filename,binary){requireNodeFS();filename=nodePath["normalize"](filename);return fs.readFileSync(filename,binary?undefined:"utf8")};readBinary=(filename=>{var ret=read_(filename,true);if(!ret.buffer){ret=new Uint8Array(ret)}return ret});readAsync=((filename,onload,onerror)=>{requireNodeFS();filename=nodePath["normalize"](filename);fs.readFile(filename,function(err,data){if(err)onerror(err);else onload(data.buffer)})});if(process["argv"].length>1){thisProgram=process["argv"][1].replace(/\\/g,"/")}arguments_=process["argv"].slice(2);process["on"]("uncaughtException",function(ex){if(!(ex instanceof ExitStatus)){throw ex}});process["on"]("unhandledRejection",function(reason){throw reason});quit_=((status,toThrow)=>{if(keepRuntimeAlive()){process["exitCode"]=status;throw toThrow}logExceptionOnExit(toThrow);process["exit"](status)});Module["inspect"]=function(){return"[Emscripten Module object]"}}else if(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER){if(ENVIRONMENT_IS_WORKER){scriptDirectory=self.location.href}else if(typeof document!="undefined"&&document.currentScript){scriptDirectory=document.currentScript.src}if(_scriptDir){scriptDirectory=_scriptDir}if(scriptDirectory.indexOf("blob:")!==0){scriptDirectory=scriptDirectory.substr(0,scriptDirectory.replace(/[?#].*/,"").lastIndexOf("/")+1)}else{scriptDirectory=""}{read_=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.send(null);return xhr.responseText});if(ENVIRONMENT_IS_WORKER){readBinary=(url=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,false);xhr.responseType="arraybuffer";xhr.send(null);return new Uint8Array(xhr.response)})}readAsync=((url,onload,onerror)=>{var xhr=new XMLHttpRequest;xhr.open("GET",url,true);xhr.responseType="arraybuffer";xhr.onload=(()=>{if(xhr.status==200||xhr.status==0&&xhr.response){onload(xhr.response);return}onerror()});xhr.onerror=onerror;xhr.send(null)})}setWindowTitle=(title=>document.title=title)}else{}var out=Module["print"]||console.log.bind(console);var err=Module["printErr"]||console.warn.bind(console);Object.assign(Module,moduleOverrides);moduleOverrides=null;if(Module["arguments"])arguments_=Module["arguments"];if(Module["thisProgram"])thisProgram=Module["thisProgram"];if(Module["quit"])quit_=Module["quit"];var POINTER_SIZE=4;function warnOnce(text){if(!warnOnce.shown)warnOnce.shown={};if(!warnOnce.shown[text]){warnOnce.shown[text]=1;err(text)}}function convertJsFunctionToWasm(func,sig){if(typeof WebAssembly.Function=="function"){var typeNames={"i":"i32","j":"i64","f":"f32","d":"f64"};var type={parameters:[],results:sig[0]=="v"?[]:[typeNames[sig[0]]]};for(var i=1;i<sig.length;++i){type.parameters.push(typeNames[sig[i]])}return new WebAssembly.Function(type,func)}var typeSection=[1,0,1,96];var sigRet=sig.slice(0,1);var sigParam=sig.slice(1);var typeCodes={"i":127,"j":126,"f":125,"d":124};typeSection.push(sigParam.length);for(var i=0;i<sigParam.length;++i){typeSection.push(typeCodes[sigParam[i]])}if(sigRet=="v"){typeSection.push(0)}else{typeSection=typeSection.concat([1,typeCodes[sigRet]])}typeSection[1]=typeSection.length-2;var bytes=new Uint8Array([0,97,115,109,1,0,0,0].concat(typeSection,[2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0]));var module=new WebAssembly.Module(bytes);var instance=new WebAssembly.Instance(module,{"e":{"f":func}});var wrappedFunc=instance.exports["f"];return wrappedFunc}var freeTableIndexes=[];var functionsInTableMap;function getEmptyTableSlot(){if(freeTableIndexes.length){return freeTableIndexes.pop()}try{wasmTable.grow(1)}catch(err){if(!(err instanceof RangeError)){throw err}throw"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH."}return wasmTable.length-1}function updateTableMap(offset,count){for(var i=offset;i<offset+count;i++){var item=getWasmTableEntry(i);if(item){functionsInTableMap.set(item,i)}}}var tempRet0=0;var setTempRet0=value=>{tempRet0=value};var getTempRet0=()=>tempRet0;var wasmBinary;if(Module["wasmBinary"])wasmBinary=Module["wasmBinary"];var noExitRuntime=Module["noExitRuntime"]||true;if(typeof WebAssembly!="object"){abort("no native wasm support detected")}var wasmMemory;var ABORT=false;var EXITSTATUS;function assert(condition,text){if(!condition){abort(text)}}function getCFunc(ident){var func=Module["_"+ident];return func}function ccall(ident,returnType,argTypes,args,opts){var toC={"string":function(str){var ret=0;if(str!==null&&str!==undefined&&str!==0){var len=(str.length<<2)+1;ret=stackAlloc(len);stringToUTF8(str,ret,len)}return ret},"array":function(arr){var ret=stackAlloc(arr.length);writeArrayToMemory(arr,ret);return ret}};function convertReturnValue(ret){if(returnType==="string")return UTF8ToString(ret);if(returnType==="boolean")return Boolean(ret);return ret}var func=getCFunc(ident);var cArgs=[];var stack=0;if(args){for(var i=0;i<args.length;i++){var converter=toC[argTypes[i]];if(converter){if(stack===0)stack=stackSave();cArgs[i]=converter(args[i])}else{cArgs[i]=args[i]}}}var ret=func.apply(null,cArgs);function onDone(ret){if(stack!==0)stackRestore(stack);return convertReturnValue(ret)}ret=onDone(ret);return ret}function cwrap(ident,returnType,argTypes,opts){argTypes=argTypes||[];var numericArgs=argTypes.every(function(type){return type==="number"});var numericRet=returnType!=="string";if(numericRet&&numericArgs&&!opts){return getCFunc(ident)}return function(){return ccall(ident,returnType,argTypes,arguments,opts)}}var ALLOC_STACK=1;var UTF8Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):undefined;function UTF8ArrayToString(heapOrArray,idx,maxBytesToRead){var endIdx=idx+maxBytesToRead;var endPtr=idx;while(heapOrArray[endPtr]&&!(endPtr>=endIdx))++endPtr;if(endPtr-idx>16&&heapOrArray.buffer&&UTF8Decoder){return UTF8Decoder.decode(heapOrArray.subarray(idx,endPtr))}else{var str="";while(idx<endPtr){var u0=heapOrArray[idx++];if(!(u0&128)){str+=String.fromCharCode(u0);continue}var u1=heapOrArray[idx++]&63;if((u0&224)==192){str+=String.fromCharCode((u0&31)<<6|u1);continue}var u2=heapOrArray[idx++]&63;if((u0&240)==224){u0=(u0&15)<<12|u1<<6|u2}else{u0=(u0&7)<<18|u1<<12|u2<<6|heapOrArray[idx++]&63}if(u0<65536){str+=String.fromCharCode(u0)}else{var ch=u0-65536;str+=String.fromCharCode(55296|ch>>10,56320|ch&1023)}}}return str}function UTF8ToString(ptr,maxBytesToRead){return ptr?UTF8ArrayToString(HEAPU8,ptr,maxBytesToRead):""}function stringToUTF8Array(str,heap,outIdx,maxBytesToWrite){if(!(maxBytesToWrite>0))return 0;var startIdx=outIdx;var endIdx=outIdx+maxBytesToWrite-1;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343){var u1=str.charCodeAt(++i);u=65536+((u&1023)<<10)|u1&1023}if(u<=127){if(outIdx>=endIdx)break;heap[outIdx++]=u}else if(u<=2047){if(outIdx+1>=endIdx)break;heap[outIdx++]=192|u>>6;heap[outIdx++]=128|u&63}else if(u<=65535){if(outIdx+2>=endIdx)break;heap[outIdx++]=224|u>>12;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}else{if(outIdx+3>=endIdx)break;heap[outIdx++]=240|u>>18;heap[outIdx++]=128|u>>12&63;heap[outIdx++]=128|u>>6&63;heap[outIdx++]=128|u&63}}heap[outIdx]=0;return outIdx-startIdx}function stringToUTF8(str,outPtr,maxBytesToWrite){return stringToUTF8Array(str,HEAPU8,outPtr,maxBytesToWrite)}function lengthBytesUTF8(str){var len=0;for(var i=0;i<str.length;++i){var u=str.charCodeAt(i);if(u>=55296&&u<=57343)u=65536+((u&1023)<<10)|str.charCodeAt(++i)&1023;if(u<=127)++len;else if(u<=2047)len+=2;else if(u<=65535)len+=3;else len+=4}return len}var UTF16Decoder=typeof TextDecoder!="undefined"?new TextDecoder("utf-16le"):undefined;function allocateUTF8(str){var size=lengthBytesUTF8(str)+1;var ret=_malloc(size);if(ret)stringToUTF8Array(str,HEAP8,ret,size);return ret}function allocateUTF8OnStack(str){var size=lengthBytesUTF8(str)+1;var ret=stackAlloc(size);stringToUTF8Array(str,HEAP8,ret,size);return ret}function writeArrayToMemory(array,buffer){HEAP8.set(array,buffer)}function writeAsciiToMemory(str,buffer,dontAddNull){for(var i=0;i<str.length;++i){HEAP8[buffer++>>0]=str.charCodeAt(i)}if(!dontAddNull)HEAP8[buffer>>0]=0}var buffer,HEAP8,HEAPU8,HEAP16,HEAPU16,HEAP32,HEAPU32,HEAPF32,HEAPF64;function updateGlobalBufferAndViews(buf){buffer=buf;Module["HEAP8"]=HEAP8=new Int8Array(buf);Module["HEAP16"]=HEAP16=new Int16Array(buf);Module["HEAP32"]=HEAP32=new Int32Array(buf);Module["HEAPU8"]=HEAPU8=new Uint8Array(buf);Module["HEAPU16"]=HEAPU16=new Uint16Array(buf);Module["HEAPU32"]=HEAPU32=new Uint32Array(buf);Module["HEAPF32"]=HEAPF32=new Float32Array(buf);Module["HEAPF64"]=HEAPF64=new Float64Array(buf)}var INITIAL_MEMORY=Module["INITIAL_MEMORY"]||33554432;var wasmTable;var __ATPRERUN__=[];var __ATINIT__=[];var __ATMAIN__=[];var __ATEXIT__=[];var __ATPOSTRUN__=[];var runtimeInitialized=false;function keepRuntimeAlive(){return noExitRuntime}function preRun(){if(Module["preRun"]){if(typeof Module["preRun"]=="function")Module["preRun"]=[Module["preRun"]];while(Module["preRun"].length){addOnPreRun(Module["preRun"].shift())}}callRuntimeCallbacks(__ATPRERUN__)}function initRuntime(){runtimeInitialized=true;if(!Module["noFSInit"]&&!FS.init.initialized)FS.init();FS.ignorePermissions=false;TTY.init();SOCKFS.root=FS.mount(SOCKFS,{},null);PIPEFS.root=FS.mount(PIPEFS,{},null);callRuntimeCallbacks(__ATINIT__)}function preMain(){callRuntimeCallbacks(__ATMAIN__)}function postRun(){if(Module["postRun"]){if(typeof Module["postRun"]=="function")Module["postRun"]=[Module["postRun"]];while(Module["postRun"].length){addOnPostRun(Module["postRun"].shift())}}callRuntimeCallbacks(__ATPOSTRUN__)}function addOnPreRun(cb){__ATPRERUN__.unshift(cb)}function addOnInit(cb){__ATINIT__.unshift(cb)}function addOnPostRun(cb){__ATPOSTRUN__.unshift(cb)}var runDependencies=0;var runDependencyWatcher=null;var dependenciesFulfilled=null;function getUniqueRunDependency(id){return id}function addRunDependency(id){runDependencies++;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}}function removeRunDependency(id){runDependencies--;if(Module["monitorRunDependencies"]){Module["monitorRunDependencies"](runDependencies)}if(runDependencies==0){if(runDependencyWatcher!==null){clearInterval(runDependencyWatcher);runDependencyWatcher=null}if(dependenciesFulfilled){var callback=dependenciesFulfilled;dependenciesFulfilled=null;callback()}}}Module["preloadedImages"]={};Module["preloadedAudios"]={};function abort(what){{if(Module["onAbort"]){Module["onAbort"](what)}}what="Aborted("+what+")";err(what);ABORT=true;EXITSTATUS=1;what+=". Build with -s ASSERTIONS=1 for more info.";var e=new WebAssembly.RuntimeError(what);readyPromiseReject(e);throw e}var dataURIPrefix="data:application/octet-stream;base64,";function isDataURI(filename){return filename.startsWith(dataURIPrefix)}function isFileURI(filename){return filename.startsWith("file://")}var wasmBinaryFile;wasmBinaryFile="build.wasm";if(!isDataURI(wasmBinaryFile)){wasmBinaryFile=locateFile(wasmBinaryFile)}function getBinary(file){try{if(file==wasmBinaryFile&&wasmBinary){return new Uint8Array(wasmBinary)}if(readBinary){return readBinary(file)}else{throw"both async and sync fetching of the wasm failed"}}catch(err){abort(err)}}function getBinaryPromise(){if(!wasmBinary&&(ENVIRONMENT_IS_WEB||ENVIRONMENT_IS_WORKER)){if(typeof fetch=="function"&&!isFileURI(wasmBinaryFile)){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){if(!response["ok"]){throw"failed to load wasm binary file at '"+wasmBinaryFile+"'"}return response["arrayBuffer"]()}).catch(function(){return getBinary(wasmBinaryFile)})}else{if(readAsync){return new Promise(function(resolve,reject){readAsync(wasmBinaryFile,function(response){resolve(new Uint8Array(response))},reject)})}}}return Promise.resolve().then(function(){return getBinary(wasmBinaryFile)})}function createWasm(){var info={"env":asmLibraryArg,"wasi_snapshot_preview1":asmLibraryArg};function receiveInstance(instance,module){var exports=instance.exports;Module["asm"]=exports;wasmMemory=Module["asm"]["memory"];updateGlobalBufferAndViews(wasmMemory.buffer);wasmTable=Module["asm"]["__indirect_function_table"];addOnInit(Module["asm"]["__wasm_call_ctors"]);removeRunDependency("wasm-instantiate")}addRunDependency("wasm-instantiate");function receiveInstantiationResult(result){receiveInstance(result["instance"])}function instantiateArrayBuffer(receiver){return getBinaryPromise().then(function(binary){return WebAssembly.instantiate(binary,info)}).then(function(instance){return instance}).then(receiver,function(reason){err("failed to asynchronously prepare wasm: "+reason);abort(reason)})}function instantiateAsync(){if(!wasmBinary&&typeof WebAssembly.instantiateStreaming=="function"&&!isDataURI(wasmBinaryFile)&&!isFileURI(wasmBinaryFile)&&typeof fetch=="function"){return fetch(wasmBinaryFile,{credentials:"same-origin"}).then(function(response){var result=WebAssembly.instantiateStreaming(response,info);return result.then(receiveInstantiationResult,function(reason){err("wasm streaming compile failed: "+reason);err("falling back to ArrayBuffer instantiation");return instantiateArrayBuffer(receiveInstantiationResult)})})}else{return instantiateArrayBuffer(receiveInstantiationResult)}}if(Module["instantiateWasm"]){try{var exports=Module["instantiateWasm"](info,receiveInstance);return exports}catch(e){err("Module.instantiateWasm callback failed with error: "+e);return false}}instantiateAsync().catch(readyPromiseReject);return{}}var tempDouble;var tempI64;var ASM_CONSTS={9879592:function(){return Module.webglContextAttributes.premultipliedAlpha},9879653:function(){return Module.webglContextAttributes.preserveDrawingBuffer},9879717:function(){return Module.webglContextAttributes.powerPreference}};function callRuntimeCallbacks(callbacks){while(callbacks.length>0){var callback=callbacks.shift();if(typeof callback=="function"){callback(Module);continue}var func=callback.func;if(typeof func=="number"){if(callback.arg===undefined){(function(){dynCall_v.call(null,func)})()}else{(function(a1){dynCall_vi.apply(null,[func,a1])})(callback.arg)}}else{func(callback.arg===undefined?null:callback.arg)}}}function withStackSave(f){var stack=stackSave();var ret=f();stackRestore(stack);return ret}function demangle(func){return func}function demangleAll(text){var regex=/\b_Z[\w\d_]+/g;return text.replace(regex,function(x){var y=demangle(x);return x===y?x:y+" ["+x+"]"})}function dynCallLegacy(sig,ptr,args){var f=Module["dynCall_"+sig];return args&&args.length?f.apply(null,[ptr].concat(args)):f.call(null,ptr)}var wasmTableMirror=[];function getWasmTableEntry(funcPtr){var func=wasmTableMirror[funcPtr];if(!func){if(funcPtr>=wasmTableMirror.length)wasmTableMirror.length=funcPtr+1;wasmTableMirror[funcPtr]=func=wasmTable.get(funcPtr)}return func}function dynCall(sig,ptr,args){return dynCallLegacy(sig,ptr,args)}function handleException(e){if(e instanceof ExitStatus||e=="unwind"){return EXITSTATUS}quit_(1,e)}function jsStackTrace(){var error=new Error;if(!error.stack){try{throw new Error}catch(e){error=e}if(!error.stack){return"(no stack trace available)"}}return error.stack.toString()}function setWasmTableEntry(idx,func){wasmTable.set(idx,func);wasmTableMirror[idx]=func}function stackTrace(){var js=jsStackTrace();if(Module["extraStackTrace"])js+="\n"+Module["extraStackTrace"]();return demangleAll(js)}function _GetJSMemoryInfo(totalJSptr,usedJSptr){if(performance.memory){HEAPF64[totalJSptr>>3]=performance.memory.totalJSHeapSize;HEAPF64[usedJSptr>>3]=performance.memory.usedJSHeapSize}else{HEAPF64[totalJSptr>>3]=NaN;HEAPF64[usedJSptr>>3]=NaN}}var JS_Accelerometer=null;var JS_Accelerometer_callback=0;function _JS_Accelerometer_IsRunning(){return JS_Accelerometer&&JS_Accelerometer.activated||JS_Accelerometer_callback!=0}var JS_Accelerometer_multiplier=1;var JS_Accelerometer_lastValue={x:0,y:0,z:0};function JS_Accelerometer_eventHandler(){JS_Accelerometer_lastValue={x:JS_Accelerometer.x*JS_Accelerometer_multiplier,y:JS_Accelerometer.y*JS_Accelerometer_multiplier,z:JS_Accelerometer.z*JS_Accelerometer_multiplier};if(JS_Accelerometer_callback!=0)dynCall_vfff(JS_Accelerometer_callback,JS_Accelerometer_lastValue.x,JS_Accelerometer_lastValue.y,JS_Accelerometer_lastValue.z)}var JS_Accelerometer_frequencyRequest=0;var JS_Accelerometer_frequency=0;var JS_LinearAccelerationSensor_callback=0;var JS_GravitySensor_callback=0;var JS_Gyroscope_callback=0;function JS_ComputeGravity(accelerometerValue,linearAccelerationValue){var difference={x:accelerometerValue.x-linearAccelerationValue.x,y:accelerometerValue.y-linearAccelerationValue.y,z:accelerometerValue.z-linearAccelerationValue.z};var differenceMagnitudeSq=difference.x*difference.x+difference.y*difference.y+difference.z*difference.z;var sum={x:accelerometerValue.x+linearAccelerationValue.x,y:accelerometerValue.y+linearAccelerationValue.y,z:accelerometerValue.z+linearAccelerationValue.z};var sumMagnitudeSq=sum.x*sum.x+sum.y*sum.y+sum.z*sum.z;return differenceMagnitudeSq<=sumMagnitudeSq?difference:sum}function JS_DeviceMotion_eventHandler(event){var accelerometerValue={x:event.accelerationIncludingGravity.x*JS_Accelerometer_multiplier,y:event.accelerationIncludingGravity.y*JS_Accelerometer_multiplier,z:event.accelerationIncludingGravity.z*JS_Accelerometer_multiplier};if(JS_Accelerometer_callback!=0)dynCall_vfff(JS_Accelerometer_callback,accelerometerValue.x,accelerometerValue.y,accelerometerValue.z);var linearAccelerationValue={x:event.acceleration.x*JS_Accelerometer_multiplier,y:event.acceleration.y*JS_Accelerometer_multiplier,z:event.acceleration.z*JS_Accelerometer_multiplier};if(JS_LinearAccelerationSensor_callback!=0)dynCall_vfff(JS_LinearAccelerationSensor_callback,linearAccelerationValue.x,linearAccelerationValue.y,linearAccelerationValue.z);if(JS_GravitySensor_callback!=0){var gravityValue=JS_ComputeGravity(accelerometerValue,linearAccelerationValue);dynCall_vfff(JS_GravitySensor_callback,gravityValue.x,gravityValue.y,gravityValue.z)}if(JS_Gyroscope_callback!=0){var degToRad=Math.PI/180;dynCall_vfff(JS_Gyroscope_callback,event.rotationRate.alpha*degToRad,event.rotationRate.beta*degToRad,event.rotationRate.gamma*degToRad)}}var JS_DeviceSensorPermissions=0;function JS_RequestDeviceSensorPermissions(permissions){if(permissions&1){if(typeof DeviceOrientationEvent.requestPermission==="function"){DeviceOrientationEvent.requestPermission().then(function(permissionState){if(permissionState==="granted"){JS_DeviceSensorPermissions&=~1}else{warnOnce("DeviceOrientationEvent permission not granted")}}).catch(function(err){warnOnce(err);JS_DeviceSensorPermissions|=1})}}if(permissions&2){if(typeof DeviceMotionEvent.requestPermission==="function"){DeviceMotionEvent.requestPermission().then(function(permissionState){if(permissionState==="granted"){JS_DeviceSensorPermissions&=~2}else{warnOnce("DeviceMotionEvent permission not granted")}}).catch(function(err){warnOnce(err);JS_DeviceSensorPermissions|=2})}}}function JS_DeviceMotion_add(){if(JS_Accelerometer_callback==0&&JS_LinearAccelerationSensor_callback==0&&JS_GravitySensor_callback==0&&JS_Gyroscope_callback==0){JS_RequestDeviceSensorPermissions(2);window.addEventListener("devicemotion",JS_DeviceMotion_eventHandler)}}function JS_DefineAccelerometerMultiplier(){var g=9.80665;JS_Accelerometer_multiplier=/(iPhone|iPad|Macintosh)/i.test(navigator.userAgent)?1/g:-1/g}function _JS_Accelerometer_Start(callback,frequency){JS_DefineAccelerometerMultiplier();if(typeof Accelerometer==="undefined"){JS_DeviceMotion_add();if(callback!=0)JS_Accelerometer_callback=callback;return}if(callback!=0)JS_Accelerometer_callback=callback;function InitializeAccelerometer(frequency){JS_Accelerometer=new Accelerometer({frequency:frequency,referenceFrame:"device"});JS_Accelerometer.addEventListener("reading",JS_Accelerometer_eventHandler);JS_Accelerometer.addEventListener("error",function(e){warnOnce(e.error?e.error:e)});JS_Accelerometer.start();JS_Accelerometer_frequency=frequency}if(JS_Accelerometer){if(JS_Accelerometer_frequency!=frequency){JS_Accelerometer.stop();JS_Accelerometer.removeEventListener("reading",JS_Accelerometer_eventHandler);InitializeAccelerometer(frequency)}}else if(JS_Accelerometer_frequencyRequest!=0){JS_Accelerometer_frequencyRequest=frequency}else{JS_Accelerometer_frequencyRequest=frequency;navigator.permissions.query({name:"accelerometer"}).then(function(result){if(result.state==="granted"){InitializeAccelerometer(JS_Accelerometer_frequencyRequest)}else{warnOnce("No permission to use Accelerometer.")}JS_Accelerometer_frequencyRequest=0})}}function JS_DeviceMotion_remove(){if(JS_Accelerometer_callback==0&&JS_LinearAccelerationSensor_callback==0&&JS_GravitySensor_callback==0&&JS_Gyroscope_callback==0){window.removeEventListener("devicemotion",JS_DeviceOrientation_eventHandler)}}function _JS_Accelerometer_Stop(){if(JS_Accelerometer){if(typeof GravitySensor!=="undefined"||JS_GravitySensor_callback==0){JS_Accelerometer.stop();JS_Accelerometer.removeEventListener("reading",JS_Accelerometer_eventHandler);JS_Accelerometer=null}JS_Accelerometer_callback=0;JS_Accelerometer_frequency=0}else if(JS_Accelerometer_callback!=0){JS_Accelerometer_callback=0;JS_DeviceMotion_remove()}}var ExceptionsSeen=0;function _JS_CallAsLongAsNoExceptionsSeen(cb){if(!ExceptionsSeen){try{(function(){dynCall_v.call(null,cb)})()}catch(e){ExceptionsSeen=1;console.error("Uncaught exception from main loop:");console.error(e);console.error("Halting program.");if(Module.errorHandler)Module.errorHandler(e);throw e}}}function _JS_Cursor_SetImage(ptr,length){var binary="";for(var i=0;i<length;i++)binary+=String.fromCharCode(HEAPU8[ptr+i]);Module.canvas.style.cursor="url(data:image/cur;base64,"+btoa(binary)+"),default"}function _JS_Cursor_SetShow(show){Module.canvas.style.cursor=show?"default":"none"}function jsDomCssEscapeId(id){if(typeof window.CSS!=="undefined"&&typeof window.CSS.escape!=="undefined"){return window.CSS.escape(id)}return id.replace(/(#|\.|\+|\[|\]|\(|\)|\{|\})/g,"\\$1")}function jsCanvasSelector(){var canvasId=Module["canvas"]?Module["canvas"].id:"unity-canvas";return"#"+jsDomCssEscapeId(canvasId)}function _JS_DOM_MapViewportCoordinateToElementLocalCoordinate(viewportX,viewportY,targetX,targetY){var canvas=document.querySelector(jsCanvasSelector());var rect=canvas&&canvas.getBoundingClientRect();HEAPU32[targetX>>2]=viewportX-(rect?rect.left:0);HEAPU32[targetY>>2]=viewportY-(rect?rect.top:0)}function stringToNewUTF8(jsString){var length=lengthBytesUTF8(jsString)+1;var cString=_malloc(length);stringToUTF8(jsString,cString,length);return cString}function _JS_DOM_UnityCanvasSelector(){var canvasSelector=jsCanvasSelector();if(_JS_DOM_UnityCanvasSelector.selector!=canvasSelector){_free(_JS_DOM_UnityCanvasSelector.ptr);_JS_DOM_UnityCanvasSelector.ptr=stringToNewUTF8(canvasSelector);_JS_DOM_UnityCanvasSelector.selector=canvasSelector}return _JS_DOM_UnityCanvasSelector.ptr}function _JS_Eval_OpenURL(ptr){var str=UTF8ToString(ptr);window.open(str,"_blank","")}var fs={numPendingSync:0,syncInternal:1e3,syncInProgress:false,sync:function(onlyPendingSync){if(onlyPendingSync){if(fs.numPendingSync==0)return}else if(fs.syncInProgress){fs.numPendingSync++;return}fs.syncInProgress=true;FS.syncfs(false,function(err){fs.syncInProgress=false});fs.numPendingSync=0}};function _JS_FileSystem_Initialize(){Module.setInterval(function(){fs.sync(true)},fs.syncInternal)}function _JS_FileSystem_Sync(){fs.sync(false)}var JS_GravitySensor=null;function _JS_GravitySensor_IsRunning(){return typeof GravitySensor!=="undefined"?JS_GravitySensor&&JS_GravitySensor.activated:JS_GravitySensor_callback!=0}function JS_GravitySensor_eventHandler(){if(JS_GravitySensor_callback!=0)dynCall_vfff(JS_GravitySensor_callback,JS_GravitySensor.x*JS_Accelerometer_multiplier,JS_GravitySensor.y*JS_Accelerometer_multiplier,JS_GravitySensor.z*JS_Accelerometer_multiplier)}var JS_GravitySensor_frequencyRequest=0;var JS_LinearAccelerationSensor=null;function JS_LinearAccelerationSensor_eventHandler(){var linearAccelerationValue={x:JS_LinearAccelerationSensor.x*JS_Accelerometer_multiplier,y:JS_LinearAccelerationSensor.y*JS_Accelerometer_multiplier,z:JS_LinearAccelerationSensor.z*JS_Accelerometer_multiplier};if(JS_LinearAccelerationSensor_callback!=0)dynCall_vfff(JS_LinearAccelerationSensor_callback,linearAccelerationValue.x,linearAccelerationValue.y,linearAccelerationValue.z);if(JS_GravitySensor_callback!=0&&typeof GravitySensor==="undefined"){var gravityValue=JS_ComputeGravity(JS_Accelerometer_lastValue,linearAccelerationValue);dynCall_vfff(JS_GravitySensor_callback,gravityValue.x,gravityValue.y,gravityValue.z)}}var JS_LinearAccelerationSensor_frequencyRequest=0;var JS_LinearAccelerationSensor_frequency=0;function _JS_LinearAccelerationSensor_Start(callback,frequency){JS_DefineAccelerometerMultiplier();if(typeof LinearAccelerationSensor==="undefined"){JS_DeviceMotion_add();if(callback!=0)JS_LinearAccelerationSensor_callback=callback;return}if(callback!=0)JS_LinearAccelerationSensor_callback=callback;function InitializeLinearAccelerationSensor(frequency){JS_LinearAccelerationSensor=new LinearAccelerationSensor({frequency:frequency,referenceFrame:"device"});JS_LinearAccelerationSensor.addEventListener("reading",JS_LinearAccelerationSensor_eventHandler);JS_LinearAccelerationSensor.addEventListener("error",function(e){warnOnce(e.error?e.error:e)});JS_LinearAccelerationSensor.start();JS_LinearAccelerationSensor_frequency=frequency}if(JS_LinearAccelerationSensor){if(JS_LinearAccelerationSensor_frequency!=frequency){JS_LinearAccelerationSensor.stop();JS_LinearAccelerationSensor.removeEventListener("reading",JS_LinearAccelerationSensor_eventHandler);InitializeLinearAccelerationSensor(frequency)}}else if(JS_LinearAccelerationSensor_frequencyRequest!=0){JS_LinearAccelerationSensor_frequencyRequest=frequency}else{JS_LinearAccelerationSensor_frequencyRequest=frequency;navigator.permissions.query({name:"accelerometer"}).then(function(result){if(result.state==="granted"){InitializeLinearAccelerationSensor(JS_LinearAccelerationSensor_frequencyRequest)}else{warnOnce("No permission to use LinearAccelerationSensor.")}JS_LinearAccelerationSensor_frequencyRequest=0})}}function _JS_GravitySensor_Start(callback,frequency){if(typeof GravitySensor==="undefined"){_JS_Accelerometer_Start(0,Math.max(frequency,JS_Accelerometer_frequency));_JS_LinearAccelerationSensor_Start(0,Math.max(frequency,JS_LinearAccelerationSensor_frequency));JS_GravitySensor_callback=callback;return}JS_DefineAccelerometerMultiplier();JS_GravitySensor_callback=callback;function InitializeGravitySensor(frequency){JS_GravitySensor=new GravitySensor({frequency:frequency,referenceFrame:"device"});JS_GravitySensor.addEventListener("reading",JS_GravitySensor_eventHandler);JS_GravitySensor.addEventListener("error",function(e){warnOnce(e.error?e.error:e)});JS_GravitySensor.start()}if(JS_GravitySensor){JS_GravitySensor.stop();JS_GravitySensor.removeEventListener("reading",JS_GravitySensor_eventHandler);InitializeGravitySensor(frequency)}else if(JS_GravitySensor_frequencyRequest!=0){JS_GravitySensor_frequencyRequest=frequency}else{JS_GravitySensor_frequencyRequest=frequency;navigator.permissions.query({name:"accelerometer"}).then(function(result){if(result.state==="granted"){InitializeGravitySensor(JS_GravitySensor_frequencyRequest)}else{warnOnce("No permission to use GravitySensor.")}JS_GravitySensor_frequencyRequest=0})}}function _JS_LinearAccelerationSensor_Stop(){if(JS_LinearAccelerationSensor){if(typeof GravitySensor!=="undefined"||JS_GravitySensor_callback==0){JS_LinearAccelerationSensor.stop();JS_LinearAccelerationSensor.removeEventListener("reading",JS_LinearAccelerationSensor_eventHandler);JS_LinearAccelerationSensor=null}JS_LinearAccelerationSensor_callback=0;JS_LinearAccelerationSensor_frequency=0}else if(JS_LinearAccelerationSensor_callback!=0){JS_LinearAccelerationSensor_callback=0;JS_DeviceMotion_remove()}}function _JS_GravitySensor_Stop(){JS_GravitySensor_callback=0;if(typeof GravitySensor==="undefined"){if(JS_Accelerometer_callback==0)_JS_Accelerometer_Stop();if(JS_LinearAccelerationSensor_callback==0)_JS_LinearAccelerationSensor_Stop();return}if(JS_GravitySensor){JS_GravitySensor.stop();JS_GravitySensor.removeEventListener("reading",JS_GravitySensor_eventHandler);JS_GravitySensor=null}}function _JS_GuardAgainstJsExceptions(cb){try{(function(){dynCall_v.call(null,cb)})()}catch(e){console.warn(e)}}var JS_Gyroscope=null;function _JS_Gyroscope_IsRunning(){return JS_Gyroscope&&JS_Gyroscope.activated||JS_Gyroscope_callback!=0}function JS_Gyroscope_eventHandler(){if(JS_Gyroscope_callback!=0)dynCall_vfff(JS_Gyroscope_callback,JS_Gyroscope.x,JS_Gyroscope.y,JS_Gyroscope.z)}var JS_Gyroscope_frequencyRequest=0;function _JS_Gyroscope_Start(callback,frequency){if(typeof Gyroscope==="undefined"){JS_DeviceMotion_add();JS_Gyroscope_callback=callback;return}JS_Gyroscope_callback=callback;function InitializeGyroscope(frequency){JS_Gyroscope=new Gyroscope({frequency:frequency,referenceFrame:"device"});JS_Gyroscope.addEventListener("reading",JS_Gyroscope_eventHandler);JS_Gyroscope.addEventListener("error",function(e){warnOnce(e.error?e.error:e)});JS_Gyroscope.start()}if(JS_Gyroscope){JS_Gyroscope.stop();JS_Gyroscope.removeEventListener("reading",JS_Gyroscope_eventHandler);InitializeGyroscope(frequency)}else if(JS_Gyroscope_frequencyRequest!=0){JS_Gyroscope_frequencyRequest=frequency}else{JS_Gyroscope_frequencyRequest=frequency;navigator.permissions.query({name:"gyroscope"}).then(function(result){if(result.state==="granted"){InitializeGyroscope(JS_Gyroscope_frequencyRequest)}else{warnOnce("No permission to use Gyroscope.")}JS_Gyroscope_frequencyRequest=0})}}function _JS_Gyroscope_Stop(){if(JS_Gyroscope){JS_Gyroscope.stop();JS_Gyroscope.removeEventListener("reading",JS_Gyroscope_eventHandler);JS_Gyroscope=null;JS_Gyroscope_callback=0}else if(JS_Gyroscope_callback!=0){JS_Gyroscope_callback=0;JS_DeviceMotion_remove()}}function _JS_Init_ContextMenuHandler(){const _handleContextMenu=function(event){if(event.target.localName!=="canvas")_ReleaseKeys()};document.addEventListener("contextmenu",_handleContextMenu);Module.deinitializers.push(function(){document.removeEventListener("contextmenu",_handleContextMenu)})}function _JS_LinearAccelerationSensor_IsRunning(){return JS_LinearAccelerationSensor&&JS_LinearAccelerationSensor.activated||JS_LinearAccelerationSensor_callback!=0}function _JS_Log_Dump(ptr,type){var str=UTF8ToString(ptr);if(typeof dump=="function")dump(str);switch(type){case 0:case 1:case 4:console.error(str);return;case 2:console.warn(str);return;case 3:case 5:console.log(str);return;default:console.error("Unknown console message type!");console.error(str)}}function _JS_Log_StackTrace(buffer,bufferSize){var trace=stackTrace();if(buffer)stringToUTF8(trace,buffer,bufferSize);return lengthBytesUTF8(trace)}var mobile_input_hide_delay=null;var mobile_input_text=null;var mobile_input=null;var mobile_input_ignore_blur_event=false;function _JS_MobileKeybard_GetIgnoreBlurEvent(){return mobile_input_ignore_blur_event}function _JS_MobileKeyboard_GetKeyboardStatus(){var kKeyboardStatusVisible=0;var kKeyboardStatusDone=1;if(!mobile_input)return kKeyboardStatusDone;return kKeyboardStatusVisible}function _JS_MobileKeyboard_GetText(buffer,bufferSize){var text=mobile_input&&mobile_input.input?mobile_input.input.value:mobile_input_text?mobile_input_text:"";if(buffer)stringToUTF8(text,buffer,bufferSize);return lengthBytesUTF8(text)}function _JS_MobileKeyboard_GetTextSelection(outStart,outLength){if(!mobile_input){HEAP32[outStart>>2]=0;HEAP32[outLength>>2]=0;return}HEAP32[outStart>>2]=mobile_input.input.selectionStart;HEAP32[outLength>>2]=mobile_input.input.selectionEnd-mobile_input.input.selectionStart}function _JS_MobileKeyboard_Hide(delay){if(mobile_input_hide_delay)return;mobile_input_ignore_blur_event=true;function hideMobileKeyboard(){if(mobile_input&&mobile_input.input){mobile_input_text=mobile_input.input.value;mobile_input.input=null;if(mobile_input.parentNode&&mobile_input.parentNode){mobile_input.parentNode.removeChild(mobile_input)}}mobile_input=null;mobile_input_hide_delay=null;setTimeout(function(){mobile_input_ignore_blur_event=false},100)}if(delay){var hideDelay=200;mobile_input_hide_delay=setTimeout(hideMobileKeyboard,hideDelay)}else{hideMobileKeyboard()}}function _JS_MobileKeyboard_SetCharacterLimit(limit){if(!mobile_input)return;mobile_input.input.maxLength=limit}function _JS_MobileKeyboard_SetText(text){if(!mobile_input)return;text=UTF8ToString(text);mobile_input.input.value=text}function _JS_MobileKeyboard_SetTextSelection(start,length){if(!mobile_input)return;if(mobile_input.input.type==="number"){mobile_input.input.type="text";mobile_input.input.setSelectionRange(start,start+length);mobile_input.input.type="number"}else{mobile_input.input.setSelectionRange(start,start+length)}}function _JS_MobileKeyboard_Show(text,keyboardType,autocorrection,multiline,secure,alert,placeholder,characterLimit){if(mobile_input_hide_delay){clearTimeout(mobile_input_hide_delay);mobile_input_hide_delay=null}text=UTF8ToString(text);mobile_input_text=text;placeholder=UTF8ToString(placeholder);var container=document.body;var hasExistingMobileInput=!!mobile_input;var input_type;var KEYBOARD_TYPE_NUMBERS_AND_PUNCTUATION=2;var KEYBOARD_TYPE_URL=3;var KEYBOARD_TYPE_NUMBER_PAD=4;var KEYBOARD_TYPE_PHONE_PAD=5;var KEYBOARD_TYPE_EMAIL_ADDRESS=7;if(!secure){switch(keyboardType){case KEYBOARD_TYPE_EMAIL_ADDRESS:input_type="email";break;case KEYBOARD_TYPE_URL:input_type="url";break;case KEYBOARD_TYPE_NUMBERS_AND_PUNCTUATION:case KEYBOARD_TYPE_NUMBER_PAD:case KEYBOARD_TYPE_PHONE_PAD:input_type="number";break;default:input_type="text";break}}else{input_type="password"}if(hasExistingMobileInput){if(mobile_input.multiline!=multiline){_JS_MobileKeyboard_Hide(false);return}}var inputContainer=mobile_input||document.createElement("div");if(!hasExistingMobileInput){inputContainer.style="width:100%; position:fixed; bottom:0px; margin:0px; padding:0px; left:0px; border: 1px solid #000; border-radius: 5px; background-color:#fff; font-size:14pt;";container.appendChild(inputContainer);mobile_input=inputContainer}var input=hasExistingMobileInput?mobile_input.input:document.createElement(multiline?"textarea":"input");mobile_input.multiline=multiline;mobile_input.secure=secure;mobile_input.keyboardType=keyboardType;mobile_input.inputType=input_type;input.type=input_type;input.style="width:calc(100% - 85px); "+(multiline?"height:100px;":"")+"vertical-align:top; border-radius: 5px; outline:none; cursor:default; resize:none; border:0px; padding:10px 0px 10px 10px;";input.spellcheck=autocorrection?true:false;input.maxLength=characterLimit>0?characterLimit:524288;input.value=text;input.placeholder=placeholder;if(!hasExistingMobileInput){inputContainer.appendChild(input);inputContainer.input=input}if(!hasExistingMobileInput){var okButton=document.createElement("button");okButton.innerText="OK";okButton.style="border:0; position:absolute; left:calc(100% - 75px); top:0px; width:75px; height:100%; margin:0; padding:0; border-radius: 5px; background-color:#fff";okButton.addEventListener("touchend",function(){_JS_MobileKeyboard_Hide(true)});inputContainer.appendChild(okButton);inputContainer.okButton=okButton;input.addEventListener("keyup",function(e){if(input.parentNode.multiline)return;if(e.code=="Enter"||e.which==13||e.keyCode==13){_JS_MobileKeyboard_Hide(true)}});input.addEventListener("blur",function(e){_JS_MobileKeyboard_Hide(true);e.stopPropagation();e.preventDefault()});input.select();input.focus()}else{input.select()}}var JS_OrientationSensor=null;var JS_OrientationSensor_callback=0;function _JS_OrientationSensor_IsRunning(){return JS_OrientationSensor&&JS_OrientationSensor.activated||JS_OrientationSensor_callback!=0}function JS_OrientationSensor_eventHandler(){if(JS_OrientationSensor_callback!=0)dynCall_vffff(JS_OrientationSensor_callback,JS_OrientationSensor.quaternion[0],JS_OrientationSensor.quaternion[1],JS_OrientationSensor.quaternion[2],JS_OrientationSensor.quaternion[3])}var JS_OrientationSensor_frequencyRequest=0;function JS_DeviceOrientation_eventHandler(event){if(JS_OrientationSensor_callback){var degToRad=Math.PI/180;var x=event.beta*degToRad;var y=event.gamma*degToRad;var z=event.alpha*degToRad;var cx=Math.cos(x/2);var sx=Math.sin(x/2);var cy=Math.cos(y/2);var sy=Math.sin(y/2);var cz=Math.cos(z/2);var sz=Math.sin(z/2);var qx=sx*cy*cz-cx*sy*sz;var qy=cx*sy*cz+sx*cy*sz;var qz=cx*cy*sz+sx*sy*cz;var qw=cx*cy*cz-sx*sy*sz;dynCall_vffff(JS_OrientationSensor_callback,qx,qy,qz,qw)}}function _JS_OrientationSensor_Start(callback,frequency){if(typeof RelativeOrientationSensor==="undefined"){if(JS_OrientationSensor_callback==0){JS_OrientationSensor_callback=callback;JS_RequestDeviceSensorPermissions(1);window.addEventListener("deviceorientation",JS_DeviceOrientation_eventHandler)}return}JS_OrientationSensor_callback=callback;function InitializeOrientationSensor(frequency){JS_OrientationSensor=new RelativeOrientationSensor({frequency:frequency,referenceFrame:"device"});JS_OrientationSensor.addEventListener("reading",JS_OrientationSensor_eventHandler);JS_OrientationSensor.addEventListener("error",function(e){warnOnce(e.error?e.error:e)});JS_OrientationSensor.start()}if(JS_OrientationSensor){JS_OrientationSensor.stop();JS_OrientationSensor.removeEventListener("reading",JS_OrientationSensor_eventHandler);InitializeOrientationSensor(frequency)}else if(JS_OrientationSensor_frequencyRequest!=0){JS_OrientationSensor_frequencyRequest=frequency}else{JS_OrientationSensor_frequencyRequest=frequency;Promise.all([navigator.permissions.query({name:"accelerometer"}),navigator.permissions.query({name:"gyroscope"})]).then(function(results){if(results.every(function(result){return result.state==="granted"})){InitializeOrientationSensor(JS_OrientationSensor_frequencyRequest)}else{warnOnce("No permissions to use RelativeOrientationSensor.")}JS_OrientationSensor_frequencyRequest=0})}}function _JS_OrientationSensor_Stop(){if(JS_OrientationSensor){JS_OrientationSensor.stop();JS_OrientationSensor.removeEventListener("reading",JS_OrientationSensor_eventHandler);JS_OrientationSensor=null}else if(JS_OrientationSensor_callback!=0){window.removeEventListener("deviceorientation",JS_DeviceOrientation_eventHandler)}JS_OrientationSensor_callback=0}function _JS_RequestDeviceSensorPermissionsOnTouch(){if(JS_DeviceSensorPermissions==0)return;JS_RequestDeviceSensorPermissions(JS_DeviceSensorPermissions)}function _JS_RunQuitCallbacks(){Module.QuitCleanup()}var JS_ScreenOrientation_callback=0;function JS_ScreenOrientation_eventHandler(){if(JS_ScreenOrientation_callback)dynCall_viii(JS_ScreenOrientation_callback,window.innerWidth,window.innerHeight,screen.orientation?screen.orientation.angle:window.orientation)}function _JS_ScreenOrientation_DeInit(){JS_ScreenOrientation_callback=0;window.removeEventListener("resize",JS_ScreenOrientation_eventHandler);if(screen.orientation){screen.orientation.removeEventListener("change",JS_ScreenOrientation_eventHandler)}}function _JS_ScreenOrientation_Init(callback){if(!JS_ScreenOrientation_callback){if(screen.orientation){screen.orientation.addEventListener("change",JS_ScreenOrientation_eventHandler)}window.addEventListener("resize",JS_ScreenOrientation_eventHandler);JS_ScreenOrientation_callback=callback;setTimeout(JS_ScreenOrientation_eventHandler,0)}}var JS_ScreenOrientation_requestedLockType=-1;var JS_ScreenOrientation_appliedLockType=-1;var JS_ScreenOrientation_timeoutID=-1;function _JS_ScreenOrientation_Lock(orientationLockType){if(!screen.orientation||!screen.orientation.lock){return}function applyLock(){JS_ScreenOrientation_appliedLockType=JS_ScreenOrientation_requestedLockType;var screenOrientations=["any",0,"landscape","portrait","portrait-primary","portrait-secondary","landscape-primary","landscape-secondary"];var type=screenOrientations[JS_ScreenOrientation_appliedLockType];screen.orientation.lock(type).then(function(){if(JS_ScreenOrientation_requestedLockType!=JS_ScreenOrientation_appliedLockType){JS_ScreenOrientation_timeoutID=setTimeout(applyLock,0)}else{JS_ScreenOrientation_timeoutID=-1}}).catch(function(err){warnOnce(err);JS_ScreenOrientation_timeoutID=-1})}JS_ScreenOrientation_requestedLockType=orientationLockType;if(JS_ScreenOrientation_timeoutID==-1&&orientationLockType!=JS_ScreenOrientation_appliedLockType){JS_ScreenOrientation_timeoutID=setTimeout(applyLock,0)}}var WEBAudio={audioInstanceIdCounter:0,audioInstances:{},audioContext:null,audioWebEnabled:0,audioCache:[],pendingAudioSources:{}};function jsAudioMixinSetPitch(source){source.estimatePlaybackPosition=function(){var t=(WEBAudio.audioContext.currentTime-source.playbackStartTime)*source.playbackRate.value;if(source.loop&&t>=source.loopStart){t=(t-source.loopStart)%(source.loopEnd-source.loopStart)+source.loopStart}return t};source.setPitch=function(newPitch){var curPosition=source.estimatePlaybackPosition();if(curPosition>=0){source.playbackStartTime=WEBAudio.audioContext.currentTime-curPosition/newPitch}if(source.playbackRate.value!==newPitch)source.playbackRate.value=newPitch}}function jsAudioCreateUncompressedSoundClip(buffer,error){var soundClip={buffer:buffer,error:error};soundClip.release=function(){};soundClip.getLength=function(){if(!this.buffer){console.log("Trying to get length of sound which is not loaded.");return 0}var sampleRateRatio=44100/this.buffer.sampleRate;return this.buffer.length*sampleRateRatio};soundClip.getData=function(ptr,length){if(!this.buffer){console.log("Trying to get data of sound which is not loaded.");return 0}var startOutputBuffer=ptr>>2;var output=HEAPF32.subarray(startOutputBuffer,startOutputBuffer+(length>>2));var numMaxSamples=Math.floor((length>>2)/this.buffer.numberOfChannels);var numReadSamples=Math.min(this.buffer.length,numMaxSamples);for(var i=0;i<this.buffer.numberOfChannels;i++){var channelData=this.buffer.getChannelData(i).subarray(0,numReadSamples);output.set(channelData,i*numReadSamples)}return numReadSamples*this.buffer.numberOfChannels*4};soundClip.getNumberOfChannels=function(){if(!this.buffer){console.log("Trying to get metadata of sound which is not loaded.");return 0}return this.buffer.numberOfChannels};soundClip.getFrequency=function(){if(!this.buffer){console.log("Trying to get metadata of sound which is not loaded.");return 0}return this.buffer.sampleRate};soundClip.createSourceNode=function(){if(!this.buffer){console.log("Trying to play sound which is not loaded.")}var source=WEBAudio.audioContext.createBufferSource();source.buffer=this.buffer;jsAudioMixinSetPitch(source);return source};return soundClip}function jsAudioCreateChannel(callback,userData){var channel={callback:callback,userData:userData,source:null,gain:WEBAudio.audioContext.createGain(),panner:WEBAudio.audioContext.createPanner(),threeD:false,loop:false,loopStart:0,loopEnd:0,pitch:1};channel.panner.rolloffFactor=0;channel.release=function(){this.disconnectSource();this.gain.disconnect();this.panner.disconnect()};channel.playSoundClip=function(soundClip,startTime,startOffset){try{var self=this;this.source=soundClip.createSourceNode();this.setupPanning();this.source.onended=function(){self.source.isStopped=true;self.disconnectSource();if(self.callback){dynCall("vi",self.callback,[self.userData])}};this.source.loop=this.loop;this.source.loopStart=this.loopStart;this.source.loopEnd=this.loopEnd;this.source.start(startTime,startOffset);this.source.playbackStartTime=startTime-startOffset/this.source.playbackRate.value;this.source.setPitch(this.pitch)}catch(e){console.error("Channel.playSoundClip error. Exception: "+e)}};channel.stop=function(delay){if(!this.source){return}try{channel.source.stop(WEBAudio.audioContext.currentTime+delay)}catch(e){}if(delay==0){this.disconnectSource()}};channel.isPaused=function(){if(!this.source){return true}if(this.source.isPausedMockNode){return true}if(this.source.mediaElement){return this.source.mediaElement.paused||this.source.pauseRequested}return false};channel.pause=function(){if(!this.source||this.source.isPausedMockNode){return}if(this.source.mediaElement){this.source._pauseMediaElement();return}var pausedSource={isPausedMockNode:true,buffer:this.source.buffer,loop:this.source.loop,loopStart:this.source.loopStart,loopEnd:this.source.loopEnd,playbackRate:this.source.playbackRate.value,scheduledStopTime:undefined,playbackPausedAtPosition:this.source.estimatePlaybackPosition(),setPitch:function(v){this.playbackRate=v},stop:function(when){this.scheduledStopTime=when}};this.stop(0);this.disconnectSource();this.source=pausedSource};channel.resume=function(){if(this.source&&this.source.mediaElement){this.source.start(undefined,this.source.currentTime);return}if(!this.source||!this.source.isPausedMockNode){return}var pausedSource=this.source;var soundClip=jsAudioCreateUncompressedSoundClip(pausedSource.buffer,false);this.playSoundClip(soundClip,WEBAudio.audioContext.currentTime,Math.max(0,pausedSource.playbackPausedAtPosition));this.source.loop=pausedSource.loop;this.source.loopStart=pausedSource.loopStart;this.source.loopEnd=pausedSource.loopEnd;this.source.setPitch(pausedSource.playbackRate);if(typeof pausedSource.scheduledStopTime!=="undefined"){var delay=Math.max(pausedSource.scheduledStopTime-WEBAudio.audioContext.currentTime,0);this.stop(delay)}};channel.setLoop=function(loop){this.loop=loop;if(!this.source||this.source.loop==loop){return}this.source.loop=loop};channel.setLoopPoints=function(loopStart,loopEnd){this.loopStart=loopStart;this.loopEnd=loopEnd;if(!this.source){return}if(this.source.loopStart!==loopStart){this.source.loopStart=loopStart}if(this.source.loopEnd!==loopEnd){this.source.loopEnd=loopEnd}};channel.set3D=function(threeD){if(this.threeD==threeD){return}this.threeD=threeD;if(!this.source){return}this.setupPanning()};channel.setPitch=function(pitch){this.pitch=pitch;if(!this.source){return}this.source.setPitch(pitch)};channel.setVolume=function(volume){if(this.gain.gain.value==volume){return}this.gain.gain.value=volume};channel.setPosition=function(x,y,z){var p=this.panner;if(p.positionX){if(p.positionX.value!==x)p.positionX.value=x;if(p.positionY.value!==y)p.positionY.value=y;if(p.positionZ.value!==z)p.positionZ.value=z}else if(p._x!==x||p._y!==y||p._z!==z){p.setPosition(x,y,z);p._x=x;p._y=y;p._z=z}};channel.disconnectSource=function(){if(!this.source||this.source.isPausedMockNode){return}if(this.source.mediaElement){this.source._pauseMediaElement()}this.source.onended=null;this.source.disconnect();delete this.source};channel.setupPanning=function(){if(this.source.isPausedMockNode)return;this.source.disconnect();this.panner.disconnect();this.gain.disconnect();if(this.threeD){this.source.connect(this.panner);this.panner.connect(this.gain)}else{this.source.connect(this.gain)}this.gain.connect(WEBAudio.audioContext.destination)};channel.isStopped=function(){if(!this.source){return true}if(this.source.mediaElement){return this.source.isStopped}return false};return channel}function _JS_Sound_Create_Channel(callback,userData){if(WEBAudio.audioWebEnabled==0)return;WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter]=jsAudioCreateChannel(callback,userData);return WEBAudio.audioInstanceIdCounter}function _JS_Sound_GetLength(bufferInstance){if(WEBAudio.audioWebEnabled==0)return 0;var soundClip=WEBAudio.audioInstances[bufferInstance];if(!soundClip)return 0;return soundClip.getLength()}function _JS_Sound_GetLoadState(bufferInstance){if(WEBAudio.audioWebEnabled==0)return 2;var sound=WEBAudio.audioInstances[bufferInstance];if(sound.error)return 2;if(sound.buffer||sound.url)return 0;return 1}function jsAudioPlayPendingBlockedAudio(soundId){var pendingAudio=WEBAudio.pendingAudioSources[soundId];pendingAudio.sourceNode._startPlayback(pendingAudio.offset);delete WEBAudio.pendingAudioSources[soundId]}function jsAudioPlayBlockedAudios(){Object.keys(WEBAudio.pendingAudioSources).forEach(function(audioId){jsAudioPlayPendingBlockedAudio(audioId)})}function _JS_Sound_Init(){try{window.AudioContext=window.AudioContext||window.webkitAudioContext;WEBAudio.audioContext=new AudioContext;var tryToResumeAudioContext=function(){if(WEBAudio.audioContext.state==="suspended")WEBAudio.audioContext.resume().catch(function(error){console.warn("Could not resume audio context. Exception: "+error)});else Module.clearInterval(resumeInterval)};var resumeInterval=Module.setInterval(tryToResumeAudioContext,400);WEBAudio.audioWebEnabled=1;var _userEventCallback=function(){try{if(WEBAudio.audioContext.state!=="running"&&WEBAudio.audioContext.state!=="closed"){WEBAudio.audioContext.resume().catch(function(error){console.warn("Could not resume audio context. Exception: "+error)})}jsAudioPlayBlockedAudios();var audioCacheSize=20;while(WEBAudio.audioCache.length<audioCacheSize){var audio=new Audio;audio.autoplay=false;WEBAudio.audioCache.push(audio)}}catch(e){}};window.addEventListener("mousedown",_userEventCallback);window.addEventListener("touchstart",_userEventCallback);Module.deinitializers.push(function(){window.removeEventListener("mousedown",_userEventCallback);window.removeEventListener("touchstart",_userEventCallback)})}catch(e){alert("Web Audio API is not supported in this browser")}}function jsAudioCreateUncompressedSoundClipFromCompressedAudio(audioData){var soundClip=jsAudioCreateUncompressedSoundClip(null,false);WEBAudio.audioContext.decodeAudioData(audioData,function(_buffer){soundClip.buffer=_buffer},function(_error){soundClip.error=true;console.log("Decode error: "+_error)});return soundClip}function jsAudioAddPendingBlockedAudio(sourceNode,offset){WEBAudio.pendingAudioSources[sourceNode.mediaElement.src]={sourceNode:sourceNode,offset:offset}}function jsAudioGetMimeTypeFromType(fmodSoundType){switch(fmodSoundType){case 13:return"audio/mpeg";case 20:return"audio/wav";default:return"audio/mp4"}}function jsAudioCreateCompressedSoundClip(audioData,fmodSoundType){var mimeType=jsAudioGetMimeTypeFromType(fmodSoundType);var blob=new Blob([audioData],{type:mimeType});var soundClip={url:URL.createObjectURL(blob),error:false,mediaElement:new Audio};soundClip.mediaElement.preload="metadata";soundClip.mediaElement.src=soundClip.url;soundClip.release=function(){if(!this.mediaElement){return}this.mediaElement.src="";URL.revokeObjectURL(this.url);delete this.mediaElement;delete this.url};soundClip.getLength=function(){return this.mediaElement.duration*44100};soundClip.getData=function(ptr,length){console.warn("getData() is not supported for compressed sound.");return 0};soundClip.getNumberOfChannels=function(){console.warn("getNumberOfChannels() is not supported for compressed sound.");return 0};soundClip.getFrequency=function(){console.warn("getFrequency() is not supported for compressed sound.");return 0};soundClip.createSourceNode=function(){var self=this;var mediaElement=WEBAudio.audioCache.length?WEBAudio.audioCache.pop():new Audio;mediaElement.preload="metadata";mediaElement.src=this.url;var source=WEBAudio.audioContext.createMediaElementSource(mediaElement);Object.defineProperty(source,"loop",{get:function(){return source.mediaElement.loop},set:function(v){if(source.mediaElement.loop!==v)source.mediaElement.loop=v}});source.playbackRate={};Object.defineProperty(source.playbackRate,"value",{get:function(){return source.mediaElement.playbackRate},set:function(v){if(source.mediaElement.playbackRate!==v)source.mediaElement.playbackRate=v}});Object.defineProperty(source,"currentTime",{get:function(){return source.mediaElement.currentTime},set:function(v){if(source.mediaElement.currentTime!==v)source.mediaElement.currentTime=v}});Object.defineProperty(source,"mute",{get:function(){return source.mediaElement.mute},set:function(v){if(source.mediaElement.mute!==v)source.mediaElement.mute=v}});Object.defineProperty(source,"onended",{get:function(){return source.mediaElement.onended},set:function(onended){source.mediaElement.onended=onended}});source.playPromise=null;source.playTimeout=null;source.pauseRequested=false;source.isStopped=false;source._pauseMediaElement=function(){if(source.playPromise||source.playTimeout){source.pauseRequested=true}else{source.mediaElement.pause()}};source._startPlayback=function(offset){if(source.playPromise||source.playTimeout){source.mediaElement.currentTime=offset;source.pauseRequested=false;return}source.mediaElement.currentTime=offset;source.playPromise=source.mediaElement.play();if(source.playPromise){source.playPromise.then(function(){if(source.pauseRequested){source.mediaElement.pause();source.pauseRequested=false}source.playPromise=null}).catch(function(error){source.playPromise=null;if(error.name!=="NotAllowedError")throw error;jsAudioAddPendingBlockedAudio(source,offset)})}};source.start=function(startTime,offset){if(typeof startTime==="undefined"){startTime=WEBAudio.audioContext.currentTime}if(typeof offset==="undefined"){offset=0}var startDelayThresholdMS=4;var startDelayMS=(startTime-WEBAudio.audioContext.currentTime)*1e3;if(startDelayMS>startDelayThresholdMS){source.playTimeout=setTimeout(function(){source.playTimeout=null;source._startPlayback(offset)},startDelayMS)}else{source._startPlayback(offset)}};source.stop=function(stopTime){if(typeof stopTime==="undefined"){stopTime=WEBAudio.audioContext.currentTime}var stopDelayThresholdMS=4;var stopDelayMS=(stopTime-WEBAudio.audioContext.currentTime)*1e3;if(stopDelayMS>stopDelayThresholdMS){setTimeout(function(){source._pauseMediaElement();source.isStopped=true},stopDelayMS)}else{source._pauseMediaElement();source.isStopped=true}};jsAudioMixinSetPitch(source);return source};return soundClip}function _JS_Sound_Load(ptr,length,decompress,fmodSoundType){if(WEBAudio.audioWebEnabled==0)return 0;var audioData=HEAPU8.buffer.slice(ptr,ptr+length);if(length<131072)decompress=1;var sound;if(decompress){sound=jsAudioCreateUncompressedSoundClipFromCompressedAudio(audioData)}else{sound=jsAudioCreateCompressedSoundClip(audioData,fmodSoundType)}WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter]=sound;return WEBAudio.audioInstanceIdCounter}function jsAudioCreateUncompressedSoundClipFromPCM(channels,length,sampleRate,ptr){var buffer=WEBAudio.audioContext.createBuffer(channels,length,sampleRate);for(var i=0;i<channels;i++){var offs=(ptr>>2)+length*i;var copyToChannel=buffer["copyToChannel"]||function(source,channelNumber,startInChannel){var clipped=source.subarray(0,Math.min(source.length,this.length-(startInChannel|0)));this.getChannelData(channelNumber|0).set(clipped,startInChannel|0)};copyToChannel.apply(buffer,[HEAPF32.subarray(offs,offs+length),i,0])}return jsAudioCreateUncompressedSoundClip(buffer,false)}function _JS_Sound_Load_PCM(channels,length,sampleRate,ptr){if(WEBAudio.audioWebEnabled==0)return 0;var sound=jsAudioCreateUncompressedSoundClipFromPCM(channels,length,sampleRate,ptr);WEBAudio.audioInstances[++WEBAudio.audioInstanceIdCounter]=sound;return WEBAudio.audioInstanceIdCounter}function _JS_Sound_Play(bufferInstance,channelInstance,offset,delay){if(WEBAudio.audioWebEnabled==0)return;_JS_Sound_Stop(channelInstance,0);var soundClip=WEBAudio.audioInstances[bufferInstance];var channel=WEBAudio.audioInstances[channelInstance];if(!soundClip){console.log("Trying to play sound which is not loaded.");return}try{channel.playSoundClip(soundClip,WEBAudio.audioContext.currentTime+delay,offset)}catch(error){console.error("playSoundClip error. Exception: "+e)}}function _JS_Sound_ReleaseInstance(instance){var object=WEBAudio.audioInstances[instance];if(object){object.release()}delete WEBAudio.audioInstances[instance]}function _JS_Sound_ResumeIfNeeded(){if(WEBAudio.audioWebEnabled==0)return;if(WEBAudio.audioContext.state==="suspended")WEBAudio.audioContext.resume().catch(function(error){console.warn("Could not resume audio context. Exception: "+error)})}function _JS_Sound_Set3D(channelInstance,threeD){var channel=WEBAudio.audioInstances[channelInstance];channel.set3D(threeD)}function _JS_Sound_SetListenerOrientation(x,y,z,xUp,yUp,zUp){if(WEBAudio.audioWebEnabled==0)return;x=-x;y=-y;z=-z;var l=WEBAudio.audioContext.listener;if(l.forwardX){if(l.forwardX.value!==x)l.forwardX.value=x;if(l.forwardY.value!==y)l.forwardY.value=y;if(l.forwardZ.value!==z)l.forwardZ.value=z;if(l.upX.value!==xUp)l.upX.value=xUp;if(l.upY.value!==yUp)l.upY.value=yUp;if(l.upZ.value!==zUp)l.upZ.value=zUp}else if(l._forwardX!==x||l._forwardY!==y||l._forwardZ!==z||l._upX!==xUp||l._upY!==yUp||l._upZ!==zUp){l.setOrientation(x,y,z,xUp,yUp,zUp);l._forwardX=x;l._forwardY=y;l._forwardZ=z;l._upX=xUp;l._upY=yUp;l._upZ=zUp}}function _JS_Sound_SetListenerPosition(x,y,z){if(WEBAudio.audioWebEnabled==0)return;var l=WEBAudio.audioContext.listener;if(l.positionX){if(l.positionX.value!==x)l.positionX.value=x;if(l.positionY.value!==y)l.positionY.value=y;if(l.positionZ.value!==z)l.positionZ.value=z}else if(l._positionX!==x||l._positionY!==y||l._positionZ!==z){l.setPosition(x,y,z);l._positionX=x;l._positionY=y;l._positionZ=z}}function _JS_Sound_SetLoop(channelInstance,loop){if(WEBAudio.audioWebEnabled==0)return;var channel=WEBAudio.audioInstances[channelInstance];channel.setLoop(loop)}function _JS_Sound_SetLoopPoints(channelInstance,loopStart,loopEnd){if(WEBAudio.audioWebEnabled==0)return;var channel=WEBAudio.audioInstances[channelInstance];channel.setLoopPoints(loopStart,loopEnd)}function _JS_Sound_SetPaused(channelInstance,paused){if(WEBAudio.audioWebEnabled==0)return;var channel=WEBAudio.audioInstances[channelInstance];if(paused!=channel.isPaused()){if(paused)channel.pause();else channel.resume()}}function _JS_Sound_SetPitch(channelInstance,v){if(WEBAudio.audioWebEnabled==0)return;try{var channel=WEBAudio.audioInstances[channelInstance];channel.setPitch(v)}catch(e){console.error("JS_Sound_SetPitch(channel="+channelInstance+", pitch="+v+") threw an exception: "+e)}}function _JS_Sound_SetPosition(channelInstance,x,y,z){if(WEBAudio.audioWebEnabled==0)return;var channel=WEBAudio.audioInstances[channelInstance];channel.setPosition(x,y,z)}function _JS_Sound_SetVolume(channelInstance,v){if(WEBAudio.audioWebEnabled==0)return;try{var channel=WEBAudio.audioInstances[channelInstance];channel.setVolume(v)}catch(e){console.error("JS_Sound_SetVolume(channel="+channelInstance+", volume="+v+") threw an exception: "+e)}}function _JS_Sound_Stop(channelInstance,delay){if(WEBAudio.audioWebEnabled==0)return;var channel=WEBAudio.audioInstances[channelInstance];channel.stop(delay)}function _JS_SystemInfo_GetCanvasClientSize(domElementSelector,outWidth,outHeight){var selector=UTF8ToString(domElementSelector);var canvas=selector=="#canvas"?Module["canvas"]:document.querySelector(selector);var w=0,h=0;if(canvas){var size=canvas.getBoundingClientRect();w=size.width;h=size.height}HEAPF64[outWidth>>3]=w;HEAPF64[outHeight>>3]=h}function _JS_SystemInfo_GetDocumentURL(buffer,bufferSize){if(buffer)stringToUTF8(document.URL,buffer,bufferSize);return lengthBytesUTF8(document.URL)}function _JS_SystemInfo_GetGPUInfo(buffer,bufferSize){var gpuinfo=Module.SystemInfo.gpu;if(buffer)stringToUTF8(gpuinfo,buffer,bufferSize);return lengthBytesUTF8(gpuinfo)}function _JS_SystemInfo_GetMatchWebGLToCanvasSize(){return Module.matchWebGLToCanvasSize||Module.matchWebGLToCanvasSize===undefined}function _JS_SystemInfo_GetMemory(){return HEAPU8.length/(1024*1024)}function _JS_SystemInfo_GetOS(buffer,bufferSize){var browser=Module.SystemInfo.os+" "+Module.SystemInfo.osVersion;if(buffer)stringToUTF8(browser,buffer,bufferSize);return lengthBytesUTF8(browser)}function _JS_SystemInfo_GetPreferredDevicePixelRatio(){return Module.matchWebGLToCanvasSize==false?1:Module.devicePixelRatio||window.devicePixelRatio||1}function _JS_SystemInfo_GetScreenSize(outWidth,outHeight){HEAPF64[outWidth>>3]=Module.SystemInfo.width;HEAPF64[outHeight>>3]=Module.SystemInfo.height}function _JS_SystemInfo_GetStreamingAssetsURL(buffer,bufferSize){if(buffer)stringToUTF8(Module.streamingAssetsUrl,buffer,bufferSize);return lengthBytesUTF8(Module.streamingAssetsUrl)}function _JS_SystemInfo_HasAstcHdr(){var ext=GLctx.getExtension("WEBGL_compressed_texture_astc");if(ext&&ext.getSupportedProfiles){return ext.getSupportedProfiles().includes("hdr")}return false}function _JS_SystemInfo_HasCursorLock(){return Module.SystemInfo.hasCursorLock}function _JS_SystemInfo_HasFullscreen(){return Module.SystemInfo.hasFullscreen}function _JS_SystemInfo_HasWebGL(){return Module.SystemInfo.hasWebGL}function _JS_SystemInfo_IsMobile(){return Module.SystemInfo.mobile}function _JS_UnityEngineShouldQuit(){return!!Module.shouldQuit}var wr={requests:{},responses:{},abortControllers:{},timer:{},nextRequestId:1};function _JS_WebRequest_Abort(requestId){var abortController=wr.abortControllers[requestId];if(!abortController||abortController.signal.aborted){return}abortController.abort()}function _JS_WebRequest_Create(url,method){var _url=UTF8ToString(url);var _method=UTF8ToString(method);var abortController=new AbortController;var requestOptions={url:_url,init:{method:_method,signal:abortController.signal,headers:{},enableStreamingDownload:true},tempBuffer:null,tempBufferSize:0};wr.abortControllers[wr.nextRequestId]=abortController;wr.requests[wr.nextRequestId]=requestOptions;return wr.nextRequestId++}function jsWebRequestGetResponseHeaderString(requestId){var response=wr.responses[requestId];if(!response){return""}if(response.headerString){return response.headerString}var headers="";var entries=response.headers.entries();for(var result=entries.next();!result.done;result=entries.next()){headers+=result.value[0]+": "+result.value[1]+"\r\n"}response.headerString=headers;return headers}function _JS_WebRequest_GetResponseMetaData(requestId,headerBuffer,headerSize,responseUrlBuffer,responseUrlSize){var response=wr.responses[requestId];if(!response){stringToUTF8("",headerBuffer,headerSize);stringToUTF8("",responseUrlBuffer,responseUrlSize);return}if(headerBuffer){var headers=jsWebRequestGetResponseHeaderString(requestId);stringToUTF8(headers,headerBuffer,headerSize)}if(responseUrlBuffer){stringToUTF8(response.url,responseUrlBuffer,responseUrlSize)}}function _JS_WebRequest_GetResponseMetaDataLengths(requestId,buffer){var response=wr.responses[requestId];if(!response){HEAPU32[buffer>>2]=0;HEAPU32[(buffer>>2)+1]=0;return}var headers=jsWebRequestGetResponseHeaderString(requestId);HEAPU32[buffer>>2]=lengthBytesUTF8(headers);HEAPU32[(buffer>>2)+1]=lengthBytesUTF8(response.url)}function _JS_WebRequest_Release(requestId){if(wr.timer[requestId]){clearTimeout(wr.timer[requestId])}delete wr.requests[requestId];delete wr.responses[requestId];delete wr.abortControllers[requestId];delete wr.timer[requestId]}function _JS_WebRequest_Send(requestId,ptr,length,arg,onresponse,onprogress){var requestOptions=wr.requests[requestId];var abortController=wr.abortControllers[requestId];function getTempBuffer(size){if(!requestOptions.tempBuffer){const initialSize=Math.max(size,1024);requestOptions.tempBuffer=_malloc(initialSize);requestOptions.tempBufferSize=initialSize}if(requestOptions.tempBufferSize<size){_free(requestOptions.tempBuffer);requestOptions.tempBuffer=_malloc(size);requestOptions.tempBufferSize=size}return requestOptions.tempBuffer}function ClearTimeout(){if(wr.timer[requestId]){clearTimeout(wr.timer[requestId]);delete wr.timer[requestId]}}function HandleSuccess(response,body){ClearTimeout();if(!onresponse){return}var kWebRequestOK=0;if(requestOptions.init.enableStreamingDownload){dynCall("viiiiii",onresponse,[arg,response.status,0,body.length,0,kWebRequestOK])}else if(body.length!=0){var buffer=_malloc(body.length);HEAPU8.set(body,buffer);dynCall("viiiiii",onresponse,[arg,response.status,buffer,body.length,0,kWebRequestOK])}else{dynCall("viiiiii",onresponse,[arg,response.status,0,0,0,kWebRequestOK])}if(requestOptions.tempBuffer){_free(requestOptions.tempBuffer)}}function HandleError(err,code){ClearTimeout();if(!onresponse){return}var len=lengthBytesUTF8(err)+1;var buffer=_malloc(len);stringToUTF8(err,buffer,len);dynCall("viiiiii",onresponse,[arg,500,0,0,buffer,code]);_free(buffer);if(requestOptions.tempBuffer){_free(requestOptions.tempBuffer)}}function HandleProgress(e){if(!onprogress||!e.lengthComputable){return}var response=e.response;wr.responses[requestId]=response;if(e.chunk){var buffer=getTempBuffer(e.chunk.length);HEAPU8.set(e.chunk,buffer);dynCall("viiiiii",onprogress,[arg,response.status,e.loaded,e.total,buffer,e.chunk.length])}else{dynCall("viiiiii",onprogress,[arg,response.status,e.loaded,e.total,0,0])}}try{if(length>0){var postData=HEAPU8.subarray(ptr,ptr+length);requestOptions.init.body=new Blob([postData])}if(requestOptions.timeout){wr.timer[requestId]=setTimeout(function(){requestOptions.isTimedOut=true;abortController.abort()},requestOptions.timeout)}var fetchImpl=Module.fetchWithProgress;requestOptions.init.onProgress=HandleProgress;if(Module.companyName&&Module.productName&&Module.cachedFetch){fetchImpl=Module.cachedFetch;requestOptions.init.companyName=Module.companyName;requestOptions.init.productName=Module.productName;requestOptions.init.productVersion=Module.productVersion;requestOptions.init.control=Module.cacheControl(requestOptions.url)}fetchImpl(requestOptions.url,requestOptions.init).then(function(response){wr.responses[requestId]=response;HandleSuccess(response,response.parsedBody)}).catch(function(error){var kWebErrorUnknown=2;var kWebErrorAborted=17;var kWebErrorTimeout=14;if(requestOptions.isTimedOut){HandleError("Connection timed out.",kWebErrorTimeout)}else if(abortController.signal.aborted){HandleError("Aborted.",kWebErrorAborted)}else{HandleError(error.message,kWebErrorUnknown)}})}catch(error){var kWebErrorUnknown=2;HandleError(error.message,kWebErrorUnknown)}}function _JS_WebRequest_SetRedirectLimit(request,redirectLimit){var requestOptions=wr.requests[request];if(!requestOptions){return}requestOptions.init.redirect=redirectLimit===0?"error":"follow"}function _JS_WebRequest_SetRequestHeader(requestId,header,value){var requestOptions=wr.requests[requestId];if(!requestOptions){return}var _header=UTF8ToString(header);var _value=UTF8ToString(value);requestOptions.init.headers[_header]=_value}function _JS_WebRequest_SetTimeout(requestId,timeout){var requestOptions=wr.requests[requestId];if(!requestOptions){return}requestOptions.timeout=timeout}function _LSDelete(key){localStorage.removeItem(UTF8ToString(key))}function _LSExists(key){return localStorage.getItem(UTF8ToString(key))!==null}function _LSRead(key){var data=localStorage.getItem(UTF8ToString(key));var bufferSize=lengthBytesUTF8(data)+1;var buffer=_malloc(bufferSize);stringToUTF8(data,buffer,bufferSize);return buffer}function _LSWrite(key,data){localStorage.setItem(UTF8ToString(key),UTF8ToString(data))}function _OpenMetaMaskDeeplink(url){var urlStr=UTF8ToString(url);console.log("MetaMask deeplink URL mobile: "+urlStr)}function _ThirdwebConnect(taskId,wallet,chainId,password,email,phoneNumber,personalWallet,authOptions,smartWalletAccountOverride,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.connect(UTF8ToString(wallet),UTF8ToString(chainId),UTF8ToString(password),UTF8ToString(email),UTF8ToString(phoneNumber),UTF8ToString(personalWallet),UTF8ToString(authOptions),UTF8ToString(smartWalletAccountOverride)).then(address=>{if(address){var bufferSize=lengthBytesUTF8(address)+1;var buffer=_malloc(bufferSize);stringToUTF8(address,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}else{dynCall_viii(cb,idPtr,null,null)}}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebCopyBuffer(taskId,text,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.copyBuffer(UTF8ToString(text)).then(()=>{dynCall_viii(cb,idPtr,idPtr,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebDisconnect(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.disconnect().then(()=>{dynCall_viii(cb,idPtr,idPtr,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebExportWallet(taskId,password,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.exportWallet(UTF8ToString(password)).then(encryptedJson=>{if(encryptedJson){var bufferSize=lengthBytesUTF8(encryptedJson)+1;var buffer=_malloc(bufferSize);stringToUTF8(encryptedJson,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}else{dynCall_viii(cb,idPtr,null,null)}}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebFundWallet(taskId,payload,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.fundWallet(UTF8ToString(payload)).then(()=>{dynCall_viii(cb,idPtr,idPtr,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetBlock(taskId,blockNumber,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getBlock(UTF8ToString(blockNumber)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetBlockWithTransactions(taskId,blockNumber,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getBlockWithTransactions(UTF8ToString(blockNumber)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetEmail(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getEmail().then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetLatestBlockNumber(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getLatestBlockNumber().then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetNonce(taskId,address,blockTag,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getNonce(UTF8ToString(address),UTF8ToString(blockTag)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebGetSignerAddress(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.getSignerAddress().then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}function _ThirdwebInitialize(chain,options){window.bridge.initialize(UTF8ToString(chain),UTF8ToString(options))}function _ThirdwebInvoke(taskId,route,payload,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.invoke(UTF8ToString(route),UTF8ToString(payload)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{console.error("ThirdwebSDK invoke error",err);var msg=err.reason||err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}function _ThirdwebInvokeListener(taskId,route,payload,action){window.bridge.invokeListener(UTF8ToString(taskId),UTF8ToString(route),UTF8ToString(payload),action,(jsAction,jsTaskId,jsResult)=>{var jsId=jsTaskId;var jsIdSize=lengthBytesUTF8(jsId)+1;var jsIdBuffer=_malloc(jsIdSize);stringToUTF8(jsId,jsIdBuffer,jsIdSize);var jsRes=jsResult;var jsResSize=lengthBytesUTF8(jsRes)+1;var jsResBuffer=_malloc(jsResSize);stringToUTF8(jsRes,jsResBuffer,jsResSize);dynCall_vii(jsAction,jsIdBuffer,jsResBuffer)})}async function _ThirdwebResolveAddressFromENS(taskId,ens,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.resolveAddressFromENS(UTF8ToString(ens)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebResolveENSFromAddress(taskId,address,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.resolveENSFromAddress(UTF8ToString(address)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletAddAdmin(taskId,admin,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletAddAdmin(UTF8ToString(admin)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletCreateSessionKey(taskId,options,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletCreateSessionKey(UTF8ToString(options)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletGetAllActiveSigners(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletGetAllActiveSigners().then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletIsDeployed(taskId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletIsDeployed().then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletRemoveAdmin(taskId,admin,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletRemoveAdmin(UTF8ToString(admin)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSmartWalletRevokeSessionKey(taskId,signer,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.smartWalletRevokeSessionKey(UTF8ToString(signer)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebSwitchNetwork(taskId,chainId,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.switchNetwork(UTF8ToString(chainId)).then(()=>{dynCall_viii(cb,idPtr,null,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}async function _ThirdwebWaitForTransactionResult(taskId,txHash,cb){var id=UTF8ToString(taskId);var idSize=lengthBytesUTF8(id)+1;var idPtr=_malloc(idSize);stringToUTF8(id,idPtr,idSize);window.bridge.waitForTransactionResult(UTF8ToString(txHash)).then(returnStr=>{var bufferSize=lengthBytesUTF8(returnStr)+1;var buffer=_malloc(bufferSize);stringToUTF8(returnStr,buffer,bufferSize);dynCall_viii(cb,idPtr,buffer,null)}).catch(err=>{var msg=err.message;var bufferSize=lengthBytesUTF8(msg)+1;var buffer=_malloc(bufferSize);stringToUTF8(msg,buffer,bufferSize);dynCall_viii(cb,idPtr,null,buffer)})}function _WebGLIsMobile(){return/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)}var webSocketState={instances:{},lastId:0,onOpen:null,onMessage:null,onError:null,onClose:null,debug:false};function _WebSocketAddSubProtocol(instanceId,subprotocol){var subprotocolStr=UTF8ToString(subprotocol);webSocketState.instances[instanceId].subprotocols.push(subprotocolStr)}function _WebSocketAllocate(url){var urlStr=UTF8ToString(url);var id=webSocketState.lastId++;webSocketState.instances[id]={url:urlStr,ws:null};return id}function _WebSocketClose(instanceId,code,reasonPtr){var instance=webSocketState.instances[instanceId];if(!instance)return-1;if(instance.ws===null)return-3;if(instance.ws.readyState===2)return-4;if(instance.ws.readyState===3)return-5;var reason=reasonPtr?UTF8ToString(reasonPtr):undefined;try{instance.ws.close(code,reason)}catch(err){return-7}return 0}function _WebSocketConnect(instanceId){var instance=webSocketState.instances[instanceId];if(!instance)return-1;if(instance.ws!==null)return-2;instance.ws=new WebSocket(instance.url);instance.ws.binaryType="arraybuffer";instance.ws.onopen=function(){if(webSocketState.debug)console.log("[JSLIB WebSocket] Connected.");if(webSocketState.onOpen)Module["dynCall_vi"](webSocketState.onOpen,instanceId)};instance.ws.onmessage=function(ev){if(webSocketState.debug)console.log("[JSLIB WebSocket] Received message:",ev.data);if(webSocketState.onMessage===null)return;if(ev.data instanceof ArrayBuffer){var dataBuffer=new Uint8Array(ev.data);var buffer=_malloc(dataBuffer.length);HEAPU8.set(dataBuffer,buffer);try{Module["dynCall_viii"](webSocketState.onMessage,instanceId,buffer,dataBuffer.length)}finally{_free(buffer)}}else if(typeof ev.data=="string"){var arrBuffer=new ArrayBuffer(ev.data.length);var dataBuffer=new Uint8Array(arrBuffer);for(var i=0,len=ev.data.length;i<len;i++){dataBuffer[i]=ev.data.charCodeAt(i)}var buffer=_malloc(dataBuffer.length);HEAPU8.set(dataBuffer,buffer);try{Module["dynCall_viii"](webSocketState.onMessage,instanceId,buffer,dataBuffer.length)}finally{_free(buffer)}}};instance.ws.onerror=function(ev){if(webSocketState.debug)console.log("[JSLIB WebSocket] Error occured.");if(webSocketState.onError){var msg="WebSocket error.";var msgBytes=lengthBytesUTF8(msg);var msgBuffer=_malloc(msgBytes+1);stringToUTF8(msg,msgBuffer,msgBytes);try{Module["dynCall_vii"](webSocketState.onError,instanceId,msgBuffer)}finally{_free(msgBuffer)}}};instance.ws.onclose=function(ev){if(webSocketState.debug)console.log("[JSLIB WebSocket] Closed.");if(webSocketState.onClose)Module["dynCall_vii"](webSocketState.onClose,instanceId,ev.code);delete instance.ws};return 0}function _WebSocketFree(instanceId){var instance=webSocketState.instances[instanceId];if(!instance)return 0;if(instance.ws!==null&&instance.ws.readyState<2)instance.ws.close();delete webSocketState.instances[instanceId];return 0}function _WebSocketGetState(instanceId){var instance=webSocketState.instances[instanceId];if(!instance)return-1;if(instance.ws)return instance.ws.readyState;else return 3}function _WebSocketSend(instanceId,bufferPtr,length){var instance=webSocketState.instances[instanceId];if(!instance)return-1;if(instance.ws===null)return-3;if(instance.ws.readyState!==1)return-6;instance.ws.send(HEAPU8.buffer.slice(bufferPtr,bufferPtr+length));return 0}function _WebSocketSendText(instanceId,message){var instance=webSocketState.instances[instanceId];if(!instance)return-1;if(!instance.ws)return-3;if(instance.ws.readyState!==1)return-6;instance.ws.send(UTF8ToString(message));return 0}function _WebSocketSetOnClose(callback){webSocketState.onClose=callback}function _WebSocketSetOnError(callback){webSocketState.onError=callback}function _WebSocketSetOnMessage(callback){webSocketState.onMessage=callback}function _WebSocketSetOnOpen(callback){webSocketState.onOpen=callback}function _WebSocketSetOnTextMessage(callback){webSocketState.onTextMessage=callback}function __DisconnectMetaMaskJS(){if(window.MMSDK){console.log("Checking if we can disconnect");var connection=window.MMSDK._getRemoteConnection();if(connection){console.log("Running window.MMSDK._getRemoteConnection().disconnect()");connection.disconnect()}else{console.log("No remote connection to disconnect")}}else{console.log("Did not disconnect MMSDK")}}function __HasMetaMaskJSSession(){return window.MMSDK&&window.MMSDK.isAuthorized()}function __InitMetaMaskJS(dappName,dappUrl,dappIcon,infuraAPIKey,readonlyRPCMapJson,walletConnectedCallback,providerReadyCallback,providerErrorCallback,providerEventCallback,doJsConnect,isDebug){var walletConnected=UTF8ToString(walletConnectedCallback);var providerReady=UTF8ToString(providerReadyCallback);var errorCallback=UTF8ToString(providerErrorCallback);var eventCallback=UTF8ToString(providerEventCallback);var readonlyRPCMap=JSON.parse(UTF8ToString(readonlyRPCMapJson));if(!window.MMSDK){window.MMSDK=new MetaMaskSDK.MetaMaskSDK({dappMetadata:{name:UTF8ToString(dappName),url:UTF8ToString(dappUrl),base64Icon:UTF8ToString(dappIcon)},infuraAPIKey:UTF8ToString(infuraAPIKey),readonlyRPCMap:readonlyRPCMap,logging:{developerMode:Boolean(isDebug)}})}var DoUnityCallback=(data,parmData)=>{var parms=data.split(":");var objName=parms[0];var functionName=parms[1];var guid=parms[2];var allParms=[guid];if(parmData){var json=JSON.stringify(parmData);allParms.push(json)}console.log("Doing Unity callback "+functionName+" with arguments "+JSON.stringify(allParms));window.unityInstance.SendMessage(objName,functionName,JSON.stringify(allParms))};var notReadyDelay=1;var PostSDKInit=()=>{try{var ethereum=window.MMSDK.getProvider();ethereum.on("accountsChanged",accounts=>{if(typeof accounts==="string"){accounts=[accounts]}var accountChangeEvent={method:"metamask_accountsChanged",params:accounts};DoUnityCallback(eventCallback,accountChangeEvent)});ethereum.on("chainChanged",chainId=>{if(typeof chainId==="string"){chainId={chainId:chainId,networkVersion:null}}var chainChangeEvent={method:"metamask_chainChanged",params:chainId};DoUnityCallback(eventCallback,chainChangeEvent)});DoUnityCallback(walletConnected)}catch(e){console.warn("MetaMask SDK provider not yet ready..");notReadyDelay*=2;setTimeout(PostSDKInit,notReadyDelay)}};var DoSDKInit=undefined;DoSDKInit=(()=>{if(!window.MMSDK.isInitialized){setTimeout(OnSDKInit,0);return}if(doJsConnect){window.MMSDK.connect().then(function(){PostSDKInit()}).catch(function(e){DoUnityCallback(errorCallback)})}else{PostSDKInit()}DoUnityCallback(providerReady)});setTimeout(DoSDKInit,0)}function __SendMetaMaskJS(idData,methodData,jsonData,responseCallback,errorCallback){var ethereum=window.MMSDK.getProvider();if(!ethereum){ethereum=window.ethereum}var DoUnityCallback=(data,parmData)=>{var parms=data.split(":");var objName=parms[0];var functionName=parms[1];var guid=parms[2];var allParms=[guid];if(parmData){var json=JSON.stringify(parmData);allParms.push(json)}window.unityInstance.SendMessage(objName,functionName,JSON.stringify(allParms))};const onResponse=UTF8ToString(responseCallback);const onError=UTF8ToString(errorCallback);const request=UTF8ToString(jsonData);const m=UTF8ToString(methodData);const i=UTF8ToString(idData);ethereum.request(JSON.parse(request)).then(result=>DoUnityCallback(onResponse,{method:m,id:i,jsonrpc:"2.0",result:result})).catch(e=>DoUnityCallback(onError,e))}function __SendRequestFetch(idUtf8,objectNameUtf8,methodUtf8,urlUtf8,parUtf8,isGet,authHeaderKeyUtf8,authHeaderValueUtf8){const id=UTF8ToString(idUtf8);const objectName=UTF8ToString(objectNameUtf8);const method=UTF8ToString(methodUtf8);const url=UTF8ToString(urlUtf8);const par=UTF8ToString(parUtf8);const authHeaderKey=UTF8ToString(authHeaderKeyUtf8);const authHeaderValue=UTF8ToString(authHeaderValueUtf8);let headers={};if(authHeaderKey){headers={[authHeaderKey]:authHeaderValue}}const data={method:method,body:par,headers:headers};fetch(url,data).then(function(resp){return resp.json()}).then(function(result){const resultData={responseJson:JSON.stringify(result),errorMessage:null,id:id};window.unityInstance.SendMessage(objectName,"OnFetchResponseCallback",JSON.stringify(resultData))}).catch(function(e){const resultData={responseJson:null,errorMessage:e.toString(),id:id};window.unityInstance.SendMessage(objectName,"OnFetchResponseCallback",JSON.stringify(resultData))})}function __TerminateMetaMaskJS(){if(window.MMSDK){console.log("Running MMSDK.terminate()");window.MMSDK.terminate()}else{console.log("Did not run MMSDK.terminate()")}}function ___cxa_allocate_exception(size){return _malloc(size+16)+16}function ExceptionInfo(excPtr){this.excPtr=excPtr;this.ptr=excPtr-16;this.set_type=function(type){HEAP32[this.ptr+4>>2]=type};this.get_type=function(){return HEAP32[this.ptr+4>>2]};this.set_destructor=function(destructor){HEAP32[this.ptr+8>>2]=destructor};this.get_destructor=function(){return HEAP32[this.ptr+8>>2]};this.set_refcount=function(refcount){HEAP32[this.ptr>>2]=refcount};this.set_caught=function(caught){caught=caught?1:0;HEAP8[this.ptr+12>>0]=caught};this.get_caught=function(){return HEAP8[this.ptr+12>>0]!=0};this.set_rethrown=function(rethrown){rethrown=rethrown?1:0;HEAP8[this.ptr+13>>0]=rethrown};this.get_rethrown=function(){return HEAP8[this.ptr+13>>0]!=0};this.init=function(type,destructor){this.set_type(type);this.set_destructor(destructor);this.set_refcount(0);this.set_caught(false);this.set_rethrown(false)};this.add_ref=function(){var value=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=value+1};this.release_ref=function(){var prev=HEAP32[this.ptr>>2];HEAP32[this.ptr>>2]=prev-1;return prev===1}}function CatchInfo(ptr){this.free=function(){_free(this.ptr);this.ptr=0};this.set_base_ptr=function(basePtr){HEAP32[this.ptr>>2]=basePtr};this.get_base_ptr=function(){return HEAP32[this.ptr>>2]};this.set_adjusted_ptr=function(adjustedPtr){HEAP32[this.ptr+4>>2]=adjustedPtr};this.get_adjusted_ptr_addr=function(){return this.ptr+4};this.get_adjusted_ptr=function(){return HEAP32[this.ptr+4>>2]};this.get_exception_ptr=function(){var isPointer=___cxa_is_pointer_type(this.get_exception_info().get_type());if(isPointer){return HEAP32[this.get_base_ptr()>>2]}var adjusted=this.get_adjusted_ptr();if(adjusted!==0)return adjusted;return this.get_base_ptr()};this.get_exception_info=function(){return new ExceptionInfo(this.get_base_ptr())};if(ptr===undefined){this.ptr=_malloc(8);this.set_adjusted_ptr(0)}else{this.ptr=ptr}}var exceptionCaught=[];function exception_addRef(info){info.add_ref()}var uncaughtExceptionCount=0;function ___cxa_begin_catch(ptr){var catchInfo=new CatchInfo(ptr);var info=catchInfo.get_exception_info();if(!info.get_caught()){info.set_caught(true);uncaughtExceptionCount--}info.set_rethrown(false);exceptionCaught.push(catchInfo);exception_addRef(info);return catchInfo.get_exception_ptr()}var exceptionLast=0;function ___cxa_free_exception(ptr){return _free(new ExceptionInfo(ptr).ptr)}function exception_decRef(info){if(info.release_ref()&&!info.get_rethrown()){var destructor=info.get_destructor();if(destructor){(function(a1){return dynCall_ii.apply(null,[destructor,a1])})(info.excPtr)}___cxa_free_exception(info.excPtr)}}function ___cxa_end_catch(){_setThrew(0);var catchInfo=exceptionCaught.pop();exception_decRef(catchInfo.get_exception_info());catchInfo.free();exceptionLast=0}function ___resumeException(catchInfoPtr){var catchInfo=new CatchInfo(catchInfoPtr);var ptr=catchInfo.get_base_ptr();if(!exceptionLast){exceptionLast=ptr}catchInfo.free();throw ptr}function ___cxa_find_matching_catch_2(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0|0}var info=new ExceptionInfo(thrown);var thrownType=info.get_type();var catchInfo=new CatchInfo;catchInfo.set_base_ptr(thrown);catchInfo.set_adjusted_ptr(thrown);if(!thrownType){setTempRet0(0);return catchInfo.ptr|0}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}if(___cxa_can_catch(caughtType,thrownType,catchInfo.get_adjusted_ptr_addr())){setTempRet0(caughtType);return catchInfo.ptr|0}}setTempRet0(thrownType);return catchInfo.ptr|0}function ___cxa_find_matching_catch_3(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0|0}var info=new ExceptionInfo(thrown);var thrownType=info.get_type();var catchInfo=new CatchInfo;catchInfo.set_base_ptr(thrown);catchInfo.set_adjusted_ptr(thrown);if(!thrownType){setTempRet0(0);return catchInfo.ptr|0}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}if(___cxa_can_catch(caughtType,thrownType,catchInfo.get_adjusted_ptr_addr())){setTempRet0(caughtType);return catchInfo.ptr|0}}setTempRet0(thrownType);return catchInfo.ptr|0}function ___cxa_find_matching_catch_4(){var thrown=exceptionLast;if(!thrown){setTempRet0(0);return 0|0}var info=new ExceptionInfo(thrown);var thrownType=info.get_type();var catchInfo=new CatchInfo;catchInfo.set_base_ptr(thrown);catchInfo.set_adjusted_ptr(thrown);if(!thrownType){setTempRet0(0);return catchInfo.ptr|0}var typeArray=Array.prototype.slice.call(arguments);for(var i=0;i<typeArray.length;i++){var caughtType=typeArray[i];if(caughtType===0||caughtType===thrownType){break}if(___cxa_can_catch(caughtType,thrownType,catchInfo.get_adjusted_ptr_addr())){setTempRet0(caughtType);return catchInfo.ptr|0}}setTempRet0(thrownType);return catchInfo.ptr|0}function ___cxa_rethrow(){var catchInfo=exceptionCaught.pop();if(!catchInfo){abort("no exception to throw")}var info=catchInfo.get_exception_info();var ptr=catchInfo.get_base_ptr();if(!info.get_rethrown()){exceptionCaught.push(catchInfo);info.set_rethrown(true);info.set_caught(false);uncaughtExceptionCount++}else{catchInfo.free()}exceptionLast=ptr;throw ptr}function ___cxa_throw(ptr,type,destructor){var info=new ExceptionInfo(ptr);info.init(type,destructor);exceptionLast=ptr;uncaughtExceptionCount++;throw ptr}var PATH={splitPath:function(filename){var splitPathRe=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;return splitPathRe.exec(filename).slice(1)},normalizeArray:function(parts,allowAboveRoot){var up=0;for(var i=parts.length-1;i>=0;i--){var last=parts[i];if(last==="."){parts.splice(i,1)}else if(last===".."){parts.splice(i,1);up++}else if(up){parts.splice(i,1);up--}}if(allowAboveRoot){for(;up;up--){parts.unshift("..")}}return parts},normalize:function(path){var isAbsolute=path.charAt(0)==="/",trailingSlash=path.substr(-1)==="/";path=PATH.normalizeArray(path.split("/").filter(function(p){return!!p}),!isAbsolute).join("/");if(!path&&!isAbsolute){path="."}if(path&&trailingSlash){path+="/"}return(isAbsolute?"/":"")+path},dirname:function(path){var result=PATH.splitPath(path),root=result[0],dir=result[1];if(!root&&!dir){return"."}if(dir){dir=dir.substr(0,dir.length-1)}return root+dir},basename:function(path){if(path==="/")return"/";path=PATH.normalize(path);path=path.replace(/\/$/,"");var lastSlash=path.lastIndexOf("/");if(lastSlash===-1)return path;return path.substr(lastSlash+1)},extname:function(path){return PATH.splitPath(path)[3]},join:function(){var paths=Array.prototype.slice.call(arguments,0);return PATH.normalize(paths.join("/"))},join2:function(l,r){return PATH.normalize(l+"/"+r)}};function getRandomDevice(){if(typeof crypto=="object"&&typeof crypto["getRandomValues"]=="function"){var randomBuffer=new Uint8Array(1);return function(){crypto.getRandomValues(randomBuffer);return randomBuffer[0]}}else if(ENVIRONMENT_IS_NODE){try{var crypto_module=require("crypto");return function(){return crypto_module["randomBytes"](1)[0]}}catch(e){}}return function(){abort("randomDevice")}}var PATH_FS={resolve:function(){var resolvedPath="",resolvedAbsolute=false;for(var i=arguments.length-1;i>=-1&&!resolvedAbsolute;i--){var path=i>=0?arguments[i]:FS.cwd();if(typeof path!="string"){throw new TypeError("Arguments to path.resolve must be strings")}else if(!path){return""}resolvedPath=path+"/"+resolvedPath;resolvedAbsolute=path.charAt(0)==="/"}resolvedPath=PATH.normalizeArray(resolvedPath.split("/").filter(function(p){return!!p}),!resolvedAbsolute).join("/");return(resolvedAbsolute?"/":"")+resolvedPath||"."},relative:function(from,to){from=PATH_FS.resolve(from).substr(1);to=PATH_FS.resolve(to).substr(1);function trim(arr){var start=0;for(;start<arr.length;start++){if(arr[start]!=="")break}var end=arr.length-1;for(;end>=0;end--){if(arr[end]!=="")break}if(start>end)return[];return arr.slice(start,end-start+1)}var fromParts=trim(from.split("/"));var toParts=trim(to.split("/"));var length=Math.min(fromParts.length,toParts.length);var samePartsLength=length;for(var i=0;i<length;i++){if(fromParts[i]!==toParts[i]){samePartsLength=i;break}}var outputParts=[];for(var i=samePartsLength;i<fromParts.length;i++){outputParts.push("..")}outputParts=outputParts.concat(toParts.slice(samePartsLength));return outputParts.join("/")}};var TTY={ttys:[],init:function(){},shutdown:function(){},register:function(dev,ops){TTY.ttys[dev]={input:[],output:[],ops:ops};FS.registerDevice(dev,TTY.stream_ops)},stream_ops:{open:function(stream){var tty=TTY.ttys[stream.node.rdev];if(!tty){throw new FS.ErrnoError(43)}stream.tty=tty;stream.seekable=false},close:function(stream){stream.tty.ops.flush(stream.tty)},flush:function(stream){stream.tty.ops.flush(stream.tty)},read:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.get_char){throw new FS.ErrnoError(60)}var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=stream.tty.ops.get_char(stream.tty)}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:function(stream,buffer,offset,length,pos){if(!stream.tty||!stream.tty.ops.put_char){throw new FS.ErrnoError(60)}try{for(var i=0;i<length;i++){stream.tty.ops.put_char(stream.tty,buffer[offset+i])}}catch(e){throw new FS.ErrnoError(29)}if(length){stream.node.timestamp=Date.now()}return i}},default_tty_ops:{get_char:function(tty){if(!tty.input.length){var result=null;if(ENVIRONMENT_IS_NODE){var BUFSIZE=256;var buf=Buffer.alloc(BUFSIZE);var bytesRead=0;try{bytesRead=fs.readSync(process.stdin.fd,buf,0,BUFSIZE,-1)}catch(e){if(e.toString().includes("EOF"))bytesRead=0;else throw e}if(bytesRead>0){result=buf.slice(0,bytesRead).toString("utf-8")}else{result=null}}else if(typeof window!="undefined"&&typeof window.prompt=="function"){result=window.prompt("Input: ");if(result!==null){result+="\n"}}else if(typeof readline=="function"){result=readline();if(result!==null){result+="\n"}}if(!result){return null}tty.input=intArrayFromString(result,true)}return tty.input.shift()},put_char:function(tty,val){if(val===null||val===10){out(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){out(UTF8ArrayToString(tty.output,0));tty.output=[]}}},default_tty1_ops:{put_char:function(tty,val){if(val===null||val===10){err(UTF8ArrayToString(tty.output,0));tty.output=[]}else{if(val!=0)tty.output.push(val)}},flush:function(tty){if(tty.output&&tty.output.length>0){err(UTF8ArrayToString(tty.output,0));tty.output=[]}}}};function zeroMemory(address,size){HEAPU8.fill(0,address,address+size)}function alignMemory(size,alignment){return Math.ceil(size/alignment)*alignment}function mmapAlloc(size){size=alignMemory(size,65536);var ptr=_emscripten_builtin_memalign(65536,size);if(!ptr)return 0;zeroMemory(ptr,size);return ptr}var MEMFS={ops_table:null,mount:function(mount){return MEMFS.createNode(null,"/",16384|511,0)},createNode:function(parent,name,mode,dev){if(FS.isBlkdev(mode)||FS.isFIFO(mode)){throw new FS.ErrnoError(63)}if(!MEMFS.ops_table){MEMFS.ops_table={dir:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,lookup:MEMFS.node_ops.lookup,mknod:MEMFS.node_ops.mknod,rename:MEMFS.node_ops.rename,unlink:MEMFS.node_ops.unlink,rmdir:MEMFS.node_ops.rmdir,readdir:MEMFS.node_ops.readdir,symlink:MEMFS.node_ops.symlink},stream:{llseek:MEMFS.stream_ops.llseek}},file:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:{llseek:MEMFS.stream_ops.llseek,read:MEMFS.stream_ops.read,write:MEMFS.stream_ops.write,allocate:MEMFS.stream_ops.allocate,mmap:MEMFS.stream_ops.mmap,msync:MEMFS.stream_ops.msync}},link:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr,readlink:MEMFS.node_ops.readlink},stream:{}},chrdev:{node:{getattr:MEMFS.node_ops.getattr,setattr:MEMFS.node_ops.setattr},stream:FS.chrdev_stream_ops}}}var node=FS.createNode(parent,name,mode,dev);if(FS.isDir(node.mode)){node.node_ops=MEMFS.ops_table.dir.node;node.stream_ops=MEMFS.ops_table.dir.stream;node.contents={}}else if(FS.isFile(node.mode)){node.node_ops=MEMFS.ops_table.file.node;node.stream_ops=MEMFS.ops_table.file.stream;node.usedBytes=0;node.contents=null}else if(FS.isLink(node.mode)){node.node_ops=MEMFS.ops_table.link.node;node.stream_ops=MEMFS.ops_table.link.stream}else if(FS.isChrdev(node.mode)){node.node_ops=MEMFS.ops_table.chrdev.node;node.stream_ops=MEMFS.ops_table.chrdev.stream}node.timestamp=Date.now();if(parent){parent.contents[name]=node;parent.timestamp=node.timestamp}return node},getFileDataAsTypedArray:function(node){if(!node.contents)return new Uint8Array(0);if(node.contents.subarray)return node.contents.subarray(0,node.usedBytes);return new Uint8Array(node.contents)},expandFileStorage:function(node,newCapacity){var prevCapacity=node.contents?node.contents.length:0;if(prevCapacity>=newCapacity)return;var CAPACITY_DOUBLING_MAX=1024*1024;newCapacity=Math.max(newCapacity,prevCapacity*(prevCapacity<CAPACITY_DOUBLING_MAX?2:1.125)>>>0);if(prevCapacity!=0)newCapacity=Math.max(newCapacity,256);var oldContents=node.contents;node.contents=new Uint8Array(newCapacity);if(node.usedBytes>0)node.contents.set(oldContents.subarray(0,node.usedBytes),0)},resizeFileStorage:function(node,newSize){if(node.usedBytes==newSize)return;if(newSize==0){node.contents=null;node.usedBytes=0}else{var oldContents=node.contents;node.contents=new Uint8Array(newSize);if(oldContents){node.contents.set(oldContents.subarray(0,Math.min(newSize,node.usedBytes)))}node.usedBytes=newSize}},node_ops:{getattr:function(node){var attr={};attr.dev=FS.isChrdev(node.mode)?node.id:1;attr.ino=node.id;attr.mode=node.mode;attr.nlink=1;attr.uid=0;attr.gid=0;attr.rdev=node.rdev;if(FS.isDir(node.mode)){attr.size=4096}else if(FS.isFile(node.mode)){attr.size=node.usedBytes}else if(FS.isLink(node.mode)){attr.size=node.link.length}else{attr.size=0}attr.atime=new Date(node.timestamp);attr.mtime=new Date(node.timestamp);attr.ctime=new Date(node.timestamp);attr.blksize=4096;attr.blocks=Math.ceil(attr.size/attr.blksize);return attr},setattr:function(node,attr){if(attr.mode!==undefined){node.mode=attr.mode}if(attr.timestamp!==undefined){node.timestamp=attr.timestamp}if(attr.size!==undefined){MEMFS.resizeFileStorage(node,attr.size)}},lookup:function(parent,name){throw FS.genericErrors[44]},mknod:function(parent,name,mode,dev){return MEMFS.createNode(parent,name,mode,dev)},rename:function(old_node,new_dir,new_name){if(FS.isDir(old_node.mode)){var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(new_node){for(var i in new_node.contents){throw new FS.ErrnoError(55)}}}delete old_node.parent.contents[old_node.name];old_node.parent.timestamp=Date.now();old_node.name=new_name;new_dir.contents[new_name]=old_node;new_dir.timestamp=old_node.parent.timestamp;old_node.parent=new_dir},unlink:function(parent,name){delete parent.contents[name];parent.timestamp=Date.now()},rmdir:function(parent,name){var node=FS.lookupNode(parent,name);for(var i in node.contents){throw new FS.ErrnoError(55)}delete parent.contents[name];parent.timestamp=Date.now()},readdir:function(node){var entries=[".",".."];for(var key in node.contents){if(!node.contents.hasOwnProperty(key)){continue}entries.push(key)}return entries},symlink:function(parent,newname,oldpath){var node=MEMFS.createNode(parent,newname,511|40960,0);node.link=oldpath;return node},readlink:function(node){if(!FS.isLink(node.mode)){throw new FS.ErrnoError(28)}return node.link}},stream_ops:{read:function(stream,buffer,offset,length,position){var contents=stream.node.contents;if(position>=stream.node.usedBytes)return 0;var size=Math.min(stream.node.usedBytes-position,length);if(size>8&&contents.subarray){buffer.set(contents.subarray(position,position+size),offset)}else{for(var i=0;i<size;i++)buffer[offset+i]=contents[position+i]}return size},write:function(stream,buffer,offset,length,position,canOwn){if(buffer.buffer===HEAP8.buffer){canOwn=false}if(!length)return 0;var node=stream.node;node.timestamp=Date.now();if(buffer.subarray&&(!node.contents||node.contents.subarray)){if(canOwn){node.contents=buffer.subarray(offset,offset+length);node.usedBytes=length;return length}else if(node.usedBytes===0&&position===0){node.contents=buffer.slice(offset,offset+length);node.usedBytes=length;return length}else if(position+length<=node.usedBytes){node.contents.set(buffer.subarray(offset,offset+length),position);return length}}MEMFS.expandFileStorage(node,position+length);if(node.contents.subarray&&buffer.subarray){node.contents.set(buffer.subarray(offset,offset+length),position)}else{for(var i=0;i<length;i++){node.contents[position+i]=buffer[offset+i]}}node.usedBytes=Math.max(node.usedBytes,position+length);return length},llseek:function(stream,offset,whence){var position=offset;if(whence===1){position+=stream.position}else if(whence===2){if(FS.isFile(stream.node.mode)){position+=stream.node.usedBytes}}if(position<0){throw new FS.ErrnoError(28)}return position},allocate:function(stream,offset,length){MEMFS.expandFileStorage(stream.node,offset+length);stream.node.usedBytes=Math.max(stream.node.usedBytes,offset+length)},mmap:function(stream,address,length,position,prot,flags){if(address!==0){throw new FS.ErrnoError(28)}if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}var ptr;var allocated;var contents=stream.node.contents;if(!(flags&2)&&contents.buffer===buffer){allocated=false;ptr=contents.byteOffset}else{if(position>0||position+length<contents.length){if(contents.subarray){contents=contents.subarray(position,position+length)}else{contents=Array.prototype.slice.call(contents,position,position+length)}}allocated=true;ptr=mmapAlloc(length);if(!ptr){throw new FS.ErrnoError(48)}HEAP8.set(contents,ptr)}return{ptr:ptr,allocated:allocated}},msync:function(stream,buffer,offset,length,mmapFlags){if(!FS.isFile(stream.node.mode)){throw new FS.ErrnoError(43)}if(mmapFlags&2){return 0}var bytesWritten=MEMFS.stream_ops.write(stream,buffer,0,length,offset,false);return 0}}};function asyncLoad(url,onload,onerror,noRunDep){var dep=!noRunDep?getUniqueRunDependency("al "+url):"";readAsync(url,function(arrayBuffer){assert(arrayBuffer,'Loading data file "'+url+'" failed (no arrayBuffer).');onload(new Uint8Array(arrayBuffer));if(dep)removeRunDependency(dep)},function(event){if(onerror){onerror()}else{throw'Loading data file "'+url+'" failed.'}});if(dep)addRunDependency(dep)}var IDBFS={dbs:{},indexedDB:()=>{if(typeof indexedDB!="undefined")return indexedDB;var ret=null;if(typeof window=="object")ret=window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB;assert(ret,"IDBFS used, but indexedDB not supported");return ret},DB_VERSION:21,DB_STORE_NAME:"FILE_DATA",mount:function(mount){return MEMFS.mount.apply(null,arguments)},syncfs:(mount,populate,callback)=>{IDBFS.getLocalSet(mount,(err,local)=>{if(err)return callback(err);IDBFS.getRemoteSet(mount,(err,remote)=>{if(err)return callback(err);var src=populate?remote:local;var dst=populate?local:remote;IDBFS.reconcile(src,dst,callback)})})},getDB:(name,callback)=>{var db=IDBFS.dbs[name];if(db){return callback(null,db)}var req;try{req=IDBFS.indexedDB().open(name,IDBFS.DB_VERSION)}catch(e){return callback(e)}if(!req){return callback("Unable to connect to IndexedDB")}req.onupgradeneeded=(e=>{var db=e.target.result;var transaction=e.target.transaction;var fileStore;if(db.objectStoreNames.contains(IDBFS.DB_STORE_NAME)){fileStore=transaction.objectStore(IDBFS.DB_STORE_NAME)}else{fileStore=db.createObjectStore(IDBFS.DB_STORE_NAME)}if(!fileStore.indexNames.contains("timestamp")){fileStore.createIndex("timestamp","timestamp",{unique:false})}});req.onsuccess=(()=>{db=req.result;IDBFS.dbs[name]=db;callback(null,db)});req.onerror=(e=>{callback(this.error);e.preventDefault()})},getLocalSet:(mount,callback)=>{var entries={};function isRealDir(p){return p!=="."&&p!==".."}function toAbsolute(root){return p=>{return PATH.join2(root,p)}}var check=FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));while(check.length){var path=check.pop();var stat;try{stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){check.push.apply(check,FS.readdir(path).filter(isRealDir).map(toAbsolute(path)))}entries[path]={"timestamp":stat.mtime}}return callback(null,{type:"local",entries:entries})},getRemoteSet:(mount,callback)=>{var entries={};IDBFS.getDB(mount.mountpoint,(err,db)=>{if(err)return callback(err);try{var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readonly");transaction.onerror=(e=>{callback(this.error);e.preventDefault()});var store=transaction.objectStore(IDBFS.DB_STORE_NAME);var index=store.index("timestamp");index.openKeyCursor().onsuccess=(event=>{var cursor=event.target.result;if(!cursor){return callback(null,{type:"remote",db:db,entries:entries})}entries[cursor.primaryKey]={"timestamp":cursor.key};cursor.continue()})}catch(e){return callback(e)}})},loadLocalEntry:(path,callback)=>{var stat,node;try{var lookup=FS.lookupPath(path);node=lookup.node;stat=FS.stat(path)}catch(e){return callback(e)}if(FS.isDir(stat.mode)){return callback(null,{"timestamp":stat.mtime,"mode":stat.mode})}else if(FS.isFile(stat.mode)){node.contents=MEMFS.getFileDataAsTypedArray(node);return callback(null,{"timestamp":stat.mtime,"mode":stat.mode,"contents":node.contents})}else{return callback(new Error("node type not supported"))}},storeLocalEntry:(path,entry,callback)=>{try{if(FS.isDir(entry["mode"])){FS.mkdirTree(path,entry["mode"])}else if(FS.isFile(entry["mode"])){FS.writeFile(path,entry["contents"],{canOwn:true})}else{return callback(new Error("node type not supported"))}FS.chmod(path,entry["mode"]);FS.utime(path,entry["timestamp"],entry["timestamp"])}catch(e){return callback(e)}callback(null)},removeLocalEntry:(path,callback)=>{try{var lookup=FS.lookupPath(path);var stat=FS.stat(path);if(FS.isDir(stat.mode)){FS.rmdir(path)}else if(FS.isFile(stat.mode)){FS.unlink(path)}}catch(e){return callback(e)}callback(null)},loadRemoteEntry:(store,path,callback)=>{var req=store.get(path);req.onsuccess=(event=>{callback(null,event.target.result)});req.onerror=(e=>{callback(this.error);e.preventDefault()})},storeRemoteEntry:(store,path,entry,callback)=>{try{var req=store.put(entry,path)}catch(e){callback(e);return}req.onsuccess=(()=>{callback(null)});req.onerror=(e=>{callback(this.error);e.preventDefault()})},removeRemoteEntry:(store,path,callback)=>{var req=store.delete(path);req.onsuccess=(()=>{callback(null)});req.onerror=(e=>{callback(this.error);e.preventDefault()})},reconcile:(src,dst,callback)=>{var total=0;var create=[];Object.keys(src.entries).forEach(function(key){var e=src.entries[key];var e2=dst.entries[key];if(!e2||e["timestamp"].getTime()!=e2["timestamp"].getTime()){create.push(key);total++}});var remove=[];Object.keys(dst.entries).forEach(function(key){if(!src.entries[key]){remove.push(key);total++}});if(!total){return callback(null)}var errored=false;var db=src.type==="remote"?src.db:dst.db;var transaction=db.transaction([IDBFS.DB_STORE_NAME],"readwrite");var store=transaction.objectStore(IDBFS.DB_STORE_NAME);function done(err){if(err&&!errored){errored=true;return callback(err)}}transaction.onerror=(e=>{done(this.error);e.preventDefault()});transaction.oncomplete=(e=>{if(!errored){callback(null)}});create.sort().forEach(path=>{if(dst.type==="local"){IDBFS.loadRemoteEntry(store,path,(err,entry)=>{if(err)return done(err);IDBFS.storeLocalEntry(path,entry,done)})}else{IDBFS.loadLocalEntry(path,(err,entry)=>{if(err)return done(err);IDBFS.storeRemoteEntry(store,path,entry,done)})}});remove.sort().reverse().forEach(path=>{if(dst.type==="local"){IDBFS.removeLocalEntry(path,done)}else{IDBFS.removeRemoteEntry(store,path,done)}})}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:(path,opts={})=>{path=PATH_FS.resolve(FS.cwd(),path);if(!path)return{path:"",node:null};var defaults={follow_mount:true,recurse_count:0};opts=Object.assign(defaults,opts);if(opts.recurse_count>8){throw new FS.ErrnoError(32)}var parts=PATH.normalizeArray(path.split("/").filter(p=>!!p),false);var current=FS.root;var current_path="/";for(var i=0;i<parts.length;i++){var islast=i===parts.length-1;if(islast&&opts.parent){break}current=FS.lookupNode(current,parts[i]);current_path=PATH.join2(current_path,parts[i]);if(FS.isMountpoint(current)){if(!islast||islast&&opts.follow_mount){current=current.mounted.root}}if(!islast||opts.follow){var count=0;while(FS.isLink(current.mode)){var link=FS.readlink(current_path);current_path=PATH_FS.resolve(PATH.dirname(current_path),link);var lookup=FS.lookupPath(current_path,{recurse_count:opts.recurse_count+1});current=lookup.node;if(count++>40){throw new FS.ErrnoError(32)}}}}return{path:current_path,node:current}},getPath:node=>{var path;while(true){if(FS.isRoot(node)){var mount=node.mount.mountpoint;if(!path)return mount;return mount[mount.length-1]!=="/"?mount+"/"+path:mount+path}path=path?node.name+"/"+path:node.name;node=node.parent}},hashName:(parentid,name)=>{var hash=0;for(var i=0;i<name.length;i++){hash=(hash<<5)-hash+name.charCodeAt(i)|0}return(parentid+hash>>>0)%FS.nameTable.length},hashAddNode:node=>{var hash=FS.hashName(node.parent.id,node.name);node.name_next=FS.nameTable[hash];FS.nameTable[hash]=node},hashRemoveNode:node=>{var hash=FS.hashName(node.parent.id,node.name);if(FS.nameTable[hash]===node){FS.nameTable[hash]=node.name_next}else{var current=FS.nameTable[hash];while(current){if(current.name_next===node){current.name_next=node.name_next;break}current=current.name_next}}},lookupNode:(parent,name)=>{var errCode=FS.mayLookup(parent);if(errCode){throw new FS.ErrnoError(errCode,parent)}var hash=FS.hashName(parent.id,name);for(var node=FS.nameTable[hash];node;node=node.name_next){var nodeName=node.name;if(node.parent.id===parent.id&&nodeName===name){return node}}return FS.lookup(parent,name)},createNode:(parent,name,mode,rdev)=>{var node=new FS.FSNode(parent,name,mode,rdev);FS.hashAddNode(node);return node},destroyNode:node=>{FS.hashRemoveNode(node)},isRoot:node=>{return node===node.parent},isMountpoint:node=>{return!!node.mounted},isFile:mode=>{return(mode&61440)===32768},isDir:mode=>{return(mode&61440)===16384},isLink:mode=>{return(mode&61440)===40960},isChrdev:mode=>{return(mode&61440)===8192},isBlkdev:mode=>{return(mode&61440)===24576},isFIFO:mode=>{return(mode&61440)===4096},isSocket:mode=>{return(mode&49152)===49152},flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:str=>{var flags=FS.flagModes[str];if(typeof flags=="undefined"){throw new Error("Unknown file open mode: "+str)}return flags},flagsToPermissionString:flag=>{var perms=["r","w","rw"][flag&3];if(flag&512){perms+="w"}return perms},nodePermissions:(node,perms)=>{if(FS.ignorePermissions){return 0}if(perms.includes("r")&&!(node.mode&292)){return 2}else if(perms.includes("w")&&!(node.mode&146)){return 2}else if(perms.includes("x")&&!(node.mode&73)){return 2}return 0},mayLookup:dir=>{var errCode=FS.nodePermissions(dir,"x");if(errCode)return errCode;if(!dir.node_ops.lookup)return 2;return 0},mayCreate:(dir,name)=>{try{var node=FS.lookupNode(dir,name);return 20}catch(e){}return FS.nodePermissions(dir,"wx")},mayDelete:(dir,name,isdir)=>{var node;try{node=FS.lookupNode(dir,name)}catch(e){return e.errno}var errCode=FS.nodePermissions(dir,"wx");if(errCode){return errCode}if(isdir){if(!FS.isDir(node.mode)){return 54}if(FS.isRoot(node)||FS.getPath(node)===FS.cwd()){return 10}}else{if(FS.isDir(node.mode)){return 31}}return 0},mayOpen:(node,flags)=>{if(!node){return 44}if(FS.isLink(node.mode)){return 32}else if(FS.isDir(node.mode)){if(FS.flagsToPermissionString(flags)!=="r"||flags&512){return 31}}return FS.nodePermissions(node,FS.flagsToPermissionString(flags))},MAX_OPEN_FDS:4096,nextfd:(fd_start=0,fd_end=FS.MAX_OPEN_FDS)=>{for(var fd=fd_start;fd<=fd_end;fd++){if(!FS.streams[fd]){return fd}}throw new FS.ErrnoError(33)},getStream:fd=>FS.streams[fd],createStream:(stream,fd_start,fd_end)=>{if(!FS.FSStream){FS.FSStream=function(){};FS.FSStream.prototype={object:{get:function(){return this.node},set:function(val){this.node=val}},isRead:{get:function(){return(this.flags&2097155)!==1}},isWrite:{get:function(){return(this.flags&2097155)!==0}},isAppend:{get:function(){return this.flags&1024}}}}stream=Object.assign(new FS.FSStream,stream);var fd=FS.nextfd(fd_start,fd_end);stream.fd=fd;FS.streams[fd]=stream;return stream},closeStream:fd=>{FS.streams[fd]=null},chrdev_stream_ops:{open:stream=>{var device=FS.getDevice(stream.node.rdev);stream.stream_ops=device.stream_ops;if(stream.stream_ops.open){stream.stream_ops.open(stream)}},llseek:()=>{throw new FS.ErrnoError(70)}},major:dev=>dev>>8,minor:dev=>dev&255,makedev:(ma,mi)=>ma<<8|mi,registerDevice:(dev,ops)=>{FS.devices[dev]={stream_ops:ops}},getDevice:dev=>FS.devices[dev],getMounts:mount=>{var mounts=[];var check=[mount];while(check.length){var m=check.pop();mounts.push(m);check.push.apply(check,m.mounts)}return mounts},syncfs:(populate,callback)=>{if(typeof populate=="function"){callback=populate;populate=false}FS.syncFSRequests++;if(FS.syncFSRequests>1){err("warning: "+FS.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work")}var mounts=FS.getMounts(FS.root.mount);var completed=0;function doCallback(errCode){FS.syncFSRequests--;return callback(errCode)}function done(errCode){if(errCode){if(!done.errored){done.errored=true;return doCallback(errCode)}return}if(++completed>=mounts.length){doCallback(null)}}mounts.forEach(mount=>{if(!mount.type.syncfs){return done(null)}mount.type.syncfs(mount,populate,done)})},mount:(type,opts,mountpoint)=>{var root=mountpoint==="/";var pseudo=!mountpoint;var node;if(root&&FS.root){throw new FS.ErrnoError(10)}else if(!root&&!pseudo){var lookup=FS.lookupPath(mountpoint,{follow_mount:false});mountpoint=lookup.path;node=lookup.node;if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}if(!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}}var mount={type:type,opts:opts,mountpoint:mountpoint,mounts:[]};var mountRoot=type.mount(mount);mountRoot.mount=mount;mount.root=mountRoot;if(root){FS.root=mountRoot}else if(node){node.mounted=mount;if(node.mount){node.mount.mounts.push(mount)}}return mountRoot},unmount:mountpoint=>{var lookup=FS.lookupPath(mountpoint,{follow_mount:false});if(!FS.isMountpoint(lookup.node)){throw new FS.ErrnoError(28)}var node=lookup.node;var mount=node.mounted;var mounts=FS.getMounts(mount);Object.keys(FS.nameTable).forEach(hash=>{var current=FS.nameTable[hash];while(current){var next=current.name_next;if(mounts.includes(current.mount)){FS.destroyNode(current)}current=next}});node.mounted=null;var idx=node.mount.mounts.indexOf(mount);node.mount.mounts.splice(idx,1)},lookup:(parent,name)=>{return parent.node_ops.lookup(parent,name)},mknod:(path,mode,dev)=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);if(!name||name==="."||name===".."){throw new FS.ErrnoError(28)}var errCode=FS.mayCreate(parent,name);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.mknod){throw new FS.ErrnoError(63)}return parent.node_ops.mknod(parent,name,mode,dev)},create:(path,mode)=>{mode=mode!==undefined?mode:438;mode&=4095;mode|=32768;return FS.mknod(path,mode,0)},mkdir:(path,mode)=>{mode=mode!==undefined?mode:511;mode&=511|512;mode|=16384;return FS.mknod(path,mode,0)},mkdirTree:(path,mode)=>{var dirs=path.split("/");var d="";for(var i=0;i<dirs.length;++i){if(!dirs[i])continue;d+="/"+dirs[i];try{FS.mkdir(d,mode)}catch(e){if(e.errno!=20)throw e}}},mkdev:(path,mode,dev)=>{if(typeof dev=="undefined"){dev=mode;mode=438}mode|=8192;return FS.mknod(path,mode,dev)},symlink:(oldpath,newpath)=>{if(!PATH_FS.resolve(oldpath)){throw new FS.ErrnoError(44)}var lookup=FS.lookupPath(newpath,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var newname=PATH.basename(newpath);var errCode=FS.mayCreate(parent,newname);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.symlink){throw new FS.ErrnoError(63)}return parent.node_ops.symlink(parent,newname,oldpath)},rename:(old_path,new_path)=>{var old_dirname=PATH.dirname(old_path);var new_dirname=PATH.dirname(new_path);var old_name=PATH.basename(old_path);var new_name=PATH.basename(new_path);var lookup,old_dir,new_dir;lookup=FS.lookupPath(old_path,{parent:true});old_dir=lookup.node;lookup=FS.lookupPath(new_path,{parent:true});new_dir=lookup.node;if(!old_dir||!new_dir)throw new FS.ErrnoError(44);if(old_dir.mount!==new_dir.mount){throw new FS.ErrnoError(75)}var old_node=FS.lookupNode(old_dir,old_name);var relative=PATH_FS.relative(old_path,new_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(28)}relative=PATH_FS.relative(new_path,old_dirname);if(relative.charAt(0)!=="."){throw new FS.ErrnoError(55)}var new_node;try{new_node=FS.lookupNode(new_dir,new_name)}catch(e){}if(old_node===new_node){return}var isdir=FS.isDir(old_node.mode);var errCode=FS.mayDelete(old_dir,old_name,isdir);if(errCode){throw new FS.ErrnoError(errCode)}errCode=new_node?FS.mayDelete(new_dir,new_name,isdir):FS.mayCreate(new_dir,new_name);if(errCode){throw new FS.ErrnoError(errCode)}if(!old_dir.node_ops.rename){throw new FS.ErrnoError(63)}if(FS.isMountpoint(old_node)||new_node&&FS.isMountpoint(new_node)){throw new FS.ErrnoError(10)}if(new_dir!==old_dir){errCode=FS.nodePermissions(old_dir,"w");if(errCode){throw new FS.ErrnoError(errCode)}}FS.hashRemoveNode(old_node);try{old_dir.node_ops.rename(old_node,new_dir,new_name)}catch(e){throw e}finally{FS.hashAddNode(old_node)}},rmdir:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,true);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.rmdir){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.rmdir(parent,name);FS.destroyNode(node)},readdir:path=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node.node_ops.readdir){throw new FS.ErrnoError(54)}return node.node_ops.readdir(node)},unlink:path=>{var lookup=FS.lookupPath(path,{parent:true});var parent=lookup.node;if(!parent){throw new FS.ErrnoError(44)}var name=PATH.basename(path);var node=FS.lookupNode(parent,name);var errCode=FS.mayDelete(parent,name,false);if(errCode){throw new FS.ErrnoError(errCode)}if(!parent.node_ops.unlink){throw new FS.ErrnoError(63)}if(FS.isMountpoint(node)){throw new FS.ErrnoError(10)}parent.node_ops.unlink(parent,name);FS.destroyNode(node)},readlink:path=>{var lookup=FS.lookupPath(path);var link=lookup.node;if(!link){throw new FS.ErrnoError(44)}if(!link.node_ops.readlink){throw new FS.ErrnoError(28)}return PATH_FS.resolve(FS.getPath(link.parent),link.node_ops.readlink(link))},stat:(path,dontFollow)=>{var lookup=FS.lookupPath(path,{follow:!dontFollow});var node=lookup.node;if(!node){throw new FS.ErrnoError(44)}if(!node.node_ops.getattr){throw new FS.ErrnoError(63)}return node.node_ops.getattr(node)},lstat:path=>{return FS.stat(path,true)},chmod:(path,mode,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{mode:mode&4095|node.mode&~4095,timestamp:Date.now()})},lchmod:(path,mode)=>{FS.chmod(path,mode,true)},fchmod:(fd,mode)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chmod(stream.node,mode)},chown:(path,uid,gid,dontFollow)=>{var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:!dontFollow});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}node.node_ops.setattr(node,{timestamp:Date.now()})},lchown:(path,uid,gid)=>{FS.chown(path,uid,gid,true)},fchown:(fd,uid,gid)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}FS.chown(stream.node,uid,gid)},truncate:(path,len)=>{if(len<0){throw new FS.ErrnoError(28)}var node;if(typeof path=="string"){var lookup=FS.lookupPath(path,{follow:true});node=lookup.node}else{node=path}if(!node.node_ops.setattr){throw new FS.ErrnoError(63)}if(FS.isDir(node.mode)){throw new FS.ErrnoError(31)}if(!FS.isFile(node.mode)){throw new FS.ErrnoError(28)}var errCode=FS.nodePermissions(node,"w");if(errCode){throw new FS.ErrnoError(errCode)}node.node_ops.setattr(node,{size:len,timestamp:Date.now()})},ftruncate:(fd,len)=>{var stream=FS.getStream(fd);if(!stream){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(28)}FS.truncate(stream.node,len)},utime:(path,atime,mtime)=>{var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;node.node_ops.setattr(node,{timestamp:Math.max(atime,mtime)})},open:(path,flags,mode,fd_start,fd_end)=>{if(path===""){throw new FS.ErrnoError(44)}flags=typeof flags=="string"?FS.modeStringToFlags(flags):flags;mode=typeof mode=="undefined"?438:mode;if(flags&64){mode=mode&4095|32768}else{mode=0}var node;if(typeof path=="object"){node=path}else{path=PATH.normalize(path);try{var lookup=FS.lookupPath(path,{follow:!(flags&131072)});node=lookup.node}catch(e){}}var created=false;if(flags&64){if(node){if(flags&128){throw new FS.ErrnoError(20)}}else{node=FS.mknod(path,mode,0);created=true}}if(!node){throw new FS.ErrnoError(44)}if(FS.isChrdev(node.mode)){flags&=~512}if(flags&65536&&!FS.isDir(node.mode)){throw new FS.ErrnoError(54)}if(!created){var errCode=FS.mayOpen(node,flags);if(errCode){throw new FS.ErrnoError(errCode)}}if(flags&512){FS.truncate(node,0)}flags&=~(128|512|131072);var stream=FS.createStream({node:node,path:FS.getPath(node),flags:flags,seekable:true,position:0,stream_ops:node.stream_ops,ungotten:[],error:false},fd_start,fd_end);if(stream.stream_ops.open){stream.stream_ops.open(stream)}if(Module["logReadFiles"]&&!(flags&1)){if(!FS.readFiles)FS.readFiles={};if(!(path in FS.readFiles)){FS.readFiles[path]=1}}return stream},close:stream=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(stream.getdents)stream.getdents=null;try{if(stream.stream_ops.close){stream.stream_ops.close(stream)}}catch(e){throw e}finally{FS.closeStream(stream.fd)}stream.fd=null},isClosed:stream=>{return stream.fd===null},llseek:(stream,offset,whence)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(!stream.seekable||!stream.stream_ops.llseek){throw new FS.ErrnoError(70)}if(whence!=0&&whence!=1&&whence!=2){throw new FS.ErrnoError(28)}stream.position=stream.stream_ops.llseek(stream,offset,whence);stream.ungotten=[];return stream.position},read:(stream,buffer,offset,length,position)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.read){throw new FS.ErrnoError(28)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesRead=stream.stream_ops.read(stream,buffer,offset,length,position);if(!seeking)stream.position+=bytesRead;return bytesRead},write:(stream,buffer,offset,length,position,canOwn)=>{if(length<0||position<0){throw new FS.ErrnoError(28)}if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(FS.isDir(stream.node.mode)){throw new FS.ErrnoError(31)}if(!stream.stream_ops.write){throw new FS.ErrnoError(28)}if(stream.seekable&&stream.flags&1024){FS.llseek(stream,0,2)}var seeking=typeof position!="undefined";if(!seeking){position=stream.position}else if(!stream.seekable){throw new FS.ErrnoError(70)}var bytesWritten=stream.stream_ops.write(stream,buffer,offset,length,position,canOwn);if(!seeking)stream.position+=bytesWritten;return bytesWritten},allocate:(stream,offset,length)=>{if(FS.isClosed(stream)){throw new FS.ErrnoError(8)}if(offset<0||length<=0){throw new FS.ErrnoError(28)}if((stream.flags&2097155)===0){throw new FS.ErrnoError(8)}if(!FS.isFile(stream.node.mode)&&!FS.isDir(stream.node.mode)){throw new FS.ErrnoError(43)}if(!stream.stream_ops.allocate){throw new FS.ErrnoError(138)}stream.stream_ops.allocate(stream,offset,length)},mmap:(stream,address,length,position,prot,flags)=>{if((prot&2)!==0&&(flags&2)===0&&(stream.flags&2097155)!==2){throw new FS.ErrnoError(2)}if((stream.flags&2097155)===1){throw new FS.ErrnoError(2)}if(!stream.stream_ops.mmap){throw new FS.ErrnoError(43)}return stream.stream_ops.mmap(stream,address,length,position,prot,flags)},msync:(stream,buffer,offset,length,mmapFlags)=>{if(!stream||!stream.stream_ops.msync){return 0}return stream.stream_ops.msync(stream,buffer,offset,length,mmapFlags)},munmap:stream=>0,ioctl:(stream,cmd,arg)=>{if(!stream.stream_ops.ioctl){throw new FS.ErrnoError(59)}return stream.stream_ops.ioctl(stream,cmd,arg)},readFile:(path,opts={})=>{opts.flags=opts.flags||0;opts.encoding=opts.encoding||"binary";if(opts.encoding!=="utf8"&&opts.encoding!=="binary"){throw new Error('Invalid encoding type "'+opts.encoding+'"')}var ret;var stream=FS.open(path,opts.flags);var stat=FS.stat(path);var length=stat.size;var buf=new Uint8Array(length);FS.read(stream,buf,0,length,0);if(opts.encoding==="utf8"){ret=UTF8ArrayToString(buf,0)}else if(opts.encoding==="binary"){ret=buf}FS.close(stream);return ret},writeFile:(path,data,opts={})=>{opts.flags=opts.flags||577;var stream=FS.open(path,opts.flags,opts.mode);if(typeof data=="string"){var buf=new Uint8Array(lengthBytesUTF8(data)+1);var actualNumBytes=stringToUTF8Array(data,buf,0,buf.length);FS.write(stream,buf,0,actualNumBytes,undefined,opts.canOwn)}else if(ArrayBuffer.isView(data)){FS.write(stream,data,0,data.byteLength,undefined,opts.canOwn)}else{throw new Error("Unsupported data type")}FS.close(stream)},cwd:()=>FS.currentPath,chdir:path=>{var lookup=FS.lookupPath(path,{follow:true});if(lookup.node===null){throw new FS.ErrnoError(44)}if(!FS.isDir(lookup.node.mode)){throw new FS.ErrnoError(54)}var errCode=FS.nodePermissions(lookup.node,"x");if(errCode){throw new FS.ErrnoError(errCode)}FS.currentPath=lookup.path},createDefaultDirectories:()=>{FS.mkdir("/tmp");FS.mkdir("/home");FS.mkdir("/home/web_user")},createDefaultDevices:()=>{FS.mkdir("/dev");FS.registerDevice(FS.makedev(1,3),{read:()=>0,write:(stream,buffer,offset,length,pos)=>length});FS.mkdev("/dev/null",FS.makedev(1,3));TTY.register(FS.makedev(5,0),TTY.default_tty_ops);TTY.register(FS.makedev(6,0),TTY.default_tty1_ops);FS.mkdev("/dev/tty",FS.makedev(5,0));FS.mkdev("/dev/tty1",FS.makedev(6,0));var random_device=getRandomDevice();FS.createDevice("/dev","random",random_device);FS.createDevice("/dev","urandom",random_device);FS.mkdir("/dev/shm");FS.mkdir("/dev/shm/tmp")},createSpecialDirectories:()=>{FS.mkdir("/proc");var proc_self=FS.mkdir("/proc/self");FS.mkdir("/proc/self/fd");FS.mount({mount:()=>{var node=FS.createNode(proc_self,"fd",16384|511,73);node.node_ops={lookup:(parent,name)=>{var fd=+name;var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var ret={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:()=>stream.path}};ret.parent=ret;return ret}};return node}},{},"/proc/self/fd")},createStandardStreams:()=>{if(Module["stdin"]){FS.createDevice("/dev","stdin",Module["stdin"])}else{FS.symlink("/dev/tty","/dev/stdin")}if(Module["stdout"]){FS.createDevice("/dev","stdout",null,Module["stdout"])}else{FS.symlink("/dev/tty","/dev/stdout")}if(Module["stderr"]){FS.createDevice("/dev","stderr",null,Module["stderr"])}else{FS.symlink("/dev/tty1","/dev/stderr")}var stdin=FS.open("/dev/stdin",0);var stdout=FS.open("/dev/stdout",1);var stderr=FS.open("/dev/stderr",1)},ensureErrnoError:()=>{if(FS.ErrnoError)return;FS.ErrnoError=function ErrnoError(errno,node){this.node=node;this.setErrno=function(errno){this.errno=errno};this.setErrno(errno);this.message="FS error"};FS.ErrnoError.prototype=new Error;FS.ErrnoError.prototype.constructor=FS.ErrnoError;[44].forEach(code=>{FS.genericErrors[code]=new FS.ErrnoError(code);FS.genericErrors[code].stack="<generic error, no stack>"})},staticInit:()=>{FS.ensureErrnoError();FS.nameTable=new Array(4096);FS.mount(MEMFS,{},"/");FS.createDefaultDirectories();FS.createDefaultDevices();FS.createSpecialDirectories();FS.filesystems={"MEMFS":MEMFS,"IDBFS":IDBFS}},init:(input,output,error)=>{FS.init.initialized=true;FS.ensureErrnoError();Module["stdin"]=input||Module["stdin"];Module["stdout"]=output||Module["stdout"];Module["stderr"]=error||Module["stderr"];FS.createStandardStreams()},quit:()=>{FS.init.initialized=false;for(var i=0;i<FS.streams.length;i++){var stream=FS.streams[i];if(!stream){continue}FS.close(stream)}},getMode:(canRead,canWrite)=>{var mode=0;if(canRead)mode|=292|73;if(canWrite)mode|=146;return mode},findObject:(path,dontResolveLastLink)=>{var ret=FS.analyzePath(path,dontResolveLastLink);if(ret.exists){return ret.object}else{return null}},analyzePath:(path,dontResolveLastLink)=>{try{var lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});path=lookup.path}catch(e){}var ret={isRoot:false,exists:false,error:0,name:null,path:null,object:null,parentExists:false,parentPath:null,parentObject:null};try{var lookup=FS.lookupPath(path,{parent:true});ret.parentExists=true;ret.parentPath=lookup.path;ret.parentObject=lookup.node;ret.name=PATH.basename(path);lookup=FS.lookupPath(path,{follow:!dontResolveLastLink});ret.exists=true;ret.path=lookup.path;ret.object=lookup.node;ret.name=lookup.node.name;ret.isRoot=lookup.path==="/"}catch(e){ret.error=e.errno}return ret},createPath:(parent,path,canRead,canWrite)=>{parent=typeof parent=="string"?parent:FS.getPath(parent);var parts=path.split("/").reverse();while(parts.length){var part=parts.pop();if(!part)continue;var current=PATH.join2(parent,part);try{FS.mkdir(current)}catch(e){}parent=current}return current},createFile:(parent,name,properties,canRead,canWrite)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(canRead,canWrite);return FS.create(path,mode)},createDataFile:(parent,name,data,canRead,canWrite,canOwn)=>{var path=name;if(parent){parent=typeof parent=="string"?parent:FS.getPath(parent);path=name?PATH.join2(parent,name):parent}var mode=FS.getMode(canRead,canWrite);var node=FS.create(path,mode);if(data){if(typeof data=="string"){var arr=new Array(data.length);for(var i=0,len=data.length;i<len;++i)arr[i]=data.charCodeAt(i);data=arr}FS.chmod(node,mode|146);var stream=FS.open(node,577);FS.write(stream,data,0,data.length,0,canOwn);FS.close(stream);FS.chmod(node,mode)}return node},createDevice:(parent,name,input,output)=>{var path=PATH.join2(typeof parent=="string"?parent:FS.getPath(parent),name);var mode=FS.getMode(!!input,!!output);if(!FS.createDevice.major)FS.createDevice.major=64;var dev=FS.makedev(FS.createDevice.major++,0);FS.registerDevice(dev,{open:stream=>{stream.seekable=false},close:stream=>{if(output&&output.buffer&&output.buffer.length){output(10)}},read:(stream,buffer,offset,length,pos)=>{var bytesRead=0;for(var i=0;i<length;i++){var result;try{result=input()}catch(e){throw new FS.ErrnoError(29)}if(result===undefined&&bytesRead===0){throw new FS.ErrnoError(6)}if(result===null||result===undefined)break;bytesRead++;buffer[offset+i]=result}if(bytesRead){stream.node.timestamp=Date.now()}return bytesRead},write:(stream,buffer,offset,length,pos)=>{for(var i=0;i<length;i++){try{output(buffer[offset+i])}catch(e){throw new FS.ErrnoError(29)}}if(length){stream.node.timestamp=Date.now()}return i}});return FS.mkdev(path,mode,dev)},forceLoadFile:obj=>{if(obj.isDevice||obj.isFolder||obj.link||obj.contents)return true;if(typeof XMLHttpRequest!="undefined"){throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.")}else if(read_){try{obj.contents=intArrayFromString(read_(obj.url),true);obj.usedBytes=obj.contents.length}catch(e){throw new FS.ErrnoError(29)}}else{throw new Error("Cannot load without read() or XMLHttpRequest.")}},createLazyFile:(parent,name,url,canRead,canWrite)=>{function LazyUint8Array(){this.lengthKnown=false;this.chunks=[]}LazyUint8Array.prototype.get=function LazyUint8Array_get(idx){if(idx>this.length-1||idx<0){return undefined}var chunkOffset=idx%this.chunkSize;var chunkNum=idx/this.chunkSize|0;return this.getter(chunkNum)[chunkOffset]};LazyUint8Array.prototype.setDataGetter=function LazyUint8Array_setDataGetter(getter){this.getter=getter};LazyUint8Array.prototype.cacheLength=function LazyUint8Array_cacheLength(){var xhr=new XMLHttpRequest;xhr.open("HEAD",url,false);xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);var datalength=Number(xhr.getResponseHeader("Content-length"));var header;var hasByteServing=(header=xhr.getResponseHeader("Accept-Ranges"))&&header==="bytes";var usesGzip=(header=xhr.getResponseHeader("Content-Encoding"))&&header==="gzip";var chunkSize=1024*1024;if(!hasByteServing)chunkSize=datalength;var doXHR=(from,to)=>{if(from>to)throw new Error("invalid range ("+from+", "+to+") or no bytes requested!");if(to>datalength-1)throw new Error("only "+datalength+" bytes available! programmer error!");var xhr=new XMLHttpRequest;xhr.open("GET",url,false);if(datalength!==chunkSize)xhr.setRequestHeader("Range","bytes="+from+"-"+to);xhr.responseType="arraybuffer";if(xhr.overrideMimeType){xhr.overrideMimeType("text/plain; charset=x-user-defined")}xhr.send(null);if(!(xhr.status>=200&&xhr.status<300||xhr.status===304))throw new Error("Couldn't load "+url+". Status: "+xhr.status);if(xhr.response!==undefined){return new Uint8Array(xhr.response||[])}else{return intArrayFromString(xhr.responseText||"",true)}};var lazyArray=this;lazyArray.setDataGetter(chunkNum=>{var start=chunkNum*chunkSize;var end=(chunkNum+1)*chunkSize-1;end=Math.min(end,datalength-1);if(typeof lazyArray.chunks[chunkNum]=="undefined"){lazyArray.chunks[chunkNum]=doXHR(start,end)}if(typeof lazyArray.chunks[chunkNum]=="undefined")throw new Error("doXHR failed!");return lazyArray.chunks[chunkNum]});if(usesGzip||!datalength){chunkSize=datalength=1;datalength=this.getter(0).length;chunkSize=datalength;out("LazyFiles on gzip forces download of the whole file when length is accessed")}this._length=datalength;this._chunkSize=chunkSize;this.lengthKnown=true};if(typeof XMLHttpRequest!="undefined"){if(!ENVIRONMENT_IS_WORKER)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var lazyArray=new LazyUint8Array;Object.defineProperties(lazyArray,{length:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._length}},chunkSize:{get:function(){if(!this.lengthKnown){this.cacheLength()}return this._chunkSize}}});var properties={isDevice:false,contents:lazyArray}}else{var properties={isDevice:false,url:url}}var node=FS.createFile(parent,name,properties,canRead,canWrite);if(properties.contents){node.contents=properties.contents}else if(properties.url){node.contents=null;node.url=properties.url}Object.defineProperties(node,{usedBytes:{get:function(){return this.contents.length}}});var stream_ops={};var keys=Object.keys(node.stream_ops);keys.forEach(key=>{var fn=node.stream_ops[key];stream_ops[key]=function forceLoadLazyFile(){FS.forceLoadFile(node);return fn.apply(null,arguments)}});stream_ops.read=((stream,buffer,offset,length,position)=>{FS.forceLoadFile(node);var contents=stream.node.contents;if(position>=contents.length)return 0;var size=Math.min(contents.length-position,length);if(contents.slice){for(var i=0;i<size;i++){buffer[offset+i]=contents[position+i]}}else{for(var i=0;i<size;i++){buffer[offset+i]=contents.get(position+i)}}return size});node.stream_ops=stream_ops;return node},createPreloadedFile:(parent,name,url,canRead,canWrite,onload,onerror,dontCreateFile,canOwn,preFinish)=>{var fullname=name?PATH_FS.resolve(PATH.join2(parent,name)):parent;var dep=getUniqueRunDependency("cp "+fullname);function processData(byteArray){function finish(byteArray){if(preFinish)preFinish();if(!dontCreateFile){FS.createDataFile(parent,name,byteArray,canRead,canWrite,canOwn)}if(onload)onload();removeRunDependency(dep)}if(Browser.handledByPreloadPlugin(byteArray,fullname,finish,()=>{if(onerror)onerror();removeRunDependency(dep)})){return}finish(byteArray)}addRunDependency(dep);if(typeof url=="string"){asyncLoad(url,byteArray=>processData(byteArray),onerror)}else{processData(url)}},indexedDB:()=>{return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:()=>{return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=(()=>{out("creating db");var db=openRequest.result;db.createObjectStore(FS.DB_STORE_NAME)});openRequest.onsuccess=(()=>{var db=openRequest.result;var transaction=db.transaction([FS.DB_STORE_NAME],"readwrite");var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var putRequest=files.put(FS.analyzePath(path).object.contents,path);putRequest.onsuccess=(()=>{ok++;if(ok+fail==total)finish()});putRequest.onerror=(()=>{fail++;if(ok+fail==total)finish()})});transaction.onerror=onerror});openRequest.onerror=onerror},loadFilesFromDB:(paths,onload,onerror)=>{onload=onload||(()=>{});onerror=onerror||(()=>{});var indexedDB=FS.indexedDB();try{var openRequest=indexedDB.open(FS.DB_NAME(),FS.DB_VERSION)}catch(e){return onerror(e)}openRequest.onupgradeneeded=onerror;openRequest.onsuccess=(()=>{var db=openRequest.result;try{var transaction=db.transaction([FS.DB_STORE_NAME],"readonly")}catch(e){onerror(e);return}var files=transaction.objectStore(FS.DB_STORE_NAME);var ok=0,fail=0,total=paths.length;function finish(){if(fail==0)onload();else onerror()}paths.forEach(path=>{var getRequest=files.get(path);getRequest.onsuccess=(()=>{if(FS.analyzePath(path).exists){FS.unlink(path)}FS.createDataFile(PATH.dirname(path),PATH.basename(path),getRequest.result,true,true,true);ok++;if(ok+fail==total)finish()});getRequest.onerror=(()=>{fail++;if(ok+fail==total)finish()})});transaction.onerror=onerror});openRequest.onerror=onerror}};var SYSCALLS={DEFAULT_POLLMASK:5,calculateAt:function(dirfd,path,allowEmpty){if(path[0]==="/"){return path}var dir;if(dirfd===-100){dir=FS.cwd()}else{var dirstream=FS.getStream(dirfd);if(!dirstream)throw new FS.ErrnoError(8);dir=dirstream.path}if(path.length==0){if(!allowEmpty){throw new FS.ErrnoError(44)}return dir}return PATH.join2(dir,path)},doStat:function(func,path,buf){try{var stat=func(path)}catch(e){if(e&&e.node&&PATH.normalize(path)!==PATH.normalize(FS.getPath(e.node))){return-54}throw e}HEAP32[buf>>2]=stat.dev;HEAP32[buf+4>>2]=0;HEAP32[buf+8>>2]=stat.ino;HEAP32[buf+12>>2]=stat.mode;HEAP32[buf+16>>2]=stat.nlink;HEAP32[buf+20>>2]=stat.uid;HEAP32[buf+24>>2]=stat.gid;HEAP32[buf+28>>2]=stat.rdev;HEAP32[buf+32>>2]=0;tempI64=[stat.size>>>0,(tempDouble=stat.size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+40>>2]=tempI64[0],HEAP32[buf+44>>2]=tempI64[1];HEAP32[buf+48>>2]=4096;HEAP32[buf+52>>2]=stat.blocks;HEAP32[buf+56>>2]=stat.atime.getTime()/1e3|0;HEAP32[buf+60>>2]=0;HEAP32[buf+64>>2]=stat.mtime.getTime()/1e3|0;HEAP32[buf+68>>2]=0;HEAP32[buf+72>>2]=stat.ctime.getTime()/1e3|0;HEAP32[buf+76>>2]=0;tempI64=[stat.ino>>>0,(tempDouble=stat.ino,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[buf+80>>2]=tempI64[0],HEAP32[buf+84>>2]=tempI64[1];return 0},doMsync:function(addr,stream,len,flags,offset){var buffer=HEAPU8.slice(addr,addr+len);FS.msync(stream,buffer,offset,len,flags)},doMkdir:function(path,mode){path=PATH.normalize(path);if(path[path.length-1]==="/")path=path.substr(0,path.length-1);FS.mkdir(path,mode,0);return 0},doMknod:function(path,mode,dev){switch(mode&61440){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}FS.mknod(path,mode,dev);return 0},doReadlink:function(path,buf,bufsize){if(bufsize<=0)return-28;var ret=FS.readlink(path);var len=Math.min(bufsize,lengthBytesUTF8(ret));var endChar=HEAP8[buf+len];stringToUTF8(ret,buf,bufsize+1);HEAP8[buf+len]=endChar;return len},doAccess:function(path,amode){if(amode&~7){return-28}var lookup=FS.lookupPath(path,{follow:true});var node=lookup.node;if(!node){return-44}var perms="";if(amode&4)perms+="r";if(amode&2)perms+="w";if(amode&1)perms+="x";if(perms&&FS.nodePermissions(node,perms)){return-2}return 0},doReadv:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.read(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr;if(curr<len)break}return ret},doWritev:function(stream,iov,iovcnt,offset){var ret=0;for(var i=0;i<iovcnt;i++){var ptr=HEAP32[iov+i*8>>2];var len=HEAP32[iov+(i*8+4)>>2];var curr=FS.write(stream,HEAP8,ptr,len,offset);if(curr<0)return-1;ret+=curr}return ret},varargs:undefined,get:function(){SYSCALLS.varargs+=4;var ret=HEAP32[SYSCALLS.varargs-4>>2];return ret},getStr:function(ptr){var ret=UTF8ToString(ptr);return ret},getStreamFromFD:function(fd){var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);return stream},get64:function(low,high){return low}};function ___syscall__newselect(nfds,readfds,writefds,exceptfds,timeout){try{var total=0;var srcReadLow=readfds?HEAP32[readfds>>2]:0,srcReadHigh=readfds?HEAP32[readfds+4>>2]:0;var srcWriteLow=writefds?HEAP32[writefds>>2]:0,srcWriteHigh=writefds?HEAP32[writefds+4>>2]:0;var srcExceptLow=exceptfds?HEAP32[exceptfds>>2]:0,srcExceptHigh=exceptfds?HEAP32[exceptfds+4>>2]:0;var dstReadLow=0,dstReadHigh=0;var dstWriteLow=0,dstWriteHigh=0;var dstExceptLow=0,dstExceptHigh=0;var allLow=(readfds?HEAP32[readfds>>2]:0)|(writefds?HEAP32[writefds>>2]:0)|(exceptfds?HEAP32[exceptfds>>2]:0);var allHigh=(readfds?HEAP32[readfds+4>>2]:0)|(writefds?HEAP32[writefds+4>>2]:0)|(exceptfds?HEAP32[exceptfds+4>>2]:0);var check=function(fd,low,high,val){return fd<32?low&val:high&val};for(var fd=0;fd<nfds;fd++){var mask=1<<fd%32;if(!check(fd,allLow,allHigh,mask)){continue}var stream=FS.getStream(fd);if(!stream)throw new FS.ErrnoError(8);var flags=SYSCALLS.DEFAULT_POLLMASK;if(stream.stream_ops.poll){flags=stream.stream_ops.poll(stream)}if(flags&1&&check(fd,srcReadLow,srcReadHigh,mask)){fd<32?dstReadLow=dstReadLow|mask:dstReadHigh=dstReadHigh|mask;total++}if(flags&4&&check(fd,srcWriteLow,srcWriteHigh,mask)){fd<32?dstWriteLow=dstWriteLow|mask:dstWriteHigh=dstWriteHigh|mask;total++}if(flags&2&&check(fd,srcExceptLow,srcExceptHigh,mask)){fd<32?dstExceptLow=dstExceptLow|mask:dstExceptHigh=dstExceptHigh|mask;total++}}if(readfds){HEAP32[readfds>>2]=dstReadLow;HEAP32[readfds+4>>2]=dstReadHigh}if(writefds){HEAP32[writefds>>2]=dstWriteLow;HEAP32[writefds+4>>2]=dstWriteHigh}if(exceptfds){HEAP32[exceptfds>>2]=dstExceptLow;HEAP32[exceptfds+4>>2]=dstExceptHigh}return total}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}var SOCKFS={mount:function(mount){Module["websocket"]=Module["websocket"]&&"object"===typeof Module["websocket"]?Module["websocket"]:{};Module["websocket"]._callbacks={};Module["websocket"]["on"]=function(event,callback){if("function"===typeof callback){this._callbacks[event]=callback}return this};Module["websocket"].emit=function(event,param){if("function"===typeof this._callbacks[event]){this._callbacks[event].call(this,param)}};return FS.createNode(null,"/",16384|511,0)},createSocket:function(family,type,protocol){type&=~526336;var streaming=type==1;if(streaming&&protocol&&protocol!=6){throw new FS.ErrnoError(66)}var sock={family:family,type:type,protocol:protocol,server:null,error:null,peers:{},pending:[],recv_queue:[],sock_ops:SOCKFS.websocket_sock_ops};var name=SOCKFS.nextname();var node=FS.createNode(SOCKFS.root,name,49152,0);node.sock=sock;var stream=FS.createStream({path:name,node:node,flags:2,seekable:false,stream_ops:SOCKFS.stream_ops});sock.stream=stream;return sock},getSocket:function(fd){var stream=FS.getStream(fd);if(!stream||!FS.isSocket(stream.node.mode)){return null}return stream.node.sock},stream_ops:{poll:function(stream){var sock=stream.node.sock;return sock.sock_ops.poll(sock)},ioctl:function(stream,request,varargs){var sock=stream.node.sock;return sock.sock_ops.ioctl(sock,request,varargs)},read:function(stream,buffer,offset,length,position){var sock=stream.node.sock;var msg=sock.sock_ops.recvmsg(sock,length);if(!msg){return 0}buffer.set(msg.buffer,offset);return msg.buffer.length},write:function(stream,buffer,offset,length,position){var sock=stream.node.sock;return sock.sock_ops.sendmsg(sock,buffer,offset,length)},close:function(stream){var sock=stream.node.sock;sock.sock_ops.close(sock)}},nextname:function(){if(!SOCKFS.nextname.current){SOCKFS.nextname.current=0}return"socket["+SOCKFS.nextname.current+++"]"},websocket_sock_ops:{createPeer:function(sock,addr,port){var ws;if(typeof addr=="object"){ws=addr;addr=null;port=null}if(ws){if(ws._socket){addr=ws._socket.remoteAddress;port=ws._socket.remotePort}else{var result=/ws[s]?:\/\/([^:]+):(\d+)/.exec(ws.url);if(!result){throw new Error("WebSocket URL must be in the format ws(s)://address:port")}addr=result[1];port=parseInt(result[2],10)}}else{try{var runtimeConfig=Module["websocket"]&&"object"===typeof Module["websocket"];var url="ws:#".replace("#","//");if(runtimeConfig){if("string"===typeof Module["websocket"]["url"]){url=Module["websocket"]["url"]}}if(url==="ws://"||url==="wss://"){var parts=addr.split("/");url=url+parts[0]+":"+port+"/"+parts.slice(1).join("/")}var subProtocols="binary";if(runtimeConfig){if("string"===typeof Module["websocket"]["subprotocol"]){subProtocols=Module["websocket"]["subprotocol"]}}var opts=undefined;if(subProtocols!=="null"){subProtocols=subProtocols.replace(/^ +| +$/g,"").split(/ *, */);opts=ENVIRONMENT_IS_NODE?{"protocol":subProtocols.toString()}:subProtocols}if(runtimeConfig&&null===Module["websocket"]["subprotocol"]){subProtocols="null";opts=undefined}var WebSocketConstructor;if(ENVIRONMENT_IS_NODE){WebSocketConstructor=require("ws")}else{WebSocketConstructor=WebSocket}ws=new WebSocketConstructor(url,opts);ws.binaryType="arraybuffer"}catch(e){throw new FS.ErrnoError(23)}}var peer={addr:addr,port:port,socket:ws,dgram_send_queue:[]};SOCKFS.websocket_sock_ops.addPeer(sock,peer);SOCKFS.websocket_sock_ops.handlePeerEvents(sock,peer);if(sock.type===2&&typeof sock.sport!="undefined"){peer.dgram_send_queue.push(new Uint8Array([255,255,255,255,"p".charCodeAt(0),"o".charCodeAt(0),"r".charCodeAt(0),"t".charCodeAt(0),(sock.sport&65280)>>8,sock.sport&255]))}return peer},getPeer:function(sock,addr,port){return sock.peers[addr+":"+port]},addPeer:function(sock,peer){sock.peers[peer.addr+":"+peer.port]=peer},removePeer:function(sock,peer){delete sock.peers[peer.addr+":"+peer.port]},handlePeerEvents:function(sock,peer){var first=true;var handleOpen=function(){Module["websocket"].emit("open",sock.stream.fd);try{var queued=peer.dgram_send_queue.shift();while(queued){peer.socket.send(queued);queued=peer.dgram_send_queue.shift()}}catch(e){peer.socket.close()}};function handleMessage(data){if(typeof data=="string"){var encoder=new TextEncoder;data=encoder.encode(data)}else{assert(data.byteLength!==undefined);if(data.byteLength==0){return}else{data=new Uint8Array(data)}}var wasfirst=first;first=false;if(wasfirst&&data.length===10&&data[0]===255&&data[1]===255&&data[2]===255&&data[3]===255&&data[4]==="p".charCodeAt(0)&&data[5]==="o".charCodeAt(0)&&data[6]==="r".charCodeAt(0)&&data[7]==="t".charCodeAt(0)){var newport=data[8]<<8|data[9];SOCKFS.websocket_sock_ops.removePeer(sock,peer);peer.port=newport;SOCKFS.websocket_sock_ops.addPeer(sock,peer);return}sock.recv_queue.push({addr:peer.addr,port:peer.port,data:data});Module["websocket"].emit("message",sock.stream.fd)}if(ENVIRONMENT_IS_NODE){peer.socket.on("open",handleOpen);peer.socket.on("message",function(data,flags){if(!flags.binary){return}handleMessage(new Uint8Array(data).buffer)});peer.socket.on("close",function(){Module["websocket"].emit("close",sock.stream.fd)});peer.socket.on("error",function(error){sock.error=14;Module["websocket"].emit("error",[sock.stream.fd,sock.error,"ECONNREFUSED: Connection refused"])})}else{peer.socket.onopen=handleOpen;peer.socket.onclose=function(){Module["websocket"].emit("close",sock.stream.fd)};peer.socket.onmessage=function peer_socket_onmessage(event){handleMessage(event.data)};peer.socket.onerror=function(error){sock.error=14;Module["websocket"].emit("error",[sock.stream.fd,sock.error,"ECONNREFUSED: Connection refused"])}}},poll:function(sock){if(sock.type===1&&sock.server){return sock.pending.length?64|1:0}var mask=0;var dest=sock.type===1?SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport):null;if(sock.recv_queue.length||!dest||dest&&dest.socket.readyState===dest.socket.CLOSING||dest&&dest.socket.readyState===dest.socket.CLOSED){mask|=64|1}if(!dest||dest&&dest.socket.readyState===dest.socket.OPEN){mask|=4}if(dest&&dest.socket.readyState===dest.socket.CLOSING||dest&&dest.socket.readyState===dest.socket.CLOSED){mask|=16}return mask},ioctl:function(sock,request,arg){switch(request){case 21531:var bytes=0;if(sock.recv_queue.length){bytes=sock.recv_queue[0].data.length}HEAP32[arg>>2]=bytes;return 0;default:return 28}},close:function(sock){if(sock.server){try{sock.server.close()}catch(e){}sock.server=null}var peers=Object.keys(sock.peers);for(var i=0;i<peers.length;i++){var peer=sock.peers[peers[i]];try{peer.socket.close()}catch(e){}SOCKFS.websocket_sock_ops.removePeer(sock,peer)}return 0},bind:function(sock,addr,port){if(typeof sock.saddr!="undefined"||typeof sock.sport!="undefined"){throw new FS.ErrnoError(28)}sock.saddr=addr;sock.sport=port;if(sock.type===2){if(sock.server){sock.server.close();sock.server=null}try{sock.sock_ops.listen(sock,0)}catch(e){if(!(e instanceof FS.ErrnoError))throw e;if(e.errno!==138)throw e}}},connect:function(sock,addr,port){if(sock.server){throw new FS.ErrnoError(138)}if(typeof sock.daddr!="undefined"&&typeof sock.dport!="undefined"){var dest=SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport);if(dest){if(dest.socket.readyState===dest.socket.CONNECTING){throw new FS.ErrnoError(7)}else{throw new FS.ErrnoError(30)}}}var peer=SOCKFS.websocket_sock_ops.createPeer(sock,addr,port);sock.daddr=peer.addr;sock.dport=peer.port;throw new FS.ErrnoError(26)},listen:function(sock,backlog){if(!ENVIRONMENT_IS_NODE){throw new FS.ErrnoError(138)}if(sock.server){throw new FS.ErrnoError(28)}var WebSocketServer=require("ws").Server;var host=sock.saddr;sock.server=new WebSocketServer({host:host,port:sock.sport});Module["websocket"].emit("listen",sock.stream.fd);sock.server.on("connection",function(ws){if(sock.type===1){var newsock=SOCKFS.createSocket(sock.family,sock.type,sock.protocol);var peer=SOCKFS.websocket_sock_ops.createPeer(newsock,ws);newsock.daddr=peer.addr;newsock.dport=peer.port;sock.pending.push(newsock);Module["websocket"].emit("connection",newsock.stream.fd)}else{SOCKFS.websocket_sock_ops.createPeer(sock,ws);Module["websocket"].emit("connection",sock.stream.fd)}});sock.server.on("closed",function(){Module["websocket"].emit("close",sock.stream.fd);sock.server=null});sock.server.on("error",function(error){sock.error=23;Module["websocket"].emit("error",[sock.stream.fd,sock.error,"EHOSTUNREACH: Host is unreachable"])})},accept:function(listensock){if(!listensock.server||!listensock.pending.length){throw new FS.ErrnoError(28)}var newsock=listensock.pending.shift();newsock.stream.flags=listensock.stream.flags;return newsock},getname:function(sock,peer){var addr,port;if(peer){if(sock.daddr===undefined||sock.dport===undefined){throw new FS.ErrnoError(53)}addr=sock.daddr;port=sock.dport}else{addr=sock.saddr||0;port=sock.sport||0}return{addr:addr,port:port}},sendmsg:function(sock,buffer,offset,length,addr,port){if(sock.type===2){if(addr===undefined||port===undefined){addr=sock.daddr;port=sock.dport}if(addr===undefined||port===undefined){throw new FS.ErrnoError(17)}}else{addr=sock.daddr;port=sock.dport}var dest=SOCKFS.websocket_sock_ops.getPeer(sock,addr,port);if(sock.type===1){if(!dest||dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){throw new FS.ErrnoError(53)}else if(dest.socket.readyState===dest.socket.CONNECTING){throw new FS.ErrnoError(6)}}if(ArrayBuffer.isView(buffer)){offset+=buffer.byteOffset;buffer=buffer.buffer}var data;data=buffer.slice(offset,offset+length);if(sock.type===2){if(!dest||dest.socket.readyState!==dest.socket.OPEN){if(!dest||dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){dest=SOCKFS.websocket_sock_ops.createPeer(sock,addr,port)}dest.dgram_send_queue.push(data);return length}}try{dest.socket.send(data);return length}catch(e){throw new FS.ErrnoError(28)}},recvmsg:function(sock,length){if(sock.type===1&&sock.server){throw new FS.ErrnoError(53)}var queued=sock.recv_queue.shift();if(!queued){if(sock.type===1){var dest=SOCKFS.websocket_sock_ops.getPeer(sock,sock.daddr,sock.dport);if(!dest){throw new FS.ErrnoError(53)}else if(dest.socket.readyState===dest.socket.CLOSING||dest.socket.readyState===dest.socket.CLOSED){return null}else{throw new FS.ErrnoError(6)}}else{throw new FS.ErrnoError(6)}}var queuedLength=queued.data.byteLength||queued.data.length;var queuedOffset=queued.data.byteOffset||0;var queuedBuffer=queued.data.buffer||queued.data;var bytesRead=Math.min(length,queuedLength);var res={buffer:new Uint8Array(queuedBuffer,queuedOffset,bytesRead),addr:queued.addr,port:queued.port};if(sock.type===1&&bytesRead<queuedLength){var bytesRemaining=queuedLength-bytesRead;queued.data=new Uint8Array(queuedBuffer,queuedOffset+bytesRead,bytesRemaining);sock.recv_queue.unshift(queued)}return res}}};function getSocketFromFD(fd){var socket=SOCKFS.getSocket(fd);if(!socket)throw new FS.ErrnoError(8);return socket}function setErrNo(value){HEAP32[___errno_location()>>2]=value;return value}function inetPton4(str){var b=str.split(".");for(var i=0;i<4;i++){var tmp=Number(b[i]);if(isNaN(tmp))return null;b[i]=tmp}return(b[0]|b[1]<<8|b[2]<<16|b[3]<<24)>>>0}function jstoi_q(str){return parseInt(str)}function inetPton6(str){var words;var w,offset,z;var valid6regx=/^((?=.*::)(?!.*::.+::)(::)?([\dA-F]{1,4}:(:|\b)|){5}|([\dA-F]{1,4}:){6})((([\dA-F]{1,4}((?!\3)::|:\b|$))|(?!\2\3)){2}|(((2[0-4]|1\d|[1-9])?\d|25[0-5])\.?\b){4})$/i;var parts=[];if(!valid6regx.test(str)){return null}if(str==="::"){return[0,0,0,0,0,0,0,0]}if(str.startsWith("::")){str=str.replace("::","Z:")}else{str=str.replace("::",":Z:")}if(str.indexOf(".")>0){str=str.replace(new RegExp("[.]","g"),":");words=str.split(":");words[words.length-4]=jstoi_q(words[words.length-4])+jstoi_q(words[words.length-3])*256;words[words.length-3]=jstoi_q(words[words.length-2])+jstoi_q(words[words.length-1])*256;words=words.slice(0,words.length-2)}else{words=str.split(":")}offset=0;z=0;for(w=0;w<words.length;w++){if(typeof words[w]=="string"){if(words[w]==="Z"){for(z=0;z<8-words.length+1;z++){parts[w+z]=0}offset=z-1}else{parts[w+offset]=_htons(parseInt(words[w],16))}}else{parts[w+offset]=words[w]}}return[parts[1]<<16|parts[0],parts[3]<<16|parts[2],parts[5]<<16|parts[4],parts[7]<<16|parts[6]]}function writeSockaddr(sa,family,addr,port,addrlen){switch(family){case 2:addr=inetPton4(addr);zeroMemory(sa,16);if(addrlen){HEAP32[addrlen>>2]=16}HEAP16[sa>>1]=family;HEAP32[sa+4>>2]=addr;HEAP16[sa+2>>1]=_htons(port);break;case 10:addr=inetPton6(addr);zeroMemory(sa,28);if(addrlen){HEAP32[addrlen>>2]=28}HEAP32[sa>>2]=family;HEAP32[sa+8>>2]=addr[0];HEAP32[sa+12>>2]=addr[1];HEAP32[sa+16>>2]=addr[2];HEAP32[sa+20>>2]=addr[3];HEAP16[sa+2>>1]=_htons(port);break;default:return 5}return 0}var DNS={address_map:{id:1,addrs:{},names:{}},lookup_name:function(name){var res=inetPton4(name);if(res!==null){return name}res=inetPton6(name);if(res!==null){return name}var addr;if(DNS.address_map.addrs[name]){addr=DNS.address_map.addrs[name]}else{var id=DNS.address_map.id++;assert(id<65535,"exceeded max address mappings of 65535");addr="172.29."+(id&255)+"."+(id&65280);DNS.address_map.names[addr]=name;DNS.address_map.addrs[name]=addr}return addr},lookup_addr:function(addr){if(DNS.address_map.names[addr]){return DNS.address_map.names[addr]}return null}};function ___syscall_accept4(fd,addr,addrlen,flags){try{var sock=getSocketFromFD(fd);var newsock=sock.sock_ops.accept(sock);if(addr){var errno=writeSockaddr(addr,newsock.family,DNS.lookup_name(newsock.daddr),newsock.dport,addrlen)}return newsock.stream.fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function inetNtop4(addr){return(addr&255)+"."+(addr>>8&255)+"."+(addr>>16&255)+"."+(addr>>24&255)}function inetNtop6(ints){var str="";var word=0;var longest=0;var lastzero=0;var zstart=0;var len=0;var i=0;var parts=[ints[0]&65535,ints[0]>>16,ints[1]&65535,ints[1]>>16,ints[2]&65535,ints[2]>>16,ints[3]&65535,ints[3]>>16];var hasipv4=true;var v4part="";for(i=0;i<5;i++){if(parts[i]!==0){hasipv4=false;break}}if(hasipv4){v4part=inetNtop4(parts[6]|parts[7]<<16);if(parts[5]===-1){str="::ffff:";str+=v4part;return str}if(parts[5]===0){str="::";if(v4part==="0.0.0.0")v4part="";if(v4part==="0.0.0.1")v4part="1";str+=v4part;return str}}for(word=0;word<8;word++){if(parts[word]===0){if(word-lastzero>1){len=0}lastzero=word;len++}if(len>longest){longest=len;zstart=word-longest+1}}for(word=0;word<8;word++){if(longest>1){if(parts[word]===0&&word>=zstart&&word<zstart+longest){if(word===zstart){str+=":";if(zstart===0)str+=":"}continue}}str+=Number(_ntohs(parts[word]&65535)).toString(16);str+=word<7?":":""}return str}function readSockaddr(sa,salen){var family=HEAP16[sa>>1];var port=_ntohs(HEAPU16[sa+2>>1]);var addr;switch(family){case 2:if(salen!==16){return{errno:28}}addr=HEAP32[sa+4>>2];addr=inetNtop4(addr);break;case 10:if(salen!==28){return{errno:28}}addr=[HEAP32[sa+8>>2],HEAP32[sa+12>>2],HEAP32[sa+16>>2],HEAP32[sa+20>>2]];addr=inetNtop6(addr);break;default:return{errno:5}}return{family:family,addr:addr,port:port}}function getSocketAddress(addrp,addrlen,allowNull){if(allowNull&&addrp===0)return null;var info=readSockaddr(addrp,addrlen);if(info.errno)throw new FS.ErrnoError(info.errno);info.addr=DNS.lookup_addr(info.addr)||info.addr;return info}function ___syscall_bind(fd,addr,addrlen){try{var sock=getSocketFromFD(fd);var info=getSocketAddress(addr,addrlen);sock.sock_ops.bind(sock,info.addr,info.port);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_chmod(path,mode){try{path=SYSCALLS.getStr(path);FS.chmod(path,mode);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_connect(fd,addr,addrlen){try{var sock=getSocketFromFD(fd);var info=getSocketAddress(addr,addrlen);sock.sock_ops.connect(sock,info.addr,info.port);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_dup3(fd,suggestFD,flags){try{var old=SYSCALLS.getStreamFromFD(fd);if(old.fd===suggestFD)return-28;var suggest=FS.getStream(suggestFD);if(suggest)FS.close(suggest);return FS.open(old.path,old.flags,0,suggestFD,suggestFD).fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_faccessat(dirfd,path,amode,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);return SYSCALLS.doAccess(path,amode)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_fcntl64(fd,cmd,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(cmd){case 0:{var arg=SYSCALLS.get();if(arg<0){return-28}var newStream;newStream=FS.open(stream.path,stream.flags,0,arg);return newStream.fd}case 1:case 2:return 0;case 3:return stream.flags;case 4:{var arg=SYSCALLS.get();stream.flags|=arg;return 0}case 5:{var arg=SYSCALLS.get();var offset=0;HEAP16[arg+offset>>1]=2;return 0}case 6:case 7:return 0;case 16:case 8:return-28;case 9:setErrNo(28);return-1;default:{return-28}}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_fstat64(fd,buf){try{var stream=SYSCALLS.getStreamFromFD(fd);return SYSCALLS.doStat(FS.stat,stream.path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_ftruncate64(fd,low,high){try{var length=SYSCALLS.get64(low,high);FS.ftruncate(fd,length);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getcwd(buf,size){try{if(size===0)return-28;var cwd=FS.cwd();var cwdLengthInBytes=lengthBytesUTF8(cwd);if(size<cwdLengthInBytes+1)return-68;stringToUTF8(cwd,buf,size);return buf}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getdents64(fd,dirp,count){try{var stream=SYSCALLS.getStreamFromFD(fd);if(!stream.getdents){stream.getdents=FS.readdir(stream.path)}var struct_size=280;var pos=0;var off=FS.llseek(stream,0,1);var idx=Math.floor(off/struct_size);while(idx<stream.getdents.length&&pos+struct_size<=count){var id;var type;var name=stream.getdents[idx];if(name==="."){id=stream.node.id;type=4}else if(name===".."){var lookup=FS.lookupPath(stream.path,{parent:true});id=lookup.node.id;type=4}else{var child=FS.lookupNode(stream.node,name);id=child.id;type=FS.isChrdev(child.mode)?2:FS.isDir(child.mode)?4:FS.isLink(child.mode)?10:8}tempI64=[id>>>0,(tempDouble=id,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos>>2]=tempI64[0],HEAP32[dirp+pos+4>>2]=tempI64[1];tempI64=[(idx+1)*struct_size>>>0,(tempDouble=(idx+1)*struct_size,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[dirp+pos+8>>2]=tempI64[0],HEAP32[dirp+pos+12>>2]=tempI64[1];HEAP16[dirp+pos+16>>1]=280;HEAP8[dirp+pos+18>>0]=type;stringToUTF8(name,dirp+pos+19,256);pos+=struct_size;idx+=1}FS.llseek(stream,idx*struct_size,0);return pos}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getpeername(fd,addr,addrlen){try{var sock=getSocketFromFD(fd);if(!sock.daddr){return-53}var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(sock.daddr),sock.dport,addrlen);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getsockname(fd,addr,addrlen){try{err("__syscall_getsockname "+fd);var sock=getSocketFromFD(fd);var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(sock.saddr||"0.0.0.0"),sock.sport,addrlen);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_getsockopt(fd,level,optname,optval,optlen){try{var sock=getSocketFromFD(fd);if(level===1){if(optname===4){HEAP32[optval>>2]=sock.error;HEAP32[optlen>>2]=4;sock.error=null;return 0}}return-50}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_ioctl(fd,op,varargs){SYSCALLS.varargs=varargs;try{var stream=SYSCALLS.getStreamFromFD(fd);switch(op){case 21509:case 21505:{if(!stream.tty)return-59;return 0}case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:{if(!stream.tty)return-59;return 0}case 21519:{if(!stream.tty)return-59;var argp=SYSCALLS.get();HEAP32[argp>>2]=0;return 0}case 21520:{if(!stream.tty)return-59;return-28}case 21531:{var argp=SYSCALLS.get();return FS.ioctl(stream,op,argp)}case 21523:{if(!stream.tty)return-59;return 0}case 21524:{if(!stream.tty)return-59;return 0}default:abort("bad ioctl syscall "+op)}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_listen(fd,backlog){try{var sock=getSocketFromFD(fd);sock.sock_ops.listen(sock,backlog);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_lstat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.lstat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_mkdir(path,mode){try{path=SYSCALLS.getStr(path);return SYSCALLS.doMkdir(path,mode)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_newfstatat(dirfd,path,buf,flags){try{path=SYSCALLS.getStr(path);var nofollow=flags&256;var allowEmpty=flags&4096;flags=flags&~4352;path=SYSCALLS.calculateAt(dirfd,path,allowEmpty);return SYSCALLS.doStat(nofollow?FS.lstat:FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_openat(dirfd,path,flags,varargs){SYSCALLS.varargs=varargs;try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);var mode=varargs?SYSCALLS.get():0;return FS.open(path,flags,mode).fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}var PIPEFS={BUCKET_BUFFER_SIZE:8192,mount:function(mount){return FS.createNode(null,"/",16384|511,0)},createPipe:function(){var pipe={buckets:[],refcnt:2};pipe.buckets.push({buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0});var rName=PIPEFS.nextname();var wName=PIPEFS.nextname();var rNode=FS.createNode(PIPEFS.root,rName,4096,0);var wNode=FS.createNode(PIPEFS.root,wName,4096,0);rNode.pipe=pipe;wNode.pipe=pipe;var readableStream=FS.createStream({path:rName,node:rNode,flags:0,seekable:false,stream_ops:PIPEFS.stream_ops});rNode.stream=readableStream;var writableStream=FS.createStream({path:wName,node:wNode,flags:1,seekable:false,stream_ops:PIPEFS.stream_ops});wNode.stream=writableStream;return{readable_fd:readableStream.fd,writable_fd:writableStream.fd}},stream_ops:{poll:function(stream){var pipe=stream.node.pipe;if((stream.flags&2097155)===1){return 256|4}else{if(pipe.buckets.length>0){for(var i=0;i<pipe.buckets.length;i++){var bucket=pipe.buckets[i];if(bucket.offset-bucket.roffset>0){return 64|1}}}}return 0},ioctl:function(stream,request,varargs){return 28},fsync:function(stream){return 28},read:function(stream,buffer,offset,length,position){var pipe=stream.node.pipe;var currentLength=0;for(var i=0;i<pipe.buckets.length;i++){var bucket=pipe.buckets[i];currentLength+=bucket.offset-bucket.roffset}assert(buffer instanceof ArrayBuffer||ArrayBuffer.isView(buffer));var data=buffer.subarray(offset,offset+length);if(length<=0){return 0}if(currentLength==0){throw new FS.ErrnoError(6)}var toRead=Math.min(currentLength,length);var totalRead=toRead;var toRemove=0;for(var i=0;i<pipe.buckets.length;i++){var currBucket=pipe.buckets[i];var bucketSize=currBucket.offset-currBucket.roffset;if(toRead<=bucketSize){var tmpSlice=currBucket.buffer.subarray(currBucket.roffset,currBucket.offset);if(toRead<bucketSize){tmpSlice=tmpSlice.subarray(0,toRead);currBucket.roffset+=toRead}else{toRemove++}data.set(tmpSlice);break}else{var tmpSlice=currBucket.buffer.subarray(currBucket.roffset,currBucket.offset);data.set(tmpSlice);data=data.subarray(tmpSlice.byteLength);toRead-=tmpSlice.byteLength;toRemove++}}if(toRemove&&toRemove==pipe.buckets.length){toRemove--;pipe.buckets[toRemove].offset=0;pipe.buckets[toRemove].roffset=0}pipe.buckets.splice(0,toRemove);return totalRead},write:function(stream,buffer,offset,length,position){var pipe=stream.node.pipe;assert(buffer instanceof ArrayBuffer||ArrayBuffer.isView(buffer));var data=buffer.subarray(offset,offset+length);var dataLen=data.byteLength;if(dataLen<=0){return 0}var currBucket=null;if(pipe.buckets.length==0){currBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:0,roffset:0};pipe.buckets.push(currBucket)}else{currBucket=pipe.buckets[pipe.buckets.length-1]}assert(currBucket.offset<=PIPEFS.BUCKET_BUFFER_SIZE);var freeBytesInCurrBuffer=PIPEFS.BUCKET_BUFFER_SIZE-currBucket.offset;if(freeBytesInCurrBuffer>=dataLen){currBucket.buffer.set(data,currBucket.offset);currBucket.offset+=dataLen;return dataLen}else if(freeBytesInCurrBuffer>0){currBucket.buffer.set(data.subarray(0,freeBytesInCurrBuffer),currBucket.offset);currBucket.offset+=freeBytesInCurrBuffer;data=data.subarray(freeBytesInCurrBuffer,data.byteLength)}var numBuckets=data.byteLength/PIPEFS.BUCKET_BUFFER_SIZE|0;var remElements=data.byteLength%PIPEFS.BUCKET_BUFFER_SIZE;for(var i=0;i<numBuckets;i++){var newBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:PIPEFS.BUCKET_BUFFER_SIZE,roffset:0};pipe.buckets.push(newBucket);newBucket.buffer.set(data.subarray(0,PIPEFS.BUCKET_BUFFER_SIZE));data=data.subarray(PIPEFS.BUCKET_BUFFER_SIZE,data.byteLength)}if(remElements>0){var newBucket={buffer:new Uint8Array(PIPEFS.BUCKET_BUFFER_SIZE),offset:data.byteLength,roffset:0};pipe.buckets.push(newBucket);newBucket.buffer.set(data)}return dataLen},close:function(stream){var pipe=stream.node.pipe;pipe.refcnt--;if(pipe.refcnt===0){pipe.buckets=null}}},nextname:function(){if(!PIPEFS.nextname.current){PIPEFS.nextname.current=0}return"pipe["+PIPEFS.nextname.current+++"]"}};function ___syscall_pipe(fdPtr){try{if(fdPtr==0){throw new FS.ErrnoError(21)}var res=PIPEFS.createPipe();HEAP32[fdPtr>>2]=res.readable_fd;HEAP32[fdPtr+4>>2]=res.writable_fd;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_poll(fds,nfds,timeout){try{var nonzero=0;for(var i=0;i<nfds;i++){var pollfd=fds+8*i;var fd=HEAP32[pollfd>>2];var events=HEAP16[pollfd+4>>1];var mask=32;var stream=FS.getStream(fd);if(stream){mask=SYSCALLS.DEFAULT_POLLMASK;if(stream.stream_ops.poll){mask=stream.stream_ops.poll(stream)}}mask&=events|8|16;if(mask)nonzero++;HEAP16[pollfd+6>>1]=mask}return nonzero}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_readlinkat(dirfd,path,buf,bufsize){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);return SYSCALLS.doReadlink(path,buf,bufsize)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_recvfrom(fd,buf,len,flags,addr,addrlen){try{var sock=getSocketFromFD(fd);var msg=sock.sock_ops.recvmsg(sock,len);if(!msg)return 0;if(addr){var errno=writeSockaddr(addr,sock.family,DNS.lookup_name(msg.addr),msg.port,addrlen)}HEAPU8.set(msg.buffer,buf);return msg.buffer.byteLength}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_recvmsg(fd,message,flags){try{var sock=getSocketFromFD(fd);var iov=HEAP32[message+8>>2];var num=HEAP32[message+12>>2];var total=0;for(var i=0;i<num;i++){total+=HEAP32[iov+(8*i+4)>>2]}var msg=sock.sock_ops.recvmsg(sock,total);if(!msg)return 0;var name=HEAP32[message>>2];if(name){var errno=writeSockaddr(name,sock.family,DNS.lookup_name(msg.addr),msg.port)}var bytesRead=0;var bytesRemaining=msg.buffer.byteLength;for(var i=0;bytesRemaining>0&&i<num;i++){var iovbase=HEAP32[iov+(8*i+0)>>2];var iovlen=HEAP32[iov+(8*i+4)>>2];if(!iovlen){continue}var length=Math.min(iovlen,bytesRemaining);var buf=msg.buffer.subarray(bytesRead,bytesRead+length);HEAPU8.set(buf,iovbase+bytesRead);bytesRead+=length;bytesRemaining-=length}return bytesRead}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_renameat(olddirfd,oldpath,newdirfd,newpath){try{oldpath=SYSCALLS.getStr(oldpath);newpath=SYSCALLS.getStr(newpath);oldpath=SYSCALLS.calculateAt(olddirfd,oldpath);newpath=SYSCALLS.calculateAt(newdirfd,newpath);FS.rename(oldpath,newpath);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_rmdir(path){try{path=SYSCALLS.getStr(path);FS.rmdir(path);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_sendmsg(fd,message,flags){try{var sock=getSocketFromFD(fd);var iov=HEAP32[message+8>>2];var num=HEAP32[message+12>>2];var addr,port;var name=HEAP32[message>>2];var namelen=HEAP32[message+4>>2];if(name){var info=readSockaddr(name,namelen);if(info.errno)return-info.errno;port=info.port;addr=DNS.lookup_addr(info.addr)||info.addr}var total=0;for(var i=0;i<num;i++){total+=HEAP32[iov+(8*i+4)>>2]}var view=new Uint8Array(total);var offset=0;for(var i=0;i<num;i++){var iovbase=HEAP32[iov+(8*i+0)>>2];var iovlen=HEAP32[iov+(8*i+4)>>2];for(var j=0;j<iovlen;j++){view[offset++]=HEAP8[iovbase+j>>0]}}return sock.sock_ops.sendmsg(sock,view,0,total,addr,port)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_sendto(fd,message,length,flags,addr,addr_len){try{var sock=getSocketFromFD(fd);var dest=getSocketAddress(addr,addr_len,true);if(!dest){return FS.write(sock.stream,HEAP8,message,length)}else{return sock.sock_ops.sendmsg(sock,HEAP8,message,length,dest.addr,dest.port)}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_socket(domain,type,protocol){try{var sock=SOCKFS.createSocket(domain,type,protocol);return sock.stream.fd}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_stat64(path,buf){try{path=SYSCALLS.getStr(path);return SYSCALLS.doStat(FS.stat,path,buf)}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_statfs64(path,size,buf){try{path=SYSCALLS.getStr(path);HEAP32[buf+4>>2]=4096;HEAP32[buf+40>>2]=4096;HEAP32[buf+8>>2]=1e6;HEAP32[buf+12>>2]=5e5;HEAP32[buf+16>>2]=5e5;HEAP32[buf+20>>2]=FS.nextInode;HEAP32[buf+24>>2]=1e6;HEAP32[buf+28>>2]=42;HEAP32[buf+44>>2]=2;HEAP32[buf+36>>2]=255;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_truncate64(path,low,high){try{path=SYSCALLS.getStr(path);var length=SYSCALLS.get64(low,high);FS.truncate(path,length);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_unlinkat(dirfd,path,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path);if(flags===0){FS.unlink(path)}else if(flags===512){FS.rmdir(path)}else{abort("Invalid flags passed to unlinkat")}return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function ___syscall_utimensat(dirfd,path,times,flags){try{path=SYSCALLS.getStr(path);path=SYSCALLS.calculateAt(dirfd,path,true);if(!times){var atime=Date.now();var mtime=atime}else{var seconds=HEAP32[times>>2];var nanoseconds=HEAP32[times+4>>2];atime=seconds*1e3+nanoseconds/(1e3*1e3);times+=8;seconds=HEAP32[times>>2];nanoseconds=HEAP32[times+4>>2];mtime=seconds*1e3+nanoseconds/(1e3*1e3)}FS.utime(path,atime,mtime);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}var dlopen_main_init=0;function __dlopen_js(handle){var ret=!dlopen_main_init;dlopen_main_init=1;return ret}function __dlsym_js(handle,symbol){return 0}function __emscripten_date_now(){return Date.now()}var nowIsMonotonic=true;function __emscripten_get_now_is_monotonic(){return nowIsMonotonic}function __emscripten_throw_longjmp(){throw Infinity}function __gmtime_js(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getUTCSeconds();HEAP32[tmPtr+4>>2]=date.getUTCMinutes();HEAP32[tmPtr+8>>2]=date.getUTCHours();HEAP32[tmPtr+12>>2]=date.getUTCDate();HEAP32[tmPtr+16>>2]=date.getUTCMonth();HEAP32[tmPtr+20>>2]=date.getUTCFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getUTCDay();var start=Date.UTC(date.getUTCFullYear(),0,1,0,0,0,0);var yday=(date.getTime()-start)/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday}function __localtime_js(time,tmPtr){var date=new Date(HEAP32[time>>2]*1e3);HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();HEAP32[tmPtr+20>>2]=date.getFullYear()-1900;HEAP32[tmPtr+24>>2]=date.getDay();var start=new Date(date.getFullYear(),0,1);var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr+36>>2]=-(date.getTimezoneOffset()*60);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dst=(summerOffset!=winterOffset&&date.getTimezoneOffset()==Math.min(winterOffset,summerOffset))|0;HEAP32[tmPtr+32>>2]=dst}function __mktime_js(tmPtr){var date=new Date(HEAP32[tmPtr+20>>2]+1900,HEAP32[tmPtr+16>>2],HEAP32[tmPtr+12>>2],HEAP32[tmPtr+8>>2],HEAP32[tmPtr+4>>2],HEAP32[tmPtr>>2],0);var dst=HEAP32[tmPtr+32>>2];var guessedOffset=date.getTimezoneOffset();var start=new Date(date.getFullYear(),0,1);var summerOffset=new Date(date.getFullYear(),6,1).getTimezoneOffset();var winterOffset=start.getTimezoneOffset();var dstOffset=Math.min(winterOffset,summerOffset);if(dst<0){HEAP32[tmPtr+32>>2]=Number(summerOffset!=winterOffset&&dstOffset==guessedOffset)}else if(dst>0!=(dstOffset==guessedOffset)){var nonDstOffset=Math.max(winterOffset,summerOffset);var trueOffset=dst>0?dstOffset:nonDstOffset;date.setTime(date.getTime()+(trueOffset-guessedOffset)*6e4)}HEAP32[tmPtr+24>>2]=date.getDay();var yday=(date.getTime()-start.getTime())/(1e3*60*60*24)|0;HEAP32[tmPtr+28>>2]=yday;HEAP32[tmPtr>>2]=date.getSeconds();HEAP32[tmPtr+4>>2]=date.getMinutes();HEAP32[tmPtr+8>>2]=date.getHours();HEAP32[tmPtr+12>>2]=date.getDate();HEAP32[tmPtr+16>>2]=date.getMonth();return date.getTime()/1e3|0}function __mmap_js(addr,len,prot,flags,fd,off,allocated,builtin){try{var info=FS.getStream(fd);if(!info)return-8;var res=FS.mmap(info,addr,len,off,prot,flags);var ptr=res.ptr;HEAP32[allocated>>2]=res.allocated;return ptr}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function __munmap_js(addr,len,prot,flags,fd,offset){try{var stream=FS.getStream(fd);if(stream){if(prot&2){SYSCALLS.doMsync(addr,stream,len,flags,offset)}FS.munmap(stream)}}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return-e.errno}}function _tzset_impl(timezone,daylight,tzname){var currentYear=(new Date).getFullYear();var winter=new Date(currentYear,0,1);var summer=new Date(currentYear,6,1);var winterOffset=winter.getTimezoneOffset();var summerOffset=summer.getTimezoneOffset();var stdTimezoneOffset=Math.max(winterOffset,summerOffset);HEAP32[timezone>>2]=stdTimezoneOffset*60;HEAP32[daylight>>2]=Number(winterOffset!=summerOffset);function extractZone(date){var match=date.toTimeString().match(/\(([A-Za-z ]+)\)$/);return match?match[1]:"GMT"}var winterName=extractZone(winter);var summerName=extractZone(summer);var winterNamePtr=allocateUTF8(winterName);var summerNamePtr=allocateUTF8(summerName);if(summerOffset<winterOffset){HEAP32[tzname>>2]=winterNamePtr;HEAP32[tzname+4>>2]=summerNamePtr}else{HEAP32[tzname>>2]=summerNamePtr;HEAP32[tzname+4>>2]=winterNamePtr}}function __tzset_js(timezone,daylight,tzname){if(__tzset_js.called)return;__tzset_js.called=true;_tzset_impl(timezone,daylight,tzname)}function _abort(){abort("")}var readAsmConstArgsArray=[];function readAsmConstArgs(sigPtr,buf){readAsmConstArgsArray.length=0;var ch;buf>>=2;while(ch=HEAPU8[sigPtr++]){var readAsmConstArgsDouble=ch<105;if(readAsmConstArgsDouble&&buf&1)buf++;readAsmConstArgsArray.push(readAsmConstArgsDouble?HEAPF64[buf++>>1]:HEAP32[buf]);++buf}return readAsmConstArgsArray}function mainThreadEM_ASM(code,sigPtr,argbuf,sync){var args=readAsmConstArgs(sigPtr,argbuf);return ASM_CONSTS[code].apply(null,args)}function _emscripten_asm_const_int_sync_on_main_thread(code,sigPtr,argbuf){return mainThreadEM_ASM(code,sigPtr,argbuf,1)}function _emscripten_set_main_loop_timing(mode,value){Browser.mainLoop.timingMode=mode;Browser.mainLoop.timingValue=value;if(!Browser.mainLoop.func){return 1}if(!Browser.mainLoop.running){Browser.mainLoop.running=true}if(mode==0){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setTimeout(){var timeUntilNextTick=Math.max(0,Browser.mainLoop.tickStartTime+value-_emscripten_get_now())|0;setTimeout(Browser.mainLoop.runner,timeUntilNextTick)};Browser.mainLoop.method="timeout"}else if(mode==1){Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_rAF(){Browser.requestAnimationFrame(Browser.mainLoop.runner)};Browser.mainLoop.method="rAF"}else if(mode==2){if(typeof setImmediate=="undefined"){var setImmediates=[];var emscriptenMainLoopMessageId="setimmediate";var Browser_setImmediate_messageHandler=function(event){if(event.data===emscriptenMainLoopMessageId||event.data.target===emscriptenMainLoopMessageId){event.stopPropagation();setImmediates.shift()()}};addEventListener("message",Browser_setImmediate_messageHandler,true);setImmediate=function Browser_emulated_setImmediate(func){setImmediates.push(func);if(ENVIRONMENT_IS_WORKER){if(Module["setImmediates"]===undefined)Module["setImmediates"]=[];Module["setImmediates"].push(func);postMessage({target:emscriptenMainLoopMessageId})}else postMessage(emscriptenMainLoopMessageId,"*")}}Browser.mainLoop.scheduler=function Browser_mainLoop_scheduler_setImmediate(){setImmediate(Browser.mainLoop.runner)};Browser.mainLoop.method="immediate"}return 0}var _emscripten_get_now;if(ENVIRONMENT_IS_NODE){_emscripten_get_now=(()=>{var t=process["hrtime"]();return t[0]*1e3+t[1]/1e6})}else _emscripten_get_now=(()=>performance.now());function _exit(status){exit(status)}function maybeExit(){}function setMainLoop(browserIterationFunc,fps,simulateInfiniteLoop,arg,noSetTiming){assert(!Browser.mainLoop.func,"emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.");Browser.mainLoop.func=browserIterationFunc;Browser.mainLoop.arg=arg;var thisMainLoopId=Browser.mainLoop.currentlyRunningMainloop;function checkIsRunning(){if(thisMainLoopId<Browser.mainLoop.currentlyRunningMainloop){maybeExit();return false}return true}Browser.mainLoop.running=false;Browser.mainLoop.runner=function Browser_mainLoop_runner(){if(ABORT)return;if(Browser.mainLoop.queue.length>0){var start=Date.now();var blocker=Browser.mainLoop.queue.shift();blocker.func(blocker.arg);if(Browser.mainLoop.remainingBlockers){var remaining=Browser.mainLoop.remainingBlockers;var next=remaining%1==0?remaining-1:Math.floor(remaining);if(blocker.counted){Browser.mainLoop.remainingBlockers=next}else{next=next+.5;Browser.mainLoop.remainingBlockers=(8*remaining+next)/9}}out('main loop blocker "'+blocker.name+'" took '+(Date.now()-start)+" ms");Browser.mainLoop.updateStatus();if(!checkIsRunning())return;setTimeout(Browser.mainLoop.runner,0);return}if(!checkIsRunning())return;Browser.mainLoop.currentFrameNumber=Browser.mainLoop.currentFrameNumber+1|0;if(Browser.mainLoop.timingMode==1&&Browser.mainLoop.timingValue>1&&Browser.mainLoop.currentFrameNumber%Browser.mainLoop.timingValue!=0){Browser.mainLoop.scheduler();return}else if(Browser.mainLoop.timingMode==0){Browser.mainLoop.tickStartTime=_emscripten_get_now()}GL.newRenderingFrameStarted();Browser.mainLoop.runIter(browserIterationFunc);if(!checkIsRunning())return;if(typeof SDL=="object"&&SDL.audio&&SDL.audio.queueNewAudioData)SDL.audio.queueNewAudioData();Browser.mainLoop.scheduler()};if(!noSetTiming){if(fps&&fps>0)_emscripten_set_main_loop_timing(0,1e3/fps);else _emscripten_set_main_loop_timing(1,1);Browser.mainLoop.scheduler()}if(simulateInfiniteLoop){throw"unwind"}}function callUserCallback(func,synchronous){if(ABORT){return}if(synchronous){func();return}try{func()}catch(e){handleException(e)}}function safeSetTimeout(func,timeout){return setTimeout(function(){callUserCallback(func)},timeout)}var Browser={mainLoop:{running:false,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function(){Browser.mainLoop.scheduler=null;Browser.mainLoop.currentlyRunningMainloop++},resume:function(){Browser.mainLoop.currentlyRunningMainloop++;var timingMode=Browser.mainLoop.timingMode;var timingValue=Browser.mainLoop.timingValue;var func=Browser.mainLoop.func;Browser.mainLoop.func=null;setMainLoop(func,0,false,Browser.mainLoop.arg,true);_emscripten_set_main_loop_timing(timingMode,timingValue);Browser.mainLoop.scheduler()},updateStatus:function(){if(Module["setStatus"]){var message=Module["statusMessage"]||"Please wait...";var remaining=Browser.mainLoop.remainingBlockers;var expected=Browser.mainLoop.expectedBlockers;if(remaining){if(remaining<expected){Module["setStatus"](message+" ("+(expected-remaining)+"/"+expected+")")}else{Module["setStatus"](message)}}else{Module["setStatus"]("")}}},runIter:function(func){if(ABORT)return;if(Module["preMainLoop"]){var preRet=Module["preMainLoop"]();if(preRet===false){return}}callUserCallback(func);if(Module["postMainLoop"])Module["postMainLoop"]()}},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function(){if(!Module["preloadPlugins"])Module["preloadPlugins"]=[];if(Browser.initted)return;Browser.initted=true;try{new Blob;Browser.hasBlobConstructor=true}catch(e){Browser.hasBlobConstructor=false;out("warning: no blob constructor, cannot create blobs with mimetypes")}Browser.BlobBuilder=typeof MozBlobBuilder!="undefined"?MozBlobBuilder:typeof WebKitBlobBuilder!="undefined"?WebKitBlobBuilder:!Browser.hasBlobConstructor?out("warning: no BlobBuilder"):null;Browser.URLObject=typeof window!="undefined"?window.URL?window.URL:window.webkitURL:undefined;if(!Module.noImageDecoding&&typeof Browser.URLObject=="undefined"){out("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");Module.noImageDecoding=true}var imagePlugin={};imagePlugin["canHandle"]=function imagePlugin_canHandle(name){return!Module.noImageDecoding&&/\.(jpg|jpeg|png|bmp)$/i.test(name)};imagePlugin["handle"]=function imagePlugin_handle(byteArray,name,onload,onerror){var b=null;if(Browser.hasBlobConstructor){try{b=new Blob([byteArray],{type:Browser.getMimetype(name)});if(b.size!==byteArray.length){b=new Blob([new Uint8Array(byteArray).buffer],{type:Browser.getMimetype(name)})}}catch(e){warnOnce("Blob constructor present but fails: "+e+"; falling back to blob builder")}}if(!b){var bb=new Browser.BlobBuilder;bb.append(new Uint8Array(byteArray).buffer);b=bb.getBlob()}var url=Browser.URLObject.createObjectURL(b);var img=new Image;img.onload=(()=>{assert(img.complete,"Image "+name+" could not be decoded");var canvas=document.createElement("canvas");canvas.width=img.width;canvas.height=img.height;var ctx=canvas.getContext("2d");ctx.drawImage(img,0,0);Module["preloadedImages"][name]=canvas;Browser.URLObject.revokeObjectURL(url);if(onload)onload(byteArray)});img.onerror=(event=>{out("Image "+url+" could not be decoded");if(onerror)onerror()});img.src=url};Module["preloadPlugins"].push(imagePlugin);var audioPlugin={};audioPlugin["canHandle"]=function audioPlugin_canHandle(name){return!Module.noAudioDecoding&&name.substr(-4)in{".ogg":1,".wav":1,".mp3":1}};audioPlugin["handle"]=function audioPlugin_handle(byteArray,name,onload,onerror){var done=false;function finish(audio){if(done)return;done=true;Module["preloadedAudios"][name]=audio;if(onload)onload(byteArray)}function fail(){if(done)return;done=true;Module["preloadedAudios"][name]=new Audio;if(onerror)onerror()}if(Browser.hasBlobConstructor){try{var b=new Blob([byteArray],{type:Browser.getMimetype(name)})}catch(e){return fail()}var url=Browser.URLObject.createObjectURL(b);var audio=new Audio;audio.addEventListener("canplaythrough",function(){finish(audio)},false);audio.onerror=function audio_onerror(event){if(done)return;out("warning: browser could not fully decode audio "+name+", trying slower base64 approach");function encode64(data){var BASE="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";var PAD="=";var ret="";var leftchar=0;var leftbits=0;for(var i=0;i<data.length;i++){leftchar=leftchar<<8|data[i];leftbits+=8;while(leftbits>=6){var curr=leftchar>>leftbits-6&63;leftbits-=6;ret+=BASE[curr]}}if(leftbits==2){ret+=BASE[(leftchar&3)<<4];ret+=PAD+PAD}else if(leftbits==4){ret+=BASE[(leftchar&15)<<2];ret+=PAD}return ret}audio.src="data:audio/x-"+name.substr(-3)+";base64,"+encode64(byteArray);finish(audio)};audio.src=url;safeSetTimeout(function(){finish(audio)},1e4)}else{return fail()}};Module["preloadPlugins"].push(audioPlugin);function pointerLockChange(){Browser.pointerLock=document["pointerLockElement"]===Module["canvas"]||document["mozPointerLockElement"]===Module["canvas"]||document["webkitPointerLockElement"]===Module["canvas"]||document["msPointerLockElement"]===Module["canvas"]}var canvas=Module["canvas"];if(canvas){canvas.requestPointerLock=canvas["requestPointerLock"]||canvas["mozRequestPointerLock"]||canvas["webkitRequestPointerLock"]||canvas["msRequestPointerLock"]||function(){};canvas.exitPointerLock=document["exitPointerLock"]||document["mozExitPointerLock"]||document["webkitExitPointerLock"]||document["msExitPointerLock"]||function(){};canvas.exitPointerLock=canvas.exitPointerLock.bind(document);document.addEventListener("pointerlockchange",pointerLockChange,false);document.addEventListener("mozpointerlockchange",pointerLockChange,false);document.addEventListener("webkitpointerlockchange",pointerLockChange,false);document.addEventListener("mspointerlockchange",pointerLockChange,false);if(Module["elementPointerLock"]){canvas.addEventListener("click",function(ev){if(!Browser.pointerLock&&Module["canvas"].requestPointerLock){Module["canvas"].requestPointerLock();ev.preventDefault()}},false)}}},handledByPreloadPlugin:function(byteArray,fullname,finish,onerror){Browser.init();var handled=false;Module["preloadPlugins"].forEach(function(plugin){if(handled)return;if(plugin["canHandle"](fullname)){plugin["handle"](byteArray,fullname,finish,onerror);handled=true}});return handled},createContext:function(canvas,useWebGL,setInModule,webGLContextAttributes){if(useWebGL&&Module.ctx&&canvas==Module.canvas)return Module.ctx;var ctx;var contextHandle;if(useWebGL){var contextAttributes={antialias:false,alpha:false,majorVersion:typeof WebGL2RenderingContext!="undefined"?2:1};if(webGLContextAttributes){for(var attribute in webGLContextAttributes){contextAttributes[attribute]=webGLContextAttributes[attribute]}}if(typeof GL!="undefined"){contextHandle=GL.createContext(canvas,contextAttributes);if(contextHandle){ctx=GL.getContext(contextHandle).GLctx}}}else{ctx=canvas.getContext("2d")}if(!ctx)return null;if(setInModule){if(!useWebGL)assert(typeof GLctx=="undefined","cannot set in module if GLctx is used, but we are a non-GL context that would replace it");Module.ctx=ctx;if(useWebGL)GL.makeContextCurrent(contextHandle);Module.useWebGL=useWebGL;Browser.moduleContextCreatedCallbacks.forEach(function(callback){callback()});Browser.init()}return ctx},destroyContext:function(canvas,useWebGL,setInModule){},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer,resizeCanvas){Browser.lockPointer=lockPointer;Browser.resizeCanvas=resizeCanvas;if(typeof Browser.lockPointer=="undefined")Browser.lockPointer=true;if(typeof Browser.resizeCanvas=="undefined")Browser.resizeCanvas=false;var canvas=Module["canvas"];function fullscreenChange(){Browser.isFullscreen=false;var canvasContainer=canvas.parentNode;if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvasContainer){canvas.exitFullscreen=Browser.exitFullscreen;if(Browser.lockPointer)canvas.requestPointerLock();Browser.isFullscreen=true;if(Browser.resizeCanvas){Browser.setFullscreenCanvasSize()}else{Browser.updateCanvasDimensions(canvas)}}else{canvasContainer.parentNode.insertBefore(canvas,canvasContainer);canvasContainer.parentNode.removeChild(canvasContainer);if(Browser.resizeCanvas){Browser.setWindowedCanvasSize()}else{Browser.updateCanvasDimensions(canvas)}}if(Module["onFullScreen"])Module["onFullScreen"](Browser.isFullscreen);if(Module["onFullscreen"])Module["onFullscreen"](Browser.isFullscreen)}if(!Browser.fullscreenHandlersInstalled){Browser.fullscreenHandlersInstalled=true;document.addEventListener("fullscreenchange",fullscreenChange,false);document.addEventListener("mozfullscreenchange",fullscreenChange,false);document.addEventListener("webkitfullscreenchange",fullscreenChange,false);document.addEventListener("MSFullscreenChange",fullscreenChange,false)}var canvasContainer=document.createElement("div");canvas.parentNode.insertBefore(canvasContainer,canvas);canvasContainer.appendChild(canvas);canvasContainer.requestFullscreen=canvasContainer["requestFullscreen"]||canvasContainer["mozRequestFullScreen"]||canvasContainer["msRequestFullscreen"]||(canvasContainer["webkitRequestFullscreen"]?function(){canvasContainer["webkitRequestFullscreen"](Element["ALLOW_KEYBOARD_INPUT"])}:null)||(canvasContainer["webkitRequestFullScreen"]?function(){canvasContainer["webkitRequestFullScreen"](Element["ALLOW_KEYBOARD_INPUT"])}:null);canvasContainer.requestFullscreen()},exitFullscreen:function(){if(!Browser.isFullscreen){return false}var CFS=document["exitFullscreen"]||document["cancelFullScreen"]||document["mozCancelFullScreen"]||document["msExitFullscreen"]||document["webkitCancelFullScreen"]||function(){};CFS.apply(document,[]);return true},nextRAF:0,fakeRequestAnimationFrame:function(func){var now=Date.now();if(Browser.nextRAF===0){Browser.nextRAF=now+1e3/60}else{while(now+2>=Browser.nextRAF){Browser.nextRAF+=1e3/60}}var delay=Math.max(Browser.nextRAF-now,0);setTimeout(func,delay)},requestAnimationFrame:function(func){if(typeof requestAnimationFrame=="function"){requestAnimationFrame(func);return}var RAF=Browser.fakeRequestAnimationFrame;RAF(func)},safeSetTimeout:function(func){return safeSetTimeout(func)},safeRequestAnimationFrame:function(func){return Browser.requestAnimationFrame(function(){callUserCallback(func)})},getMimetype:function(name){return{"jpg":"image/jpeg","jpeg":"image/jpeg","png":"image/png","bmp":"image/bmp","ogg":"audio/ogg","wav":"audio/wav","mp3":"audio/mpeg"}[name.substr(name.lastIndexOf(".")+1)]},getUserMedia:function(func){if(!window.getUserMedia){window.getUserMedia=navigator["getUserMedia"]||navigator["mozGetUserMedia"]}window.getUserMedia(func)},getMovementX:function(event){return event["movementX"]||event["mozMovementX"]||event["webkitMovementX"]||0},getMovementY:function(event){return event["movementY"]||event["mozMovementY"]||event["webkitMovementY"]||0},getMouseWheelDelta:function(event){var delta=0;switch(event.type){case"DOMMouseScroll":delta=event.detail/3;break;case"mousewheel":delta=event.wheelDelta/120;break;case"wheel":delta=event.deltaY;switch(event.deltaMode){case 0:delta/=100;break;case 1:delta/=3;break;case 2:delta*=80;break;default:throw"unrecognized mouse wheel delta mode: "+event.deltaMode}break;default:throw"unrecognized mouse wheel event: "+event.type}return delta},mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event){if(Browser.pointerLock){if(event.type!="mousemove"&&"mozMovementX"in event){Browser.mouseMovementX=Browser.mouseMovementY=0}else{Browser.mouseMovementX=Browser.getMovementX(event);Browser.mouseMovementY=Browser.getMovementY(event)}if(typeof SDL!="undefined"){Browser.mouseX=SDL.mouseX+Browser.mouseMovementX;Browser.mouseY=SDL.mouseY+Browser.mouseMovementY}else{Browser.mouseX+=Browser.mouseMovementX;Browser.mouseY+=Browser.mouseMovementY}}else{var rect=Module["canvas"].getBoundingClientRect();var cw=Module["canvas"].width;var ch=Module["canvas"].height;var scrollX=typeof window.scrollX!="undefined"?window.scrollX:window.pageXOffset;var scrollY=typeof window.scrollY!="undefined"?window.scrollY:window.pageYOffset;if(event.type==="touchstart"||event.type==="touchend"||event.type==="touchmove"){var touch=event.touch;if(touch===undefined){return}var adjustedX=touch.pageX-(scrollX+rect.left);var adjustedY=touch.pageY-(scrollY+rect.top);adjustedX=adjustedX*(cw/rect.width);adjustedY=adjustedY*(ch/rect.height);var coords={x:adjustedX,y:adjustedY};if(event.type==="touchstart"){Browser.lastTouches[touch.identifier]=coords;Browser.touches[touch.identifier]=coords}else if(event.type==="touchend"||event.type==="touchmove"){var last=Browser.touches[touch.identifier];if(!last)last=coords;Browser.lastTouches[touch.identifier]=last;Browser.touches[touch.identifier]=coords}return}var x=event.pageX-(scrollX+rect.left);var y=event.pageY-(scrollY+rect.top);x=x*(cw/rect.width);y=y*(ch/rect.height);Browser.mouseMovementX=x-Browser.mouseX;Browser.mouseMovementY=y-Browser.mouseY;Browser.mouseX=x;Browser.mouseY=y}},resizeListeners:[],updateResizeListeners:function(){var canvas=Module["canvas"];Browser.resizeListeners.forEach(function(listener){listener(canvas.width,canvas.height)})},setCanvasSize:function(width,height,noUpdates){var canvas=Module["canvas"];Browser.updateCanvasDimensions(canvas,width,height);if(!noUpdates)Browser.updateResizeListeners()},windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen>>2];flags=flags|8388608;HEAP32[SDL.screen>>2]=flags}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners()},setWindowedCanvasSize:function(){if(typeof SDL!="undefined"){var flags=HEAPU32[SDL.screen>>2];flags=flags&~8388608;HEAP32[SDL.screen>>2]=flags}Browser.updateCanvasDimensions(Module["canvas"]);Browser.updateResizeListeners()},updateCanvasDimensions:function(canvas,wNative,hNative){if(wNative&&hNative){canvas.widthNative=wNative;canvas.heightNative=hNative}else{wNative=canvas.widthNative;hNative=canvas.heightNative}var w=wNative;var h=hNative;if(Module["forcedAspectRatio"]&&Module["forcedAspectRatio"]>0){if(w/h<Module["forcedAspectRatio"]){w=Math.round(h*Module["forcedAspectRatio"])}else{h=Math.round(w/Module["forcedAspectRatio"])}}if((document["fullscreenElement"]||document["mozFullScreenElement"]||document["msFullscreenElement"]||document["webkitFullscreenElement"]||document["webkitCurrentFullScreenElement"])===canvas.parentNode&&typeof screen!="undefined"){var factor=Math.min(screen.width/w,screen.height/h);w=Math.round(w*factor);h=Math.round(h*factor)}if(Browser.resizeCanvas){if(canvas.width!=w)canvas.width=w;if(canvas.height!=h)canvas.height=h;if(typeof canvas.style!="undefined"){canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}else{if(canvas.width!=wNative)canvas.width=wNative;if(canvas.height!=hNative)canvas.height=hNative;if(typeof canvas.style!="undefined"){if(w!=wNative||h!=hNative){canvas.style.setProperty("width",w+"px","important");canvas.style.setProperty("height",h+"px","important")}else{canvas.style.removeProperty("width");canvas.style.removeProperty("height")}}}}};function _emscripten_cancel_main_loop(){Browser.mainLoop.pause();Browser.mainLoop.func=null}function _emscripten_clear_interval(id){clearInterval(id)}var JSEvents={inEventHandler:0,removeAllEventListeners:function(){for(var i=JSEvents.eventHandlers.length-1;i>=0;--i){JSEvents._removeHandler(i)}JSEvents.eventHandlers=[];JSEvents.deferredCalls=[]},registerRemoveEventListeners:function(){if(!JSEvents.removeEventListenersRegistered){__ATEXIT__.push(JSEvents.removeAllEventListeners);JSEvents.removeEventListenersRegistered=true}},deferredCalls:[],deferCall:function(targetFunction,precedence,argsList){function arraysHaveEqualContent(arrA,arrB){if(arrA.length!=arrB.length)return false;for(var i in arrA){if(arrA[i]!=arrB[i])return false}return true}for(var i in JSEvents.deferredCalls){var call=JSEvents.deferredCalls[i];if(call.targetFunction==targetFunction&&arraysHaveEqualContent(call.argsList,argsList)){return}}JSEvents.deferredCalls.push({targetFunction:targetFunction,precedence:precedence,argsList:argsList});JSEvents.deferredCalls.sort(function(x,y){return x.precedence<y.precedence})},removeDeferredCalls:function(targetFunction){for(var i=0;i<JSEvents.deferredCalls.length;++i){if(JSEvents.deferredCalls[i].targetFunction==targetFunction){JSEvents.deferredCalls.splice(i,1);--i}}},canPerformEventHandlerRequests:function(){return JSEvents.inEventHandler&&JSEvents.currentEventHandler.allowsDeferredCalls},runDeferredCalls:function(){if(!JSEvents.canPerformEventHandlerRequests()){return}for(var i=0;i<JSEvents.deferredCalls.length;++i){var call=JSEvents.deferredCalls[i];JSEvents.deferredCalls.splice(i,1);--i;call.targetFunction.apply(null,call.argsList)}},eventHandlers:[],removeAllHandlersOnTarget:function(target,eventTypeString){for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==target&&(!eventTypeString||eventTypeString==JSEvents.eventHandlers[i].eventTypeString)){JSEvents._removeHandler(i--)}}},_removeHandler:function(i){var h=JSEvents.eventHandlers[i];h.target.removeEventListener(h.eventTypeString,h.eventListenerFunc,h.useCapture);JSEvents.eventHandlers.splice(i,1)},registerOrRemoveHandler:function(eventHandler){var jsEventHandler=function jsEventHandler(event){++JSEvents.inEventHandler;JSEvents.currentEventHandler=eventHandler;JSEvents.runDeferredCalls();eventHandler.handlerFunc(event);JSEvents.runDeferredCalls();--JSEvents.inEventHandler};if(eventHandler.callbackfunc){eventHandler.eventListenerFunc=jsEventHandler;eventHandler.target.addEventListener(eventHandler.eventTypeString,jsEventHandler,eventHandler.useCapture);JSEvents.eventHandlers.push(eventHandler);JSEvents.registerRemoveEventListeners()}else{for(var i=0;i<JSEvents.eventHandlers.length;++i){if(JSEvents.eventHandlers[i].target==eventHandler.target&&JSEvents.eventHandlers[i].eventTypeString==eventHandler.eventTypeString){JSEvents._removeHandler(i--)}}}},getNodeNameForTarget:function(target){if(!target)return"";if(target==window)return"#window";if(target==screen)return"#screen";return target&&target.nodeName?target.nodeName:""},fullscreenEnabled:function(){return document.fullscreenEnabled||document.webkitFullscreenEnabled}};var currentFullscreenStrategy={};function maybeCStringToJsString(cString){return cString>2?UTF8ToString(cString):cString}var specialHTMLTargets=[0,typeof document!="undefined"?document:0,typeof window!="undefined"?window:0];function findEventTarget(target){target=maybeCStringToJsString(target);var domElement=specialHTMLTargets[target]||(typeof document!="undefined"?document.querySelector(target):undefined);return domElement}function findCanvasEventTarget(target){return findEventTarget(target)}function _emscripten_get_canvas_element_size(target,width,height){var canvas=findCanvasEventTarget(target);if(!canvas)return-4;HEAP32[width>>2]=canvas.width;HEAP32[height>>2]=canvas.height}function getCanvasElementSize(target){return withStackSave(function(){var w=stackAlloc(8);var h=w+4;var targetInt=stackAlloc(target.id.length+1);stringToUTF8(target.id,targetInt,target.id.length+1);var ret=_emscripten_get_canvas_element_size(targetInt,w,h);var size=[HEAP32[w>>2],HEAP32[h>>2]];return size})}function _emscripten_set_canvas_element_size(target,width,height){var canvas=findCanvasEventTarget(target);if(!canvas)return-4;canvas.width=width;canvas.height=height;return 0}function setCanvasElementSize(target,width,height){if(!target.controlTransferredOffscreen){target.width=width;target.height=height}else{withStackSave(function(){var targetInt=stackAlloc(target.id.length+1);stringToUTF8(target.id,targetInt,target.id.length+1);_emscripten_set_canvas_element_size(targetInt,width,height)})}}function registerRestoreOldStyle(canvas){var canvasSize=getCanvasElementSize(canvas);var oldWidth=canvasSize[0];var oldHeight=canvasSize[1];var oldCssWidth=canvas.style.width;var oldCssHeight=canvas.style.height;var oldBackgroundColor=canvas.style.backgroundColor;var oldDocumentBackgroundColor=document.body.style.backgroundColor;var oldPaddingLeft=canvas.style.paddingLeft;var oldPaddingRight=canvas.style.paddingRight;var oldPaddingTop=canvas.style.paddingTop;var oldPaddingBottom=canvas.style.paddingBottom;var oldMarginLeft=canvas.style.marginLeft;var oldMarginRight=canvas.style.marginRight;var oldMarginTop=canvas.style.marginTop;var oldMarginBottom=canvas.style.marginBottom;var oldDocumentBodyMargin=document.body.style.margin;var oldDocumentOverflow=document.documentElement.style.overflow;var oldDocumentScroll=document.body.scroll;var oldImageRendering=canvas.style.imageRendering;function restoreOldStyle(){var fullscreenElement=document.fullscreenElement||document.webkitFullscreenElement||document.msFullscreenElement;if(!fullscreenElement){document.removeEventListener("fullscreenchange",restoreOldStyle);document.removeEventListener("webkitfullscreenchange",restoreOldStyle);setCanvasElementSize(canvas,oldWidth,oldHeight);canvas.style.width=oldCssWidth;canvas.style.height=oldCssHeight;canvas.style.backgroundColor=oldBackgroundColor;if(!oldDocumentBackgroundColor)document.body.style.backgroundColor="white";document.body.style.backgroundColor=oldDocumentBackgroundColor;canvas.style.paddingLeft=oldPaddingLeft;canvas.style.paddingRight=oldPaddingRight;canvas.style.paddingTop=oldPaddingTop;canvas.style.paddingBottom=oldPaddingBottom;canvas.style.marginLeft=oldMarginLeft;canvas.style.marginRight=oldMarginRight;canvas.style.marginTop=oldMarginTop;canvas.style.marginBottom=oldMarginBottom;document.body.style.margin=oldDocumentBodyMargin;document.documentElement.style.overflow=oldDocumentOverflow;document.body.scroll=oldDocumentScroll;canvas.style.imageRendering=oldImageRendering;if(canvas.GLctxObject)canvas.GLctxObject.GLctx.viewport(0,0,oldWidth,oldHeight);if(currentFullscreenStrategy.canvasResizedCallback){(function(a1,a2,a3){return dynCall_iiii.apply(null,[currentFullscreenStrategy.canvasResizedCallback,a1,a2,a3])})(37,0,currentFullscreenStrategy.canvasResizedCallbackUserData)}}}document.addEventListener("fullscreenchange",restoreOldStyle);document.addEventListener("webkitfullscreenchange",restoreOldStyle);return restoreOldStyle}function setLetterbox(element,topBottom,leftRight){element.style.paddingLeft=element.style.paddingRight=leftRight+"px";element.style.paddingTop=element.style.paddingBottom=topBottom+"px"}function getBoundingClientRect(e){return specialHTMLTargets.indexOf(e)<0?e.getBoundingClientRect():{"left":0,"top":0}}function _JSEvents_resizeCanvasForFullscreen(target,strategy){var restoreOldStyle=registerRestoreOldStyle(target);var cssWidth=strategy.softFullscreen?innerWidth:screen.width;var cssHeight=strategy.softFullscreen?innerHeight:screen.height;var rect=getBoundingClientRect(target);var windowedCssWidth=rect.width;var windowedCssHeight=rect.height;var canvasSize=getCanvasElementSize(target);var windowedRttWidth=canvasSize[0];var windowedRttHeight=canvasSize[1];if(strategy.scaleMode==3){setLetterbox(target,(cssHeight-windowedCssHeight)/2,(cssWidth-windowedCssWidth)/2);cssWidth=windowedCssWidth;cssHeight=windowedCssHeight}else if(strategy.scaleMode==2){if(cssWidth*windowedRttHeight<windowedRttWidth*cssHeight){var desiredCssHeight=windowedRttHeight*cssWidth/windowedRttWidth;setLetterbox(target,(cssHeight-desiredCssHeight)/2,0);cssHeight=desiredCssHeight}else{var desiredCssWidth=windowedRttWidth*cssHeight/windowedRttHeight;setLetterbox(target,0,(cssWidth-desiredCssWidth)/2);cssWidth=desiredCssWidth}}if(!target.style.backgroundColor)target.style.backgroundColor="black";if(!document.body.style.backgroundColor)document.body.style.backgroundColor="black";target.style.width=cssWidth+"px";target.style.height=cssHeight+"px";if(strategy.filteringMode==1){target.style.imageRendering="optimizeSpeed";target.style.imageRendering="-moz-crisp-edges";target.style.imageRendering="-o-crisp-edges";target.style.imageRendering="-webkit-optimize-contrast";target.style.imageRendering="optimize-contrast";target.style.imageRendering="crisp-edges";target.style.imageRendering="pixelated"}var dpiScale=strategy.canvasResolutionScaleMode==2?devicePixelRatio:1;if(strategy.canvasResolutionScaleMode!=0){var newWidth=cssWidth*dpiScale|0;var newHeight=cssHeight*dpiScale|0;setCanvasElementSize(target,newWidth,newHeight);if(target.GLctxObject)target.GLctxObject.GLctx.viewport(0,0,newWidth,newHeight)}return restoreOldStyle}function _JSEvents_requestFullscreen(target,strategy){if(strategy.scaleMode!=0||strategy.canvasResolutionScaleMode!=0){_JSEvents_resizeCanvasForFullscreen(target,strategy)}if(target.requestFullscreen){target.requestFullscreen()}else if(target.webkitRequestFullscreen){target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT)}else{return JSEvents.fullscreenEnabled()?-3:-1}currentFullscreenStrategy=strategy;if(strategy.canvasResizedCallback){(function(a1,a2,a3){return dynCall_iiii.apply(null,[strategy.canvasResizedCallback,a1,a2,a3])})(37,0,strategy.canvasResizedCallbackUserData)}return 0}function _emscripten_exit_fullscreen(){if(!JSEvents.fullscreenEnabled())return-1;JSEvents.removeDeferredCalls(_JSEvents_requestFullscreen);var d=specialHTMLTargets[1];if(d.exitFullscreen){d.fullscreenElement&&d.exitFullscreen()}else if(d.webkitExitFullscreen){d.webkitFullscreenElement&&d.webkitExitFullscreen()}else{return-1}return 0}function requestPointerLock(target){if(target.requestPointerLock){target.requestPointerLock()}else if(target.msRequestPointerLock){target.msRequestPointerLock()}else{if(document.body.requestPointerLock||document.body.msRequestPointerLock){return-3}else{return-1}}return 0}function _emscripten_exit_pointerlock(){JSEvents.removeDeferredCalls(requestPointerLock);if(document.exitPointerLock){document.exitPointerLock()}else if(document.msExitPointerLock){document.msExitPointerLock()}else{return-1}return 0}function fillFullscreenChangeEventData(eventStruct){var fullscreenElement=document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement;var isFullscreen=!!fullscreenElement;HEAP32[eventStruct>>2]=isFullscreen;HEAP32[eventStruct+4>>2]=JSEvents.fullscreenEnabled();var reportedElement=isFullscreen?fullscreenElement:JSEvents.previousFullscreenElement;var nodeName=JSEvents.getNodeNameForTarget(reportedElement);var id=reportedElement&&reportedElement.id?reportedElement.id:"";stringToUTF8(nodeName,eventStruct+8,128);stringToUTF8(id,eventStruct+136,128);HEAP32[eventStruct+264>>2]=reportedElement?reportedElement.clientWidth:0;HEAP32[eventStruct+268>>2]=reportedElement?reportedElement.clientHeight:0;HEAP32[eventStruct+272>>2]=screen.width;HEAP32[eventStruct+276>>2]=screen.height;if(isFullscreen){JSEvents.previousFullscreenElement=fullscreenElement}}function _emscripten_get_fullscreen_status(fullscreenStatus){if(!JSEvents.fullscreenEnabled())return-1;fillFullscreenChangeEventData(fullscreenStatus);return 0}function fillGamepadEventData(eventStruct,e){HEAPF64[eventStruct>>3]=e.timestamp;for(var i=0;i<e.axes.length;++i){HEAPF64[eventStruct+i*8+16>>3]=e.axes[i]}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAPF64[eventStruct+i*8+528>>3]=e.buttons[i].value}else{HEAPF64[eventStruct+i*8+528>>3]=e.buttons[i]}}for(var i=0;i<e.buttons.length;++i){if(typeof e.buttons[i]=="object"){HEAP32[eventStruct+i*4+1040>>2]=e.buttons[i].pressed}else{HEAP32[eventStruct+i*4+1040>>2]=e.buttons[i]==1}}HEAP32[eventStruct+1296>>2]=e.connected;HEAP32[eventStruct+1300>>2]=e.index;HEAP32[eventStruct+8>>2]=e.axes.length;HEAP32[eventStruct+12>>2]=e.buttons.length;stringToUTF8(e.id,eventStruct+1304,64);stringToUTF8(e.mapping,eventStruct+1368,64)}function _emscripten_get_gamepad_status(index,gamepadState){if(index<0||index>=JSEvents.lastGamepadState.length)return-5;if(!JSEvents.lastGamepadState[index])return-7;fillGamepadEventData(gamepadState,JSEvents.lastGamepadState[index]);return 0}function _emscripten_get_heap_max(){return 2147483648}function _emscripten_get_now_res(){if(ENVIRONMENT_IS_NODE){return 1}else return 1e3}function _emscripten_get_num_gamepads(){return JSEvents.lastGamepadState.length}function _emscripten_html5_remove_all_event_listeners(){JSEvents.removeAllEventListeners()}function _emscripten_is_webgl_context_lost(contextHandle){return!GL.contexts[contextHandle]||GL.contexts[contextHandle].GLctx.isContextLost()}function reallyNegative(x){return x<0||x===0&&1/x===-Infinity}function convertI32PairToI53(lo,hi){return(lo>>>0)+hi*4294967296}function convertU32PairToI53(lo,hi){return(lo>>>0)+(hi>>>0)*4294967296}function reSign(value,bits){if(value<=0){return value}var half=bits<=32?Math.abs(1<<bits-1):Math.pow(2,bits-1);if(value>=half&&(bits<=32||value>half)){value=-2*half+value}return value}function unSign(value,bits){if(value>=0){return value}return bits<=32?2*Math.abs(1<<bits-1)+value:Math.pow(2,bits)+value}function formatString(format,varargs){var textIndex=format;var argIndex=varargs;function prepVararg(ptr,type){if(type==="double"||type==="i64"){if(ptr&7){ptr+=4}}else{}return ptr}function getNextArg(type){var ret;argIndex=prepVararg(argIndex,type);if(type==="double"){ret=Number(HEAPF64[argIndex>>3]);argIndex+=8}else if(type=="i64"){ret=[HEAP32[argIndex>>2],HEAP32[argIndex+4>>2]];argIndex+=8}else{type="i32";ret=HEAP32[argIndex>>2];argIndex+=4}return ret}var ret=[];var curr,next,currArg;while(1){var startTextIndex=textIndex;curr=HEAP8[textIndex>>0];if(curr===0)break;next=HEAP8[textIndex+1>>0];if(curr==37){var flagAlwaysSigned=false;var flagLeftAlign=false;var flagAlternative=false;var flagZeroPad=false;var flagPadSign=false;flagsLoop:while(1){switch(next){case 43:flagAlwaysSigned=true;break;case 45:flagLeftAlign=true;break;case 35:flagAlternative=true;break;case 48:if(flagZeroPad){break flagsLoop}else{flagZeroPad=true;break}case 32:flagPadSign=true;break;default:break flagsLoop}textIndex++;next=HEAP8[textIndex+1>>0]}var width=0;if(next==42){width=getNextArg("i32");textIndex++;next=HEAP8[textIndex+1>>0]}else{while(next>=48&&next<=57){width=width*10+(next-48);textIndex++;next=HEAP8[textIndex+1>>0]}}var precisionSet=false,precision=-1;if(next==46){precision=0;precisionSet=true;textIndex++;next=HEAP8[textIndex+1>>0];if(next==42){precision=getNextArg("i32");textIndex++}else{while(1){var precisionChr=HEAP8[textIndex+1>>0];if(precisionChr<48||precisionChr>57)break;precision=precision*10+(precisionChr-48);textIndex++}}next=HEAP8[textIndex+1>>0]}if(precision<0){precision=6;precisionSet=false}var argSize;switch(String.fromCharCode(next)){case"h":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==104){textIndex++;argSize=1}else{argSize=2}break;case"l":var nextNext=HEAP8[textIndex+2>>0];if(nextNext==108){textIndex++;argSize=8}else{argSize=4}break;case"L":case"q":case"j":argSize=8;break;case"z":case"t":case"I":argSize=4;break;default:argSize=null}if(argSize)textIndex++;next=HEAP8[textIndex+1>>0];switch(String.fromCharCode(next)){case"d":case"i":case"u":case"o":case"x":case"X":case"p":{var signed=next==100||next==105;argSize=argSize||4;currArg=getNextArg("i"+argSize*8);var argText;if(argSize==8){currArg=next==117?convertU32PairToI53(currArg[0],currArg[1]):convertI32PairToI53(currArg[0],currArg[1])}if(argSize<=4){var limit=Math.pow(256,argSize)-1;currArg=(signed?reSign:unSign)(currArg&limit,argSize*8)}var currAbsArg=Math.abs(currArg);var prefix="";if(next==100||next==105){argText=reSign(currArg,8*argSize).toString(10)}else if(next==117){argText=unSign(currArg,8*argSize).toString(10);currArg=Math.abs(currArg)}else if(next==111){argText=(flagAlternative?"0":"")+currAbsArg.toString(8)}else if(next==120||next==88){prefix=flagAlternative&&currArg!=0?"0x":"";if(currArg<0){currArg=-currArg;argText=(currAbsArg-1).toString(16);var buffer=[];for(var i=0;i<argText.length;i++){buffer.push((15-parseInt(argText[i],16)).toString(16))}argText=buffer.join("");while(argText.length<argSize*2)argText="f"+argText}else{argText=currAbsArg.toString(16)}if(next==88){prefix=prefix.toUpperCase();argText=argText.toUpperCase()}}else if(next==112){if(currAbsArg===0){argText="(nil)"}else{prefix="0x";argText=currAbsArg.toString(16)}}if(precisionSet){while(argText.length<precision){argText="0"+argText}}if(currArg>=0){if(flagAlwaysSigned){prefix="+"+prefix}else if(flagPadSign){prefix=" "+prefix}}if(argText.charAt(0)=="-"){prefix="-"+prefix;argText=argText.substr(1)}while(prefix.length+argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad){argText="0"+argText}else{prefix=" "+prefix}}}argText=prefix+argText;argText.split("").forEach(function(chr){ret.push(chr.charCodeAt(0))});break}case"f":case"F":case"e":case"E":case"g":case"G":{currArg=getNextArg("double");var argText;if(isNaN(currArg)){argText="nan";flagZeroPad=false}else if(!isFinite(currArg)){argText=(currArg<0?"-":"")+"inf";flagZeroPad=false}else{var isGeneral=false;var effectivePrecision=Math.min(precision,20);if(next==103||next==71){isGeneral=true;precision=precision||1;var exponent=parseInt(currArg.toExponential(effectivePrecision).split("e")[1],10);if(precision>exponent&&exponent>=-4){next=(next==103?"f":"F").charCodeAt(0);precision-=exponent+1}else{next=(next==103?"e":"E").charCodeAt(0);precision--}effectivePrecision=Math.min(precision,20)}if(next==101||next==69){argText=currArg.toExponential(effectivePrecision);if(/[eE][-+]\d$/.test(argText)){argText=argText.slice(0,-1)+"0"+argText.slice(-1)}}else if(next==102||next==70){argText=currArg.toFixed(effectivePrecision);if(currArg===0&&reallyNegative(currArg)){argText="-"+argText}}var parts=argText.split("e");if(isGeneral&&!flagAlternative){while(parts[0].length>1&&parts[0].includes(".")&&(parts[0].slice(-1)=="0"||parts[0].slice(-1)==".")){parts[0]=parts[0].slice(0,-1)}}else{if(flagAlternative&&argText.indexOf(".")==-1)parts[0]+=".";while(precision>effectivePrecision++)parts[0]+="0"}argText=parts[0]+(parts.length>1?"e"+parts[1]:"");if(next==69)argText=argText.toUpperCase();if(currArg>=0){if(flagAlwaysSigned){argText="+"+argText}else if(flagPadSign){argText=" "+argText}}}while(argText.length<width){if(flagLeftAlign){argText+=" "}else{if(flagZeroPad&&(argText[0]=="-"||argText[0]=="+")){argText=argText[0]+"0"+argText.slice(1)}else{argText=(flagZeroPad?"0":" ")+argText}}}if(next<97)argText=argText.toUpperCase();argText.split("").forEach(function(chr){ret.push(chr.charCodeAt(0))});break}case"s":{var arg=getNextArg("i8*");var argLength=arg?_strlen(arg):"(null)".length;if(precisionSet)argLength=Math.min(argLength,precision);if(!flagLeftAlign){while(argLength<width--){ret.push(32)}}if(arg){for(var i=0;i<argLength;i++){ret.push(HEAPU8[arg++>>0])}}else{ret=ret.concat(intArrayFromString("(null)".substr(0,argLength),true))}if(flagLeftAlign){while(argLength<width--){ret.push(32)}}break}case"c":{if(flagLeftAlign)ret.push(getNextArg("i8"));while(--width>0){ret.push(32)}if(!flagLeftAlign)ret.push(getNextArg("i8"));break}case"n":{var ptr=getNextArg("i32*");HEAP32[ptr>>2]=ret.length;break}case"%":{ret.push(curr);break}default:{for(var i=startTextIndex;i<textIndex+2;i++){ret.push(HEAP8[i>>0])}}}textIndex+=2}else{ret.push(curr);textIndex+=1}}return ret}function traverseStack(args){if(!args||!args.callee||!args.callee.name){return[null,"",""]}var funstr=args.callee.toString();var funcname=args.callee.name;var str="(";var first=true;for(var i in args){var a=args[i];if(!first){str+=", "}first=false;if(typeof a=="number"||typeof a=="string"){str+=a}else{str+="("+typeof a+")"}}str+=")";var caller=args.callee.caller;args=caller?caller.arguments:[];if(first)str="";return[args,funcname,str]}function _emscripten_get_callstack_js(flags){var callstack=jsStackTrace();var iThisFunc=callstack.lastIndexOf("_emscripten_log");var iThisFunc2=callstack.lastIndexOf("_emscripten_get_callstack");var iNextLine=callstack.indexOf("\n",Math.max(iThisFunc,iThisFunc2))+1;callstack=callstack.slice(iNextLine);if(flags&32){warnOnce("EM_LOG_DEMANGLE is deprecated; ignoring")}if(flags&8&&typeof emscripten_source_map=="undefined"){warnOnce('Source map information is not available, emscripten_log with EM_LOG_C_STACK will be ignored. Build with "--pre-js $EMSCRIPTEN/src/emscripten-source-map.min.js" linker flag to add source map loading to code.');flags^=8;flags|=16}var stack_args=null;if(flags&128){stack_args=traverseStack(arguments);while(stack_args[1].includes("_emscripten_"))stack_args=traverseStack(stack_args[0])}var lines=callstack.split("\n");callstack="";var newFirefoxRe=new RegExp("\\s*(.*?)@(.*?):([0-9]+):([0-9]+)");var firefoxRe=new RegExp("\\s*(.*?)@(.*):(.*)(:(.*))?");var chromeRe=new RegExp("\\s*at (.*?) \\((.*):(.*):(.*)\\)");for(var l in lines){var line=lines[l];var symbolName="";var file="";var lineno=0;var column=0;var parts=chromeRe.exec(line);if(parts&&parts.length==5){symbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4]}else{parts=newFirefoxRe.exec(line);if(!parts)parts=firefoxRe.exec(line);if(parts&&parts.length>=4){symbolName=parts[1];file=parts[2];lineno=parts[3];column=parts[4]|0}else{callstack+=line+"\n";continue}}var haveSourceMap=false;if(flags&8){var orig=emscripten_source_map.originalPositionFor({line:lineno,column:column});haveSourceMap=orig&&orig.source;if(haveSourceMap){if(flags&64){orig.source=orig.source.substring(orig.source.replace(/\\/g,"/").lastIndexOf("/")+1)}callstack+="    at "+symbolName+" ("+orig.source+":"+orig.line+":"+orig.column+")\n"}}if(flags&16||!haveSourceMap){if(flags&64){file=file.substring(file.replace(/\\/g,"/").lastIndexOf("/")+1)}callstack+=(haveSourceMap?"     = "+symbolName:"    at "+symbolName)+" ("+file+":"+lineno+":"+column+")\n"}if(flags&128&&stack_args[0]){if(stack_args[1]==symbolName&&stack_args[2].length>0){callstack=callstack.replace(/\s+$/,"");callstack+=" with values: "+stack_args[1]+stack_args[2]+"\n"}stack_args=traverseStack(stack_args[0])}}callstack=callstack.replace(/\s+$/,"");return callstack}function _emscripten_log_js(flags,str){if(flags&24){str=str.replace(/\s+$/,"");str+=(str.length>0?"\n":"")+_emscripten_get_callstack_js(flags)}if(flags&1){if(flags&4){console.error(str)}else if(flags&2){console.warn(str)}else if(flags&512){console.info(str)}else if(flags&256){console.debug(str)}else{console.log(str)}}else if(flags&6){err(str)}else{out(str)}}function _emscripten_log(flags,format,varargs){var result=formatString(format,varargs);var str=UTF8ArrayToString(result,0);_emscripten_log_js(flags,str)}function _emscripten_memcpy_big(dest,src,num){HEAPU8.copyWithin(dest,src,src+num)}function doRequestFullscreen(target,strategy){if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;if(!target.requestFullscreen&&!target.webkitRequestFullscreen){return-3}var canPerformRequests=JSEvents.canPerformEventHandlerRequests();if(!canPerformRequests){if(strategy.deferUntilInEventHandler){JSEvents.deferCall(_JSEvents_requestFullscreen,1,[target,strategy]);return 1}else{return-2}}return _JSEvents_requestFullscreen(target,strategy)}function _emscripten_request_fullscreen(target,deferUntilInEventHandler){var strategy={scaleMode:0,canvasResolutionScaleMode:0,filteringMode:0,deferUntilInEventHandler:deferUntilInEventHandler,canvasResizedCallbackTargetThread:2};return doRequestFullscreen(target,strategy)}function _emscripten_request_pointerlock(target,deferUntilInEventHandler){target=findEventTarget(target);if(!target)return-4;if(!target.requestPointerLock&&!target.msRequestPointerLock){return-1}var canPerformRequests=JSEvents.canPerformEventHandlerRequests();if(!canPerformRequests){if(deferUntilInEventHandler){JSEvents.deferCall(requestPointerLock,2,[target]);return 1}else{return-2}}return requestPointerLock(target)}function emscripten_realloc_buffer(size){try{wasmMemory.grow(size-buffer.byteLength+65535>>>16);updateGlobalBufferAndViews(wasmMemory.buffer);return 1}catch(e){}}function _emscripten_resize_heap(requestedSize){var oldSize=HEAPU8.length;requestedSize=requestedSize>>>0;var maxHeapSize=_emscripten_get_heap_max();if(requestedSize>maxHeapSize){return false}let alignUp=(x,multiple)=>x+(multiple-x%multiple)%multiple;for(var cutDown=1;cutDown<=4;cutDown*=2){var overGrownHeapSize=oldSize*(1+.2/cutDown);overGrownHeapSize=Math.min(overGrownHeapSize,requestedSize+100663296);var newSize=Math.min(maxHeapSize,alignUp(Math.max(requestedSize,overGrownHeapSize),65536));var replacement=emscripten_realloc_buffer(newSize);if(replacement){return true}}return false}function _emscripten_sample_gamepad_data(){try{if(navigator.getGamepads)return(JSEvents.lastGamepadState=navigator.getGamepads())?0:-1}catch(e){navigator.getGamepads=null}return-1}function registerFocusEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.focusEvent)JSEvents.focusEvent=_malloc(256);var focusEventHandlerFunc=function(ev){var e=ev||event;var nodeName=JSEvents.getNodeNameForTarget(e.target);var id=e.target.id?e.target.id:"";var focusEvent=JSEvents.focusEvent;stringToUTF8(nodeName,focusEvent+0,128);stringToUTF8(id,focusEvent+128,128);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,focusEvent,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:focusEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_blur_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerFocusEventCallback(target,userData,useCapture,callbackfunc,12,"blur",targetThread);return 0}function _emscripten_set_focus_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerFocusEventCallback(target,userData,useCapture,callbackfunc,13,"focus",targetThread);return 0}function registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.fullscreenChangeEvent)JSEvents.fullscreenChangeEvent=_malloc(280);var fullscreenChangeEventhandlerFunc=function(ev){var e=ev||event;var fullscreenChangeEvent=JSEvents.fullscreenChangeEvent;fillFullscreenChangeEventData(fullscreenChangeEvent);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,fullscreenChangeEvent,userData))e.preventDefault()};var eventHandler={target:target,eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:fullscreenChangeEventhandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_fullscreenchange_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){if(!JSEvents.fullscreenEnabled())return-1;target=findEventTarget(target);if(!target)return-4;registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"fullscreenchange",targetThread);registerFullscreenChangeEventCallback(target,userData,useCapture,callbackfunc,19,"webkitfullscreenchange",targetThread);return 0}function registerGamepadEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.gamepadEvent)JSEvents.gamepadEvent=_malloc(1432);var gamepadEventHandlerFunc=function(ev){var e=ev||event;var gamepadEvent=JSEvents.gamepadEvent;fillGamepadEventData(gamepadEvent,e["gamepad"]);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,gamepadEvent,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),allowsDeferredCalls:true,eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:gamepadEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_gamepadconnected_callback_on_thread(userData,useCapture,callbackfunc,targetThread){if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,26,"gamepadconnected",targetThread)}function _emscripten_set_gamepaddisconnected_callback_on_thread(userData,useCapture,callbackfunc,targetThread){if(_emscripten_sample_gamepad_data())return-1;return registerGamepadEventCallback(2,userData,useCapture,callbackfunc,27,"gamepaddisconnected",targetThread)}function _emscripten_set_interval(cb,msecs,userData){return setInterval(function(){callUserCallback(function(){(function(a1){dynCall_vi.apply(null,[cb,a1])})(userData)})},msecs)}function registerKeyEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.keyEvent)JSEvents.keyEvent=_malloc(176);var keyEventHandlerFunc=function(e){var keyEventData=JSEvents.keyEvent;HEAPF64[keyEventData>>3]=e.timeStamp;var idx=keyEventData>>2;HEAP32[idx+2]=e.location;HEAP32[idx+3]=e.ctrlKey;HEAP32[idx+4]=e.shiftKey;HEAP32[idx+5]=e.altKey;HEAP32[idx+6]=e.metaKey;HEAP32[idx+7]=e.repeat;HEAP32[idx+8]=e.charCode;HEAP32[idx+9]=e.keyCode;HEAP32[idx+10]=e.which;stringToUTF8(e.key||"",keyEventData+44,32);stringToUTF8(e.code||"",keyEventData+76,32);stringToUTF8(e.char||"",keyEventData+108,32);stringToUTF8(e.locale||"",keyEventData+140,32);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,keyEventData,userData))e.preventDefault()};var eventHandler={target:findEventTarget(target),allowsDeferredCalls:true,eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:keyEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_keydown_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerKeyEventCallback(target,userData,useCapture,callbackfunc,2,"keydown",targetThread);return 0}function _emscripten_set_keypress_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerKeyEventCallback(target,userData,useCapture,callbackfunc,1,"keypress",targetThread);return 0}function _emscripten_set_keyup_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerKeyEventCallback(target,userData,useCapture,callbackfunc,3,"keyup",targetThread);return 0}function _emscripten_set_main_loop(func,fps,simulateInfiniteLoop){var browserIterationFunc=function(){dynCall_v.call(null,func)};setMainLoop(browserIterationFunc,fps,simulateInfiniteLoop)}function fillMouseEventData(eventStruct,e,target){HEAPF64[eventStruct>>3]=e.timeStamp;var idx=eventStruct>>2;HEAP32[idx+2]=e.screenX;HEAP32[idx+3]=e.screenY;HEAP32[idx+4]=e.clientX;HEAP32[idx+5]=e.clientY;HEAP32[idx+6]=e.ctrlKey;HEAP32[idx+7]=e.shiftKey;HEAP32[idx+8]=e.altKey;HEAP32[idx+9]=e.metaKey;HEAP16[idx*2+20]=e.button;HEAP16[idx*2+21]=e.buttons;HEAP32[idx+11]=e["movementX"];HEAP32[idx+12]=e["movementY"];var rect=getBoundingClientRect(target);HEAP32[idx+13]=e.clientX-rect.left;HEAP32[idx+14]=e.clientY-rect.top}function registerMouseEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.mouseEvent)JSEvents.mouseEvent=_malloc(72);target=findEventTarget(target);var mouseEventHandlerFunc=function(ev){var e=ev||event;fillMouseEventData(JSEvents.mouseEvent,e,target);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,JSEvents.mouseEvent,userData))e.preventDefault()};var eventHandler={target:target,allowsDeferredCalls:eventTypeString!="mousemove"&&eventTypeString!="mouseenter"&&eventTypeString!="mouseleave",eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:mouseEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_mousedown_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerMouseEventCallback(target,userData,useCapture,callbackfunc,5,"mousedown",targetThread);return 0}function _emscripten_set_mousemove_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerMouseEventCallback(target,userData,useCapture,callbackfunc,8,"mousemove",targetThread);return 0}function _emscripten_set_mouseup_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerMouseEventCallback(target,userData,useCapture,callbackfunc,6,"mouseup",targetThread);return 0}function fillPointerlockChangeEventData(eventStruct){var pointerLockElement=document.pointerLockElement||document.mozPointerLockElement||document.webkitPointerLockElement||document.msPointerLockElement;var isPointerlocked=!!pointerLockElement;HEAP32[eventStruct>>2]=isPointerlocked;var nodeName=JSEvents.getNodeNameForTarget(pointerLockElement);var id=pointerLockElement&&pointerLockElement.id?pointerLockElement.id:"";stringToUTF8(nodeName,eventStruct+4,128);stringToUTF8(id,eventStruct+132,128)}function registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.pointerlockChangeEvent)JSEvents.pointerlockChangeEvent=_malloc(260);var pointerlockChangeEventHandlerFunc=function(ev){var e=ev||event;var pointerlockChangeEvent=JSEvents.pointerlockChangeEvent;fillPointerlockChangeEventData(pointerlockChangeEvent);if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,pointerlockChangeEvent,userData))e.preventDefault()};var eventHandler={target:target,eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:pointerlockChangeEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_pointerlockchange_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){if(!document||!document.body||!document.body.requestPointerLock&&!document.body.mozRequestPointerLock&&!document.body.webkitRequestPointerLock&&!document.body.msRequestPointerLock){return-1}target=findEventTarget(target);if(!target)return-4;registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"pointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mozpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"webkitpointerlockchange",targetThread);registerPointerlockChangeEventCallback(target,userData,useCapture,callbackfunc,20,"mspointerlockchange",targetThread);return 0}function registerTouchEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.touchEvent)JSEvents.touchEvent=_malloc(1696);target=findEventTarget(target);var touchEventHandlerFunc=function(e){var t,touches={},et=e.touches;for(var i=0;i<et.length;++i){t=et[i];t.isChanged=t.onTarget=0;touches[t.identifier]=t}for(var i=0;i<e.changedTouches.length;++i){t=e.changedTouches[i];t.isChanged=1;touches[t.identifier]=t}for(var i=0;i<e.targetTouches.length;++i){touches[e.targetTouches[i].identifier].onTarget=1}var touchEvent=JSEvents.touchEvent;var idx=touchEvent>>2;HEAP32[idx+3]=e.ctrlKey;HEAP32[idx+4]=e.shiftKey;HEAP32[idx+5]=e.altKey;HEAP32[idx+6]=e.metaKey;idx+=7;var targetRect=getBoundingClientRect(target);var numTouches=0;for(var i in touches){var t=touches[i];HEAP32[idx+0]=t.identifier;HEAP32[idx+1]=t.screenX;HEAP32[idx+2]=t.screenY;HEAP32[idx+3]=t.clientX;HEAP32[idx+4]=t.clientY;HEAP32[idx+5]=t.pageX;HEAP32[idx+6]=t.pageY;HEAP32[idx+7]=t.isChanged;HEAP32[idx+8]=t.onTarget;HEAP32[idx+9]=t.clientX-targetRect.left;HEAP32[idx+10]=t.clientY-targetRect.top;idx+=13;if(++numTouches>31){break}}HEAP32[touchEvent+8>>2]=numTouches;if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,touchEvent,userData))e.preventDefault()};var eventHandler={target:target,allowsDeferredCalls:eventTypeString=="touchstart"||eventTypeString=="touchend",eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:touchEventHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_touchcancel_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerTouchEventCallback(target,userData,useCapture,callbackfunc,25,"touchcancel",targetThread);return 0}function _emscripten_set_touchend_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerTouchEventCallback(target,userData,useCapture,callbackfunc,23,"touchend",targetThread);return 0}function _emscripten_set_touchmove_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerTouchEventCallback(target,userData,useCapture,callbackfunc,24,"touchmove",targetThread);return 0}function _emscripten_set_touchstart_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){registerTouchEventCallback(target,userData,useCapture,callbackfunc,22,"touchstart",targetThread);return 0}function registerWheelEventCallback(target,userData,useCapture,callbackfunc,eventTypeId,eventTypeString,targetThread){if(!JSEvents.wheelEvent)JSEvents.wheelEvent=_malloc(104);var wheelHandlerFunc=function(ev){var e=ev||event;var wheelEvent=JSEvents.wheelEvent;fillMouseEventData(wheelEvent,e,target);HEAPF64[wheelEvent+72>>3]=e["deltaX"];HEAPF64[wheelEvent+80>>3]=e["deltaY"];HEAPF64[wheelEvent+88>>3]=e["deltaZ"];HEAP32[wheelEvent+96>>2]=e["deltaMode"];if(function(a1,a2,a3){return dynCall_iiii.apply(null,[callbackfunc,a1,a2,a3])}(eventTypeId,wheelEvent,userData))e.preventDefault()};var eventHandler={target:target,allowsDeferredCalls:true,eventTypeString:eventTypeString,callbackfunc:callbackfunc,handlerFunc:wheelHandlerFunc,useCapture:useCapture};JSEvents.registerOrRemoveHandler(eventHandler)}function _emscripten_set_wheel_callback_on_thread(target,userData,useCapture,callbackfunc,targetThread){target=findEventTarget(target);if(typeof target.onwheel!="undefined"){registerWheelEventCallback(target,userData,useCapture,callbackfunc,9,"wheel",targetThread);return 0}else{return-1}}function __webgl_enable_ANGLE_instanced_arrays(ctx){var ext=ctx.getExtension("ANGLE_instanced_arrays");if(ext){ctx["vertexAttribDivisor"]=function(index,divisor){ext["vertexAttribDivisorANGLE"](index,divisor)};ctx["drawArraysInstanced"]=function(mode,first,count,primcount){ext["drawArraysInstancedANGLE"](mode,first,count,primcount)};ctx["drawElementsInstanced"]=function(mode,count,type,indices,primcount){ext["drawElementsInstancedANGLE"](mode,count,type,indices,primcount)};return 1}}function __webgl_enable_OES_vertex_array_object(ctx){var ext=ctx.getExtension("OES_vertex_array_object");if(ext){ctx["createVertexArray"]=function(){return ext["createVertexArrayOES"]()};ctx["deleteVertexArray"]=function(vao){ext["deleteVertexArrayOES"](vao)};ctx["bindVertexArray"]=function(vao){ext["bindVertexArrayOES"](vao)};ctx["isVertexArray"]=function(vao){return ext["isVertexArrayOES"](vao)};return 1}}function __webgl_enable_WEBGL_draw_buffers(ctx){var ext=ctx.getExtension("WEBGL_draw_buffers");if(ext){ctx["drawBuffers"]=function(n,bufs){ext["drawBuffersWEBGL"](n,bufs)};return 1}}function __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(ctx){return!!(ctx.dibvbi=ctx.getExtension("WEBGL_draw_instanced_base_vertex_base_instance"))}function __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(ctx){return!!(ctx.mdibvbi=ctx.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance"))}function __webgl_enable_WEBGL_multi_draw(ctx){return!!(ctx.multiDrawWebgl=ctx.getExtension("WEBGL_multi_draw"))}var GL={counter:1,buffers:[],mappedBuffers:{},programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],samplers:[],transformFeedbacks:[],syncs:[],byteSizeByTypeRoot:5120,byteSizeByType:[1,1,2,2,4,4,4,2,3,4,8],stringCache:{},stringiCache:{},unpackAlignment:4,recordError:function recordError(errorCode){if(!GL.lastError){GL.lastError=errorCode}},getNewId:function(table){var ret=GL.counter++;for(var i=table.length;i<ret;i++){table[i]=null}return ret},MAX_TEMP_BUFFER_SIZE:2097152,numTempVertexBuffersPerSize:64,log2ceilLookup:function(i){return 32-Math.clz32(i===0?0:i-1)},generateTempBuffers:function(quads,context){var largestIndex=GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);context.tempVertexBufferCounters1=[];context.tempVertexBufferCounters2=[];context.tempVertexBufferCounters1.length=context.tempVertexBufferCounters2.length=largestIndex+1;context.tempVertexBuffers1=[];context.tempVertexBuffers2=[];context.tempVertexBuffers1.length=context.tempVertexBuffers2.length=largestIndex+1;context.tempIndexBuffers=[];context.tempIndexBuffers.length=largestIndex+1;for(var i=0;i<=largestIndex;++i){context.tempIndexBuffers[i]=null;context.tempVertexBufferCounters1[i]=context.tempVertexBufferCounters2[i]=0;var ringbufferLength=GL.numTempVertexBuffersPerSize;context.tempVertexBuffers1[i]=[];context.tempVertexBuffers2[i]=[];var ringbuffer1=context.tempVertexBuffers1[i];var ringbuffer2=context.tempVertexBuffers2[i];ringbuffer1.length=ringbuffer2.length=ringbufferLength;for(var j=0;j<ringbufferLength;++j){ringbuffer1[j]=ringbuffer2[j]=null}}if(quads){context.tempQuadIndexBuffer=GLctx.createBuffer();context.GLctx.bindBuffer(34963,context.tempQuadIndexBuffer);var numIndexes=GL.MAX_TEMP_BUFFER_SIZE>>1;var quadIndexes=new Uint16Array(numIndexes);var i=0,v=0;while(1){quadIndexes[i++]=v;if(i>=numIndexes)break;quadIndexes[i++]=v+1;if(i>=numIndexes)break;quadIndexes[i++]=v+2;if(i>=numIndexes)break;quadIndexes[i++]=v;if(i>=numIndexes)break;quadIndexes[i++]=v+2;if(i>=numIndexes)break;quadIndexes[i++]=v+3;if(i>=numIndexes)break;v+=4}context.GLctx.bufferData(34963,quadIndexes,35044);context.GLctx.bindBuffer(34963,null)}},getTempVertexBuffer:function getTempVertexBuffer(sizeBytes){var idx=GL.log2ceilLookup(sizeBytes);var ringbuffer=GL.currentContext.tempVertexBuffers1[idx];var nextFreeBufferIndex=GL.currentContext.tempVertexBufferCounters1[idx];GL.currentContext.tempVertexBufferCounters1[idx]=GL.currentContext.tempVertexBufferCounters1[idx]+1&GL.numTempVertexBuffersPerSize-1;var vbo=ringbuffer[nextFreeBufferIndex];if(vbo){return vbo}var prevVBO=GLctx.getParameter(34964);ringbuffer[nextFreeBufferIndex]=GLctx.createBuffer();GLctx.bindBuffer(34962,ringbuffer[nextFreeBufferIndex]);GLctx.bufferData(34962,1<<idx,35048);GLctx.bindBuffer(34962,prevVBO);return ringbuffer[nextFreeBufferIndex]},getTempIndexBuffer:function getTempIndexBuffer(sizeBytes){var idx=GL.log2ceilLookup(sizeBytes);var ibo=GL.currentContext.tempIndexBuffers[idx];if(ibo){return ibo}var prevIBO=GLctx.getParameter(34965);GL.currentContext.tempIndexBuffers[idx]=GLctx.createBuffer();GLctx.bindBuffer(34963,GL.currentContext.tempIndexBuffers[idx]);GLctx.bufferData(34963,1<<idx,35048);GLctx.bindBuffer(34963,prevIBO);return GL.currentContext.tempIndexBuffers[idx]},newRenderingFrameStarted:function newRenderingFrameStarted(){if(!GL.currentContext){return}var vb=GL.currentContext.tempVertexBuffers1;GL.currentContext.tempVertexBuffers1=GL.currentContext.tempVertexBuffers2;GL.currentContext.tempVertexBuffers2=vb;vb=GL.currentContext.tempVertexBufferCounters1;GL.currentContext.tempVertexBufferCounters1=GL.currentContext.tempVertexBufferCounters2;GL.currentContext.tempVertexBufferCounters2=vb;var largestIndex=GL.log2ceilLookup(GL.MAX_TEMP_BUFFER_SIZE);for(var i=0;i<=largestIndex;++i){GL.currentContext.tempVertexBufferCounters1[i]=0}},getSource:function(shader,count,string,length){var source="";for(var i=0;i<count;++i){var len=length?HEAP32[length+i*4>>2]:-1;source+=UTF8ToString(HEAP32[string+i*4>>2],len<0?undefined:len)}return source},calcBufLength:function calcBufLength(size,type,stride,count){if(stride>0){return count*stride}var typeSize=GL.byteSizeByType[type-GL.byteSizeByTypeRoot];return size*typeSize*count},usedTempBuffers:[],preDrawHandleClientVertexAttribBindings:function preDrawHandleClientVertexAttribBindings(count){GL.resetBufferBinding=false;for(var i=0;i<GL.currentContext.maxVertexAttribs;++i){var cb=GL.currentContext.clientBuffers[i];if(!cb.clientside||!cb.enabled)continue;GL.resetBufferBinding=true;var size=GL.calcBufLength(cb.size,cb.type,cb.stride,count);var buf=GL.getTempVertexBuffer(size);GLctx.bindBuffer(34962,buf);GLctx.bufferSubData(34962,0,HEAPU8.subarray(cb.ptr,cb.ptr+size));cb.vertexAttribPointerAdaptor.call(GLctx,i,cb.size,cb.type,cb.normalized,cb.stride,0)}},postDrawHandleClientVertexAttribBindings:function postDrawHandleClientVertexAttribBindings(){if(GL.resetBufferBinding){GLctx.bindBuffer(34962,GL.buffers[GLctx.currentArrayBufferBinding])}},createContext:function(canvas,webGLContextAttributes){if(!canvas.getContextSafariWebGL2Fixed){canvas.getContextSafariWebGL2Fixed=canvas.getContext;function fixedGetContext(ver,attrs){var gl=canvas.getContextSafariWebGL2Fixed(ver,attrs);return ver=="webgl"==gl instanceof WebGLRenderingContext?gl:null}canvas.getContext=fixedGetContext}var ctx=webGLContextAttributes.majorVersion>1?canvas.getContext("webgl2",webGLContextAttributes):canvas.getContext("webgl",webGLContextAttributes);if(!ctx)return 0;var handle=GL.registerContext(ctx,webGLContextAttributes);return handle},registerContext:function(ctx,webGLContextAttributes){var handle=GL.getNewId(GL.contexts);var context={handle:handle,attributes:webGLContextAttributes,version:webGLContextAttributes.majorVersion,GLctx:ctx};if(ctx.canvas)ctx.canvas.GLctxObject=context;GL.contexts[handle]=context;if(typeof webGLContextAttributes.enableExtensionsByDefault=="undefined"||webGLContextAttributes.enableExtensionsByDefault){GL.initExtensions(context)}context.maxVertexAttribs=context.GLctx.getParameter(34921);context.clientBuffers=[];for(var i=0;i<context.maxVertexAttribs;i++){context.clientBuffers[i]={enabled:false,clientside:false,size:0,type:0,normalized:0,stride:0,ptr:0,vertexAttribPointerAdaptor:null}}GL.generateTempBuffers(false,context);return handle},makeContextCurrent:function(contextHandle){GL.currentContext=GL.contexts[contextHandle];Module.ctx=GLctx=GL.currentContext&&GL.currentContext.GLctx;return!(contextHandle&&!GLctx)},getContext:function(contextHandle){return GL.contexts[contextHandle]},deleteContext:function(contextHandle){if(GL.currentContext===GL.contexts[contextHandle])GL.currentContext=null;if(typeof JSEvents=="object")JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas);if(GL.contexts[contextHandle]&&GL.contexts[contextHandle].GLctx.canvas)GL.contexts[contextHandle].GLctx.canvas.GLctxObject=undefined;GL.contexts[contextHandle]=null},initExtensions:function(context){if(!context)context=GL.currentContext;if(context.initExtensionsDone)return;context.initExtensionsDone=true;var GLctx=context.GLctx;__webgl_enable_ANGLE_instanced_arrays(GLctx);__webgl_enable_OES_vertex_array_object(GLctx);__webgl_enable_WEBGL_draw_buffers(GLctx);__webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);__webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);if(context.version>=2){GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query_webgl2")}if(context.version<2||!GLctx.disjointTimerQueryExt){GLctx.disjointTimerQueryExt=GLctx.getExtension("EXT_disjoint_timer_query")}__webgl_enable_WEBGL_multi_draw(GLctx);var exts=GLctx.getSupportedExtensions()||[];exts.forEach(function(ext){if(!ext.includes("lose_context")&&!ext.includes("debug")){GLctx.getExtension(ext)}})}};var __emscripten_webgl_power_preferences=["default","low-power","high-performance"];function _emscripten_webgl_do_create_context(target,attributes){var a=attributes>>2;var powerPreference=HEAP32[a+(24>>2)];var contextAttributes={"alpha":!!HEAP32[a+(0>>2)],"depth":!!HEAP32[a+(4>>2)],"stencil":!!HEAP32[a+(8>>2)],"antialias":!!HEAP32[a+(12>>2)],"premultipliedAlpha":!!HEAP32[a+(16>>2)],"preserveDrawingBuffer":!!HEAP32[a+(20>>2)],"powerPreference":__emscripten_webgl_power_preferences[powerPreference],"failIfMajorPerformanceCaveat":!!HEAP32[a+(28>>2)],majorVersion:HEAP32[a+(32>>2)],minorVersion:HEAP32[a+(36>>2)],enableExtensionsByDefault:HEAP32[a+(40>>2)],explicitSwapControl:HEAP32[a+(44>>2)],proxyContextToMainThread:HEAP32[a+(48>>2)],renderViaOffscreenBackBuffer:HEAP32[a+(52>>2)]};var canvas=findCanvasEventTarget(target);if(!canvas){return 0}if(contextAttributes.explicitSwapControl){return 0}var contextHandle=GL.createContext(canvas,contextAttributes);return contextHandle}function _emscripten_webgl_create_context(a0,a1){return _emscripten_webgl_do_create_context(a0,a1)}function _emscripten_webgl_destroy_context(contextHandle){if(GL.currentContext==contextHandle)GL.currentContext=0;GL.deleteContext(contextHandle)}function _emscripten_webgl_enable_extension(contextHandle,extension){var context=GL.getContext(contextHandle);var extString=UTF8ToString(extension);if(extString.startsWith("GL_"))extString=extString.substr(3);if(extString=="ANGLE_instanced_arrays")__webgl_enable_ANGLE_instanced_arrays(GLctx);if(extString=="OES_vertex_array_object")__webgl_enable_OES_vertex_array_object(GLctx);if(extString=="WEBGL_draw_buffers")__webgl_enable_WEBGL_draw_buffers(GLctx);if(extString=="WEBGL_draw_instanced_base_vertex_base_instance")__webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);if(extString=="WEBGL_multi_draw_instanced_base_vertex_base_instance")__webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);if(extString=="WEBGL_multi_draw")__webgl_enable_WEBGL_multi_draw(GLctx);var ext=context.GLctx.getExtension(extString);return!!ext}function _emscripten_webgl_do_get_current_context(){return GL.currentContext?GL.currentContext.handle:0}function _emscripten_webgl_get_current_context(){return _emscripten_webgl_do_get_current_context()}function _emscripten_webgl_init_context_attributes(attributes){var a=attributes>>2;for(var i=0;i<56>>2;++i){HEAP32[a+i]=0}HEAP32[a+(0>>2)]=HEAP32[a+(4>>2)]=HEAP32[a+(12>>2)]=HEAP32[a+(16>>2)]=HEAP32[a+(32>>2)]=HEAP32[a+(40>>2)]=1}function _emscripten_webgl_make_context_current(contextHandle){var success=GL.makeContextCurrent(contextHandle);return success?0:-5}var ENV={};function getExecutableName(){return thisProgram||"./this.program"}function getEnvStrings(){if(!getEnvStrings.strings){var lang=(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8";var env={"USER":"web_user","LOGNAME":"web_user","PATH":"/","PWD":"/","HOME":"/home/web_user","LANG":lang,"_":getExecutableName()};for(var x in ENV){if(ENV[x]===undefined)delete env[x];else env[x]=ENV[x]}var strings=[];for(var x in env){strings.push(x+"="+env[x])}getEnvStrings.strings=strings}return getEnvStrings.strings}function _environ_get(__environ,environ_buf){var bufSize=0;getEnvStrings().forEach(function(string,i){var ptr=environ_buf+bufSize;HEAP32[__environ+i*4>>2]=ptr;writeAsciiToMemory(string,ptr);bufSize+=string.length+1});return 0}function _environ_sizes_get(penviron_count,penviron_buf_size){var strings=getEnvStrings();HEAP32[penviron_count>>2]=strings.length;var bufSize=0;strings.forEach(function(string){bufSize+=string.length+1});HEAP32[penviron_buf_size>>2]=bufSize;return 0}function _fd_close(fd){try{var stream=SYSCALLS.getStreamFromFD(fd);FS.close(stream);return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_fdstat_get(fd,pbuf){try{var stream=SYSCALLS.getStreamFromFD(fd);var type=stream.tty?2:FS.isDir(stream.mode)?3:FS.isLink(stream.mode)?7:4;HEAP8[pbuf>>0]=type;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_read(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doReadv(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_seek(fd,offset_low,offset_high,whence,newOffset){try{var stream=SYSCALLS.getStreamFromFD(fd);var HIGH_OFFSET=4294967296;var offset=offset_high*HIGH_OFFSET+(offset_low>>>0);var DOUBLE_LIMIT=9007199254740992;if(offset<=-DOUBLE_LIMIT||offset>=DOUBLE_LIMIT){return-61}FS.llseek(stream,offset,whence);tempI64=[stream.position>>>0,(tempDouble=stream.position,+Math.abs(tempDouble)>=1?tempDouble>0?(Math.min(+Math.floor(tempDouble/4294967296),4294967295)|0)>>>0:~~+Math.ceil((tempDouble-+(~~tempDouble>>>0))/4294967296)>>>0:0)],HEAP32[newOffset>>2]=tempI64[0],HEAP32[newOffset+4>>2]=tempI64[1];if(stream.getdents&&offset===0&&whence===0)stream.getdents=null;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _fd_write(fd,iov,iovcnt,pnum){try{var stream=SYSCALLS.getStreamFromFD(fd);var num=SYSCALLS.doWritev(stream,iov,iovcnt);HEAP32[pnum>>2]=num;return 0}catch(e){if(typeof FS=="undefined"||!(e instanceof FS.ErrnoError))throw e;return e.errno}}function _getTempRet0(){return getTempRet0()}function _getaddrinfo(node,service,hint,out){var addr=0;var port=0;var flags=0;var family=0;var type=0;var proto=0;var ai;function allocaddrinfo(family,type,proto,canon,addr,port){var sa,salen,ai;var errno;salen=family===10?28:16;addr=family===10?inetNtop6(addr):inetNtop4(addr);sa=_malloc(salen);errno=writeSockaddr(sa,family,addr,port);assert(!errno);ai=_malloc(32);HEAP32[ai+4>>2]=family;HEAP32[ai+8>>2]=type;HEAP32[ai+12>>2]=proto;HEAP32[ai+24>>2]=canon;HEAP32[ai+20>>2]=sa;if(family===10){HEAP32[ai+16>>2]=28}else{HEAP32[ai+16>>2]=16}HEAP32[ai+28>>2]=0;return ai}if(hint){flags=HEAP32[hint>>2];family=HEAP32[hint+4>>2];type=HEAP32[hint+8>>2];proto=HEAP32[hint+12>>2]}if(type&&!proto){proto=type===2?17:6}if(!type&&proto){type=proto===17?2:1}if(proto===0){proto=6}if(type===0){type=1}if(!node&&!service){return-2}if(flags&~(1|2|4|1024|8|16|32)){return-1}if(hint!==0&&HEAP32[hint>>2]&2&&!node){return-1}if(flags&32){return-2}if(type!==0&&type!==1&&type!==2){return-7}if(family!==0&&family!==2&&family!==10){return-6}if(service){service=UTF8ToString(service);port=parseInt(service,10);if(isNaN(port)){if(flags&1024){return-2}return-8}}if(!node){if(family===0){family=2}if((flags&1)===0){if(family===2){addr=_htonl(2130706433)}else{addr=[0,0,0,1]}}ai=allocaddrinfo(family,type,proto,null,addr,port);HEAP32[out>>2]=ai;return 0}node=UTF8ToString(node);addr=inetPton4(node);if(addr!==null){if(family===0||family===2){family=2}else if(family===10&&flags&8){addr=[0,0,_htonl(65535),addr];family=10}else{return-2}}else{addr=inetPton6(node);if(addr!==null){if(family===0||family===10){family=10}else{return-2}}}if(addr!=null){ai=allocaddrinfo(family,type,proto,node,addr,port);HEAP32[out>>2]=ai;return 0}if(flags&4){return-2}node=DNS.lookup_name(node);addr=inetPton4(node);if(family===0){family=2}else if(family===10){addr=[0,0,_htonl(65535),addr]}ai=allocaddrinfo(family,type,proto,null,addr,port);HEAP32[out>>2]=ai;return 0}function getHostByName(name){var ret=_malloc(20);var nameBuf=_malloc(name.length+1);stringToUTF8(name,nameBuf,name.length+1);HEAP32[ret>>2]=nameBuf;var aliasesBuf=_malloc(4);HEAP32[aliasesBuf>>2]=0;HEAP32[ret+4>>2]=aliasesBuf;var afinet=2;HEAP32[ret+8>>2]=afinet;HEAP32[ret+12>>2]=4;var addrListBuf=_malloc(12);HEAP32[addrListBuf>>2]=addrListBuf+8;HEAP32[addrListBuf+4>>2]=0;HEAP32[addrListBuf+8>>2]=inetPton4(DNS.lookup_name(name));HEAP32[ret+16>>2]=addrListBuf;return ret}function _gethostbyaddr(addr,addrlen,type){if(type!==2){setErrNo(5);return null}addr=HEAP32[addr>>2];var host=inetNtop4(addr);var lookup=DNS.lookup_addr(host);if(lookup){host=lookup}return getHostByName(host)}function _gethostbyname(name){return getHostByName(UTF8ToString(name))}function _getnameinfo(sa,salen,node,nodelen,serv,servlen,flags){var info=readSockaddr(sa,salen);if(info.errno){return-6}var port=info.port;var addr=info.addr;var overflowed=false;if(node&&nodelen){var lookup;if(flags&1||!(lookup=DNS.lookup_addr(addr))){if(flags&8){return-2}}else{addr=lookup}var numBytesWrittenExclNull=stringToUTF8(addr,node,nodelen);if(numBytesWrittenExclNull+1>=nodelen){overflowed=true}}if(serv&&servlen){port=""+port;var numBytesWrittenExclNull=stringToUTF8(port,serv,servlen);if(numBytesWrittenExclNull+1>=servlen){overflowed=true}}if(overflowed){return-12}return 0}function _glActiveTexture(x0){GLctx["activeTexture"](x0)}function _glAttachShader(program,shader){program=GL.programs[program];shader=GL.shaders[shader];program[shader.shaderType]=shader;GLctx.attachShader(program,shader)}function _glBeginQuery(target,id){GLctx["beginQuery"](target,GL.queries[id])}function _glBindAttribLocation(program,index,name){GLctx.bindAttribLocation(GL.programs[program],index,UTF8ToString(name))}function _glBindBuffer(target,buffer){if(target==34962){GLctx.currentArrayBufferBinding=buffer}else if(target==34963){GLctx.currentElementArrayBufferBinding=buffer}if(target==35051){GLctx.currentPixelPackBufferBinding=buffer}else if(target==35052){GLctx.currentPixelUnpackBufferBinding=buffer}GLctx.bindBuffer(target,GL.buffers[buffer])}function _glBindBufferBase(target,index,buffer){GLctx["bindBufferBase"](target,index,GL.buffers[buffer])}function _glBindBufferRange(target,index,buffer,offset,ptrsize){GLctx["bindBufferRange"](target,index,GL.buffers[buffer],offset,ptrsize)}function _glBindFramebuffer(target,framebuffer){GLctx.bindFramebuffer(target,GL.framebuffers[framebuffer])}function _glBindRenderbuffer(target,renderbuffer){GLctx.bindRenderbuffer(target,GL.renderbuffers[renderbuffer])}function _glBindSampler(unit,sampler){GLctx["bindSampler"](unit,GL.samplers[sampler])}function _glBindTexture(target,texture){GLctx.bindTexture(target,GL.textures[texture])}function _glBindVertexArray(vao){GLctx["bindVertexArray"](GL.vaos[vao]);var ibo=GLctx.getParameter(34965);GLctx.currentElementArrayBufferBinding=ibo?ibo.name|0:0}function _glBlendEquation(x0){GLctx["blendEquation"](x0)}function _glBlendEquationSeparate(x0,x1){GLctx["blendEquationSeparate"](x0,x1)}function _glBlendFuncSeparate(x0,x1,x2,x3){GLctx["blendFuncSeparate"](x0,x1,x2,x3)}function _glBlitFramebuffer(x0,x1,x2,x3,x4,x5,x6,x7,x8,x9){GLctx["blitFramebuffer"](x0,x1,x2,x3,x4,x5,x6,x7,x8,x9)}function _glBufferData(target,size,data,usage){if(GL.currentContext.version>=2){if(data){GLctx.bufferData(target,HEAPU8,usage,data,size)}else{GLctx.bufferData(target,size,usage)}}else{GLctx.bufferData(target,data?HEAPU8.subarray(data,data+size):size,usage)}}function _glBufferSubData(target,offset,size,data){if(GL.currentContext.version>=2){GLctx.bufferSubData(target,offset,HEAPU8,data,size);return}GLctx.bufferSubData(target,offset,HEAPU8.subarray(data,data+size))}function _glCheckFramebufferStatus(x0){return GLctx["checkFramebufferStatus"](x0)}function _glClear(x0){GLctx["clear"](x0)}function _glClearBufferfi(x0,x1,x2,x3){GLctx["clearBufferfi"](x0,x1,x2,x3)}function _glClearBufferfv(buffer,drawbuffer,value){GLctx["clearBufferfv"](buffer,drawbuffer,HEAPF32,value>>2)}function _glClearBufferuiv(buffer,drawbuffer,value){GLctx["clearBufferuiv"](buffer,drawbuffer,HEAPU32,value>>2)}function _glClearColor(x0,x1,x2,x3){GLctx["clearColor"](x0,x1,x2,x3)}function _glClearDepthf(x0){GLctx["clearDepth"](x0)}function _glClearStencil(x0){GLctx["clearStencil"](x0)}function _glClientWaitSync(sync,flags,timeoutLo,timeoutHi){return GLctx.clientWaitSync(GL.syncs[sync],flags,convertI32PairToI53(timeoutLo,timeoutHi))}function _glColorMask(red,green,blue,alpha){GLctx.colorMask(!!red,!!green,!!blue,!!alpha)}function _glCompileShader(shader){GLctx.compileShader(GL.shaders[shader])}function _glCompressedTexImage2D(target,level,internalFormat,width,height,border,imageSize,data){if(GL.currentContext.version>=2){if(GLctx.currentPixelUnpackBufferBinding){GLctx["compressedTexImage2D"](target,level,internalFormat,width,height,border,imageSize,data)}else{GLctx["compressedTexImage2D"](target,level,internalFormat,width,height,border,HEAPU8,data,imageSize)}return}GLctx["compressedTexImage2D"](target,level,internalFormat,width,height,border,data?HEAPU8.subarray(data,data+imageSize):null)}function _glCompressedTexImage3D(target,level,internalFormat,width,height,depth,border,imageSize,data){if(GLctx.currentPixelUnpackBufferBinding){GLctx["compressedTexImage3D"](target,level,internalFormat,width,height,depth,border,imageSize,data)}else{GLctx["compressedTexImage3D"](target,level,internalFormat,width,height,depth,border,HEAPU8,data,imageSize)}}function _glCompressedTexSubImage2D(target,level,xoffset,yoffset,width,height,format,imageSize,data){if(GL.currentContext.version>=2){if(GLctx.currentPixelUnpackBufferBinding){GLctx["compressedTexSubImage2D"](target,level,xoffset,yoffset,width,height,format,imageSize,data)}else{GLctx["compressedTexSubImage2D"](target,level,xoffset,yoffset,width,height,format,HEAPU8,data,imageSize)}return}GLctx["compressedTexSubImage2D"](target,level,xoffset,yoffset,width,height,format,data?HEAPU8.subarray(data,data+imageSize):null)}function _glCompressedTexSubImage3D(target,level,xoffset,yoffset,zoffset,width,height,depth,format,imageSize,data){if(GLctx.currentPixelUnpackBufferBinding){GLctx["compressedTexSubImage3D"](target,level,xoffset,yoffset,zoffset,width,height,depth,format,imageSize,data)}else{GLctx["compressedTexSubImage3D"](target,level,xoffset,yoffset,zoffset,width,height,depth,format,HEAPU8,data,imageSize)}}function _glCopyBufferSubData(x0,x1,x2,x3,x4){GLctx["copyBufferSubData"](x0,x1,x2,x3,x4)}function _glCopyTexImage2D(x0,x1,x2,x3,x4,x5,x6,x7){GLctx["copyTexImage2D"](x0,x1,x2,x3,x4,x5,x6,x7)}function _glCopyTexSubImage2D(x0,x1,x2,x3,x4,x5,x6,x7){GLctx["copyTexSubImage2D"](x0,x1,x2,x3,x4,x5,x6,x7)}function _glCreateProgram(){var id=GL.getNewId(GL.programs);var program=GLctx.createProgram();program.name=id;program.maxUniformLength=program.maxAttributeLength=program.maxUniformBlockNameLength=0;program.uniformIdCounter=1;GL.programs[id]=program;return id}function _glCreateShader(shaderType){var id=GL.getNewId(GL.shaders);GL.shaders[id]=GLctx.createShader(shaderType);GL.shaders[id].shaderType=shaderType&1?"vs":"fs";return id}function _glCullFace(x0){GLctx["cullFace"](x0)}function _glDeleteBuffers(n,buffers){for(var i=0;i<n;i++){var id=HEAP32[buffers+i*4>>2];var buffer=GL.buffers[id];if(!buffer)continue;GLctx.deleteBuffer(buffer);buffer.name=0;GL.buffers[id]=null;if(id==GLctx.currentArrayBufferBinding)GLctx.currentArrayBufferBinding=0;if(id==GLctx.currentElementArrayBufferBinding)GLctx.currentElementArrayBufferBinding=0;if(id==GLctx.currentPixelPackBufferBinding)GLctx.currentPixelPackBufferBinding=0;if(id==GLctx.currentPixelUnpackBufferBinding)GLctx.currentPixelUnpackBufferBinding=0}}function _glDeleteFramebuffers(n,framebuffers){for(var i=0;i<n;++i){var id=HEAP32[framebuffers+i*4>>2];var framebuffer=GL.framebuffers[id];if(!framebuffer)continue;GLctx.deleteFramebuffer(framebuffer);framebuffer.name=0;GL.framebuffers[id]=null}}function _glDeleteProgram(id){if(!id)return;var program=GL.programs[id];if(!program){GL.recordError(1281);return}GLctx.deleteProgram(program);program.name=0;GL.programs[id]=null}function _glDeleteQueries(n,ids){for(var i=0;i<n;i++){var id=HEAP32[ids+i*4>>2];var query=GL.queries[id];if(!query)continue;GLctx["deleteQuery"](query);GL.queries[id]=null}}function _glDeleteRenderbuffers(n,renderbuffers){for(var i=0;i<n;i++){var id=HEAP32[renderbuffers+i*4>>2];var renderbuffer=GL.renderbuffers[id];if(!renderbuffer)continue;GLctx.deleteRenderbuffer(renderbuffer);renderbuffer.name=0;GL.renderbuffers[id]=null}}function _glDeleteSamplers(n,samplers){for(var i=0;i<n;i++){var id=HEAP32[samplers+i*4>>2];var sampler=GL.samplers[id];if(!sampler)continue;GLctx["deleteSampler"](sampler);sampler.name=0;GL.samplers[id]=null}}function _glDeleteShader(id){if(!id)return;var shader=GL.shaders[id];if(!shader){GL.recordError(1281);return}GLctx.deleteShader(shader);GL.shaders[id]=null}function _glDeleteSync(id){if(!id)return;var sync=GL.syncs[id];if(!sync){GL.recordError(1281);return}GLctx.deleteSync(sync);sync.name=0;GL.syncs[id]=null}function _glDeleteTextures(n,textures){for(var i=0;i<n;i++){var id=HEAP32[textures+i*4>>2];var texture=GL.textures[id];if(!texture)continue;GLctx.deleteTexture(texture);texture.name=0;GL.textures[id]=null}}function _glDeleteVertexArrays(n,vaos){for(var i=0;i<n;i++){var id=HEAP32[vaos+i*4>>2];GLctx["deleteVertexArray"](GL.vaos[id]);GL.vaos[id]=null}}function _glDepthFunc(x0){GLctx["depthFunc"](x0)}function _glDepthMask(flag){GLctx.depthMask(!!flag)}function _glDetachShader(program,shader){GLctx.detachShader(GL.programs[program],GL.shaders[shader])}function _glDisable(x0){GLctx["disable"](x0)}function _glDisableVertexAttribArray(index){var cb=GL.currentContext.clientBuffers[index];cb.enabled=false;GLctx.disableVertexAttribArray(index)}function _glDrawArrays(mode,first,count){GL.preDrawHandleClientVertexAttribBindings(first+count);GLctx.drawArrays(mode,first,count);GL.postDrawHandleClientVertexAttribBindings()}function _glDrawArraysInstanced(mode,first,count,primcount){GLctx["drawArraysInstanced"](mode,first,count,primcount)}var tempFixedLengthArray=[];function _glDrawBuffers(n,bufs){var bufArray=tempFixedLengthArray[n];for(var i=0;i<n;i++){bufArray[i]=HEAP32[bufs+i*4>>2]}GLctx["drawBuffers"](bufArray)}function _glDrawElements(mode,count,type,indices){var buf;if(!GLctx.currentElementArrayBufferBinding){var size=GL.calcBufLength(1,type,0,count);buf=GL.getTempIndexBuffer(size);GLctx.bindBuffer(34963,buf);GLctx.bufferSubData(34963,0,HEAPU8.subarray(indices,indices+size));indices=0}GL.preDrawHandleClientVertexAttribBindings(count);GLctx.drawElements(mode,count,type,indices);GL.postDrawHandleClientVertexAttribBindings(count);if(!GLctx.currentElementArrayBufferBinding){GLctx.bindBuffer(34963,null)}}function _glDrawElementsInstanced(mode,count,type,indices,primcount){GLctx["drawElementsInstanced"](mode,count,type,indices,primcount)}function _glEnable(x0){GLctx["enable"](x0)}function _glEnableVertexAttribArray(index){var cb=GL.currentContext.clientBuffers[index];cb.enabled=true;GLctx.enableVertexAttribArray(index)}function _glEndQuery(x0){GLctx["endQuery"](x0)}function _glFenceSync(condition,flags){var sync=GLctx.fenceSync(condition,flags);if(sync){var id=GL.getNewId(GL.syncs);sync.name=id;GL.syncs[id]=sync;return id}else{return 0}}function _glFinish(){GLctx["finish"]()}function _glFlush(){GLctx["flush"]()}function emscriptenWebGLGetBufferBinding(target){switch(target){case 34962:target=34964;break;case 34963:target=34965;break;case 35051:target=35053;break;case 35052:target=35055;break;case 35982:target=35983;break;case 36662:target=36662;break;case 36663:target=36663;break;case 35345:target=35368;break}var buffer=GLctx.getParameter(target);if(buffer)return buffer.name|0;else return 0}function emscriptenWebGLValidateMapBufferTarget(target){switch(target){case 34962:case 34963:case 36662:case 36663:case 35051:case 35052:case 35882:case 35982:case 35345:return true;default:return false}}function _glFlushMappedBufferRange(target,offset,length){if(!emscriptenWebGLValidateMapBufferTarget(target)){GL.recordError(1280);err("GL_INVALID_ENUM in glFlushMappedBufferRange");return}var mapping=GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)];if(!mapping){GL.recordError(1282);err("buffer was never mapped in glFlushMappedBufferRange");return}if(!(mapping.access&16)){GL.recordError(1282);err("buffer was not mapped with GL_MAP_FLUSH_EXPLICIT_BIT in glFlushMappedBufferRange");return}if(offset<0||length<0||offset+length>mapping.length){GL.recordError(1281);err("invalid range in glFlushMappedBufferRange");return}GLctx.bufferSubData(target,mapping.offset,HEAPU8.subarray(mapping.mem+offset,mapping.mem+offset+length))}function _glFramebufferRenderbuffer(target,attachment,renderbuffertarget,renderbuffer){GLctx.framebufferRenderbuffer(target,attachment,renderbuffertarget,GL.renderbuffers[renderbuffer])}function _glFramebufferTexture2D(target,attachment,textarget,texture,level){GLctx.framebufferTexture2D(target,attachment,textarget,GL.textures[texture],level)}function _glFramebufferTextureLayer(target,attachment,texture,level,layer){GLctx.framebufferTextureLayer(target,attachment,GL.textures[texture],level,layer)}function _glFrontFace(x0){GLctx["frontFace"](x0)}function __glGenObject(n,buffers,createFunction,objectTable){for(var i=0;i<n;i++){var buffer=GLctx[createFunction]();var id=buffer&&GL.getNewId(objectTable);if(buffer){buffer.name=id;objectTable[id]=buffer}else{GL.recordError(1282)}HEAP32[buffers+i*4>>2]=id}}function _glGenBuffers(n,buffers){__glGenObject(n,buffers,"createBuffer",GL.buffers)}function _glGenFramebuffers(n,ids){__glGenObject(n,ids,"createFramebuffer",GL.framebuffers)}function _glGenQueries(n,ids){__glGenObject(n,ids,"createQuery",GL.queries)}function _glGenRenderbuffers(n,renderbuffers){__glGenObject(n,renderbuffers,"createRenderbuffer",GL.renderbuffers)}function _glGenSamplers(n,samplers){__glGenObject(n,samplers,"createSampler",GL.samplers)}function _glGenTextures(n,textures){__glGenObject(n,textures,"createTexture",GL.textures)}function _glGenVertexArrays(n,arrays){__glGenObject(n,arrays,"createVertexArray",GL.vaos)}function _glGenerateMipmap(x0){GLctx["generateMipmap"](x0)}function __glGetActiveAttribOrUniform(funcName,program,index,bufSize,length,size,type,name){program=GL.programs[program];var info=GLctx[funcName](program,index);if(info){var numBytesWrittenExclNull=name&&stringToUTF8(info.name,name,bufSize);if(length)HEAP32[length>>2]=numBytesWrittenExclNull;if(size)HEAP32[size>>2]=info.size;if(type)HEAP32[type>>2]=info.type}}function _glGetActiveAttrib(program,index,bufSize,length,size,type,name){__glGetActiveAttribOrUniform("getActiveAttrib",program,index,bufSize,length,size,type,name)}function _glGetActiveUniform(program,index,bufSize,length,size,type,name){__glGetActiveAttribOrUniform("getActiveUniform",program,index,bufSize,length,size,type,name)}function _glGetActiveUniformBlockName(program,uniformBlockIndex,bufSize,length,uniformBlockName){program=GL.programs[program];var result=GLctx["getActiveUniformBlockName"](program,uniformBlockIndex);if(!result)return;if(uniformBlockName&&bufSize>0){var numBytesWrittenExclNull=stringToUTF8(result,uniformBlockName,bufSize);if(length)HEAP32[length>>2]=numBytesWrittenExclNull}else{if(length)HEAP32[length>>2]=0}}function _glGetActiveUniformBlockiv(program,uniformBlockIndex,pname,params){if(!params){GL.recordError(1281);return}program=GL.programs[program];if(pname==35393){var name=GLctx["getActiveUniformBlockName"](program,uniformBlockIndex);HEAP32[params>>2]=name.length+1;return}var result=GLctx["getActiveUniformBlockParameter"](program,uniformBlockIndex,pname);if(result===null)return;if(pname==35395){for(var i=0;i<result.length;i++){HEAP32[params+i*4>>2]=result[i]}}else{HEAP32[params>>2]=result}}function _glGetActiveUniformsiv(program,uniformCount,uniformIndices,pname,params){if(!params){GL.recordError(1281);return}if(uniformCount>0&&uniformIndices==0){GL.recordError(1281);return}program=GL.programs[program];var ids=[];for(var i=0;i<uniformCount;i++){ids.push(HEAP32[uniformIndices+i*4>>2])}var result=GLctx["getActiveUniforms"](program,ids,pname);if(!result)return;var len=result.length;for(var i=0;i<len;i++){HEAP32[params+i*4>>2]=result[i]}}function _glGetAttribLocation(program,name){return GLctx.getAttribLocation(GL.programs[program],UTF8ToString(name))}function _glGetBufferSubData(target,offset,size,data){if(!data){GL.recordError(1281);return}GLctx["getBufferSubData"](target,offset,HEAPU8,data,size)}function _glGetError(){var error=GLctx.getError()||GL.lastError;GL.lastError=0;return error}function _glGetFramebufferAttachmentParameteriv(target,attachment,pname,params){var result=GLctx.getFramebufferAttachmentParameter(target,attachment,pname);if(result instanceof WebGLRenderbuffer||result instanceof WebGLTexture){result=result.name|0}HEAP32[params>>2]=result}function writeI53ToI64(ptr,num){HEAPU32[ptr>>2]=num;HEAPU32[ptr+4>>2]=(num-HEAPU32[ptr>>2])/4294967296}function emscriptenWebGLGetIndexed(target,index,data,type){if(!data){GL.recordError(1281);return}var result=GLctx["getIndexedParameter"](target,index);var ret;switch(typeof result){case"boolean":ret=result?1:0;break;case"number":ret=result;break;case"object":if(result===null){switch(target){case 35983:case 35368:ret=0;break;default:{GL.recordError(1280);return}}}else if(result instanceof WebGLBuffer){ret=result.name|0}else{GL.recordError(1280);return}break;default:GL.recordError(1280);return}switch(type){case 1:writeI53ToI64(data,ret);break;case 0:HEAP32[data>>2]=ret;break;case 2:HEAPF32[data>>2]=ret;break;case 4:HEAP8[data>>0]=ret?1:0;break;default:throw"internal emscriptenWebGLGetIndexed() error, bad type: "+type}}function _glGetIntegeri_v(target,index,data){emscriptenWebGLGetIndexed(target,index,data,0)}function emscriptenWebGLGet(name_,p,type){if(!p){GL.recordError(1281);return}var ret=undefined;switch(name_){case 36346:ret=1;break;case 36344:if(type!=0&&type!=1){GL.recordError(1280)}return;case 34814:case 36345:ret=0;break;case 34466:var formats=GLctx.getParameter(34467);ret=formats?formats.length:0;break;case 33390:ret=1048576;break;case 33309:if(GL.currentContext.version<2){GL.recordError(1282);return}var exts=GLctx.getSupportedExtensions()||[];ret=2*exts.length;break;case 33307:case 33308:if(GL.currentContext.version<2){GL.recordError(1280);return}ret=name_==33307?3:0;break}if(ret===undefined){var result=GLctx.getParameter(name_);switch(typeof result){case"number":ret=result;break;case"boolean":ret=result?1:0;break;case"string":GL.recordError(1280);return;case"object":if(result===null){switch(name_){case 34964:case 35725:case 34965:case 36006:case 36007:case 32873:case 34229:case 36662:case 36663:case 35053:case 35055:case 36010:case 35097:case 35869:case 32874:case 36389:case 35983:case 35368:case 34068:{ret=0;break}default:{GL.recordError(1280);return}}}else if(result instanceof Float32Array||result instanceof Uint32Array||result instanceof Int32Array||result instanceof Array){for(var i=0;i<result.length;++i){switch(type){case 0:HEAP32[p+i*4>>2]=result[i];break;case 2:HEAPF32[p+i*4>>2]=result[i];break;case 4:HEAP8[p+i>>0]=result[i]?1:0;break}}return}else{try{ret=result.name|0}catch(e){GL.recordError(1280);err("GL_INVALID_ENUM in glGet"+type+"v: Unknown object returned from WebGL getParameter("+name_+")! (error: "+e+")");return}}break;default:GL.recordError(1280);err("GL_INVALID_ENUM in glGet"+type+"v: Native code calling glGet"+type+"v("+name_+") and it returns "+result+" of type "+typeof result+"!");return}}switch(type){case 1:writeI53ToI64(p,ret);break;case 0:HEAP32[p>>2]=ret;break;case 2:HEAPF32[p>>2]=ret;break;case 4:HEAP8[p>>0]=ret?1:0;break}}function _glGetIntegerv(name_,p){emscriptenWebGLGet(name_,p,0)}function _glGetInternalformativ(target,internalformat,pname,bufSize,params){if(bufSize<0){GL.recordError(1281);return}if(!params){GL.recordError(1281);return}var ret=GLctx["getInternalformatParameter"](target,internalformat,pname);if(ret===null)return;for(var i=0;i<ret.length&&i<bufSize;++i){HEAP32[params+i*4>>2]=ret[i]}}function _glGetProgramBinary(program,bufSize,length,binaryFormat,binary){GL.recordError(1282)}function _glGetProgramInfoLog(program,maxLength,length,infoLog){var log=GLctx.getProgramInfoLog(GL.programs[program]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=maxLength>0&&infoLog?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[length>>2]=numBytesWrittenExclNull}function _glGetProgramiv(program,pname,p){if(!p){GL.recordError(1281);return}if(program>=GL.counter){GL.recordError(1281);return}program=GL.programs[program];if(pname==35716){var log=GLctx.getProgramInfoLog(program);if(log===null)log="(unknown error)";HEAP32[p>>2]=log.length+1}else if(pname==35719){if(!program.maxUniformLength){for(var i=0;i<GLctx.getProgramParameter(program,35718);++i){program.maxUniformLength=Math.max(program.maxUniformLength,GLctx.getActiveUniform(program,i).name.length+1)}}HEAP32[p>>2]=program.maxUniformLength}else if(pname==35722){if(!program.maxAttributeLength){for(var i=0;i<GLctx.getProgramParameter(program,35721);++i){program.maxAttributeLength=Math.max(program.maxAttributeLength,GLctx.getActiveAttrib(program,i).name.length+1)}}HEAP32[p>>2]=program.maxAttributeLength}else if(pname==35381){if(!program.maxUniformBlockNameLength){for(var i=0;i<GLctx.getProgramParameter(program,35382);++i){program.maxUniformBlockNameLength=Math.max(program.maxUniformBlockNameLength,GLctx.getActiveUniformBlockName(program,i).length+1)}}HEAP32[p>>2]=program.maxUniformBlockNameLength}else{HEAP32[p>>2]=GLctx.getProgramParameter(program,pname)}}function _glGetQueryObjectuiv(id,pname,params){if(!params){GL.recordError(1281);return}var query=GL.queries[id];var param=GLctx["getQueryParameter"](query,pname);var ret;if(typeof param=="boolean"){ret=param?1:0}else{ret=param}HEAP32[params>>2]=ret}function _glGetQueryiv(target,pname,params){if(!params){GL.recordError(1281);return}HEAP32[params>>2]=GLctx["getQuery"](target,pname)}function _glGetRenderbufferParameteriv(target,pname,params){if(!params){GL.recordError(1281);return}HEAP32[params>>2]=GLctx.getRenderbufferParameter(target,pname)}function _glGetShaderInfoLog(shader,maxLength,length,infoLog){var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";var numBytesWrittenExclNull=maxLength>0&&infoLog?stringToUTF8(log,infoLog,maxLength):0;if(length)HEAP32[length>>2]=numBytesWrittenExclNull}function _glGetShaderPrecisionFormat(shaderType,precisionType,range,precision){var result=GLctx.getShaderPrecisionFormat(shaderType,precisionType);HEAP32[range>>2]=result.rangeMin;HEAP32[range+4>>2]=result.rangeMax;HEAP32[precision>>2]=result.precision}function _glGetShaderSource(shader,bufSize,length,source){var result=GLctx.getShaderSource(GL.shaders[shader]);if(!result)return;var numBytesWrittenExclNull=bufSize>0&&source?stringToUTF8(result,source,bufSize):0;if(length)HEAP32[length>>2]=numBytesWrittenExclNull}function _glGetShaderiv(shader,pname,p){if(!p){GL.recordError(1281);return}if(pname==35716){var log=GLctx.getShaderInfoLog(GL.shaders[shader]);if(log===null)log="(unknown error)";var logLength=log?log.length+1:0;HEAP32[p>>2]=logLength}else if(pname==35720){var source=GLctx.getShaderSource(GL.shaders[shader]);var sourceLength=source?source.length+1:0;HEAP32[p>>2]=sourceLength}else{HEAP32[p>>2]=GLctx.getShaderParameter(GL.shaders[shader],pname)}}function _glGetString(name_){var ret=GL.stringCache[name_];if(!ret){switch(name_){case 7939:var exts=GLctx.getSupportedExtensions()||[];exts=exts.concat(exts.map(function(e){return"GL_"+e}));ret=stringToNewUTF8(exts.join(" "));break;case 7936:case 7937:case 37445:case 37446:var s=GLctx.getParameter(name_);if(!s){GL.recordError(1280)}ret=s&&stringToNewUTF8(s);break;case 7938:var glVersion=GLctx.getParameter(7938);if(GL.currentContext.version>=2)glVersion="OpenGL ES 3.0 ("+glVersion+")";else{glVersion="OpenGL ES 2.0 ("+glVersion+")"}ret=stringToNewUTF8(glVersion);break;case 35724:var glslVersion=GLctx.getParameter(35724);var ver_re=/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/;var ver_num=glslVersion.match(ver_re);if(ver_num!==null){if(ver_num[1].length==3)ver_num[1]=ver_num[1]+"0";glslVersion="OpenGL ES GLSL ES "+ver_num[1]+" ("+glslVersion+")"}ret=stringToNewUTF8(glslVersion);break;default:GL.recordError(1280)}GL.stringCache[name_]=ret}return ret}function _glGetStringi(name,index){if(GL.currentContext.version<2){GL.recordError(1282);return 0}var stringiCache=GL.stringiCache[name];if(stringiCache){if(index<0||index>=stringiCache.length){GL.recordError(1281);return 0}return stringiCache[index]}switch(name){case 7939:var exts=GLctx.getSupportedExtensions()||[];exts=exts.concat(exts.map(function(e){return"GL_"+e}));exts=exts.map(function(e){return stringToNewUTF8(e)});stringiCache=GL.stringiCache[name]=exts;if(index<0||index>=stringiCache.length){GL.recordError(1281);return 0}return stringiCache[index];default:GL.recordError(1280);return 0}}function _glGetTexParameteriv(target,pname,params){if(!params){GL.recordError(1281);return}HEAP32[params>>2]=GLctx.getTexParameter(target,pname)}function _glGetUniformBlockIndex(program,uniformBlockName){return GLctx["getUniformBlockIndex"](GL.programs[program],UTF8ToString(uniformBlockName))}function _glGetUniformIndices(program,uniformCount,uniformNames,uniformIndices){if(!uniformIndices){GL.recordError(1281);return}if(uniformCount>0&&(uniformNames==0||uniformIndices==0)){GL.recordError(1281);return}program=GL.programs[program];var names=[];for(var i=0;i<uniformCount;i++)names.push(UTF8ToString(HEAP32[uniformNames+i*4>>2]));var result=GLctx["getUniformIndices"](program,names);if(!result)return;var len=result.length;for(var i=0;i<len;i++){HEAP32[uniformIndices+i*4>>2]=result[i]}}function webglGetLeftBracePos(name){return name.slice(-1)=="]"&&name.lastIndexOf("[")}function webglPrepareUniformLocationsBeforeFirstUse(program){var uniformLocsById=program.uniformLocsById,uniformSizeAndIdsByName=program.uniformSizeAndIdsByName,i,j;if(!uniformLocsById){program.uniformLocsById=uniformLocsById={};program.uniformArrayNamesById={};for(i=0;i<GLctx.getProgramParameter(program,35718);++i){var u=GLctx.getActiveUniform(program,i);var nm=u.name;var sz=u.size;var lb=webglGetLeftBracePos(nm);var arrayName=lb>0?nm.slice(0,lb):nm;var id=uniformSizeAndIdsByName[arrayName]?uniformSizeAndIdsByName[arrayName][1]:program.uniformIdCounter;program.uniformIdCounter=Math.max(id+sz,program.uniformIdCounter);uniformSizeAndIdsByName[arrayName]=[sz,id];for(j=0;j<sz;++j){uniformLocsById[id]=j;program.uniformArrayNamesById[id++]=arrayName}}}}function _glGetUniformLocation(program,name){name=UTF8ToString(name);if(program=GL.programs[program]){webglPrepareUniformLocationsBeforeFirstUse(program);var uniformLocsById=program.uniformLocsById;var arrayIndex=0;var uniformBaseName=name;var leftBrace=webglGetLeftBracePos(name);if(leftBrace>0){arrayIndex=jstoi_q(name.slice(leftBrace+1))>>>0;uniformBaseName=name.slice(0,leftBrace)}var sizeAndId=program.uniformSizeAndIdsByName[uniformBaseName];if(sizeAndId&&arrayIndex<sizeAndId[0]){arrayIndex+=sizeAndId[1];if(uniformLocsById[arrayIndex]=uniformLocsById[arrayIndex]||GLctx.getUniformLocation(program,name)){return arrayIndex}}}else{GL.recordError(1281)}return-1}function webglGetUniformLocation(location){var p=GLctx.currentProgram;if(p){var webglLoc=p.uniformLocsById[location];if(typeof webglLoc=="number"){p.uniformLocsById[location]=webglLoc=GLctx.getUniformLocation(p,p.uniformArrayNamesById[location]+(webglLoc>0?"["+webglLoc+"]":""))}return webglLoc}else{GL.recordError(1282)}}function emscriptenWebGLGetUniform(program,location,params,type){if(!params){GL.recordError(1281);return}program=GL.programs[program];webglPrepareUniformLocationsBeforeFirstUse(program);var data=GLctx.getUniform(program,webglGetUniformLocation(location));if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[params>>2]=data;break;case 2:HEAPF32[params>>2]=data;break}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[params+i*4>>2]=data[i];break;case 2:HEAPF32[params+i*4>>2]=data[i];break}}}}function _glGetUniformiv(program,location,params){emscriptenWebGLGetUniform(program,location,params,0)}function emscriptenWebGLGetVertexAttrib(index,pname,params,type){if(!params){GL.recordError(1281);return}if(GL.currentContext.clientBuffers[index].enabled){err("glGetVertexAttrib*v on client-side array: not supported, bad data returned")}var data=GLctx.getVertexAttrib(index,pname);if(pname==34975){HEAP32[params>>2]=data&&data["name"]}else if(typeof data=="number"||typeof data=="boolean"){switch(type){case 0:HEAP32[params>>2]=data;break;case 2:HEAPF32[params>>2]=data;break;case 5:HEAP32[params>>2]=Math.fround(data);break}}else{for(var i=0;i<data.length;i++){switch(type){case 0:HEAP32[params+i*4>>2]=data[i];break;case 2:HEAPF32[params+i*4>>2]=data[i];break;case 5:HEAP32[params+i*4>>2]=Math.fround(data[i]);break}}}}function _glGetVertexAttribiv(index,pname,params){emscriptenWebGLGetVertexAttrib(index,pname,params,5)}function _glInvalidateFramebuffer(target,numAttachments,attachments){var list=tempFixedLengthArray[numAttachments];for(var i=0;i<numAttachments;i++){list[i]=HEAP32[attachments+i*4>>2]}GLctx["invalidateFramebuffer"](target,list)}function _glIsEnabled(x0){return GLctx["isEnabled"](x0)}function _glIsVertexArray(array){var vao=GL.vaos[array];if(!vao)return 0;return GLctx["isVertexArray"](vao)}function _glLinkProgram(program){program=GL.programs[program];GLctx.linkProgram(program);program.uniformLocsById=0;program.uniformSizeAndIdsByName={};[program["vs"],program["fs"]].forEach(function(s){Object.keys(s.explicitUniformLocations).forEach(function(shaderLocation){var loc=s.explicitUniformLocations[shaderLocation];program.uniformSizeAndIdsByName[shaderLocation]=[1,loc];program.uniformIdCounter=Math.max(program.uniformIdCounter,loc+1)})});function copyKeys(dst,src){Object.keys(src).forEach(function(key){dst[key]=src[key]})}program.explicitUniformBindings={};program.explicitSamplerBindings={};[program["vs"],program["fs"]].forEach(function(s){copyKeys(program.explicitUniformBindings,s.explicitUniformBindings);copyKeys(program.explicitSamplerBindings,s.explicitSamplerBindings)});program.explicitProgramBindingsApplied=0}function _glMapBufferRange(target,offset,length,access){if(access!=26&&access!=10){err("glMapBufferRange is only supported when access is MAP_WRITE|INVALIDATE_BUFFER");return 0}if(!emscriptenWebGLValidateMapBufferTarget(target)){GL.recordError(1280);err("GL_INVALID_ENUM in glMapBufferRange");return 0}var mem=_malloc(length);if(!mem)return 0;GL.mappedBuffers[emscriptenWebGLGetBufferBinding(target)]={offset:offset,length:length,mem:mem,access:access};return mem}function _glPixelStorei(pname,param){if(pname==3317){GL.unpackAlignment=param}GLctx.pixelStorei(pname,param)}function _glPolygonOffset(x0,x1){GLctx["polygonOffset"](x0,x1)}function _glProgramBinary(program,binaryFormat,binary,length){GL.recordError(1280)}function _glProgramParameteri(program,pname,value){GL.recordError(1280)}function _glReadBuffer(x0){GLctx["readBuffer"](x0)}function computeUnpackAlignedImageSize(width,height,sizePerPixel,alignment){function roundedToNextMultipleOf(x,y){return x+y-1&-y}var plainRowSize=width*sizePerPixel;var alignedRowSize=roundedToNextMultipleOf(plainRowSize,alignment);return height*alignedRowSize}function __colorChannelsInGlTextureFormat(format){var colorChannels={5:3,6:4,8:2,29502:3,29504:4,26917:2,26918:2,29846:3,29847:4};return colorChannels[format-6402]||1}function heapObjectForWebGLType(type){type-=5120;if(type==0)return HEAP8;if(type==1)return HEAPU8;if(type==2)return HEAP16;if(type==4)return HEAP32;if(type==6)return HEAPF32;if(type==5||type==28922||type==28520||type==30779||type==30782)return HEAPU32;return HEAPU16}function heapAccessShiftForWebGLHeap(heap){return 31-Math.clz32(heap.BYTES_PER_ELEMENT)}function emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,internalFormat){var heap=heapObjectForWebGLType(type);var shift=heapAccessShiftForWebGLHeap(heap);var byteSize=1<<shift;var sizePerPixel=__colorChannelsInGlTextureFormat(format)*byteSize;var bytes=computeUnpackAlignedImageSize(width,height,sizePerPixel,GL.unpackAlignment);return heap.subarray(pixels>>shift,pixels+bytes>>shift)}function _glReadPixels(x,y,width,height,format,type,pixels){if(GL.currentContext.version>=2){if(GLctx.currentPixelPackBufferBinding){GLctx.readPixels(x,y,width,height,format,type,pixels)}else{var heap=heapObjectForWebGLType(type);GLctx.readPixels(x,y,width,height,format,type,heap,pixels>>heapAccessShiftForWebGLHeap(heap))}return}var pixelData=emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,format);if(!pixelData){GL.recordError(1280);return}GLctx.readPixels(x,y,width,height,format,type,pixelData)}function _glRenderbufferStorage(x0,x1,x2,x3){GLctx["renderbufferStorage"](x0,x1,x2,x3)}function _glRenderbufferStorageMultisample(x0,x1,x2,x3,x4){GLctx["renderbufferStorageMultisample"](x0,x1,x2,x3,x4)}function _glSamplerParameteri(sampler,pname,param){GLctx["samplerParameteri"](GL.samplers[sampler],pname,param)}function _glScissor(x0,x1,x2,x3){GLctx["scissor"](x0,x1,x2,x3)}function find_closing_parens_index(arr,i,opening="(",closing=")"){for(var nesting=0;i<arr.length;++i){if(arr[i]==opening)++nesting;if(arr[i]==closing&&--nesting==0){return i}}}function preprocess_c_code(code,defs={}){var i=0,len=code.length,out="",stack=[1];defs["defined"]=(args=>{return defs[args[0]]?1:0});function isWhitespace(str,i){return!(str.charCodeAt(i)>32)}function nextWhitespace(str,i){while(!isWhitespace(str,i))++i;return i}function classifyChar(str,idx){var cc=str.charCodeAt(idx);if(cc>32){if(cc<48)return 1;if(cc<58)return 2;if(cc<65)return 1;if(cc<91||cc==95)return 3;if(cc<97)return 1;if(cc<123)return 3;return 1}return cc<33?0:4}function tokenize(exprString,keepWhitespace){var out=[],len=exprString.length;for(var i=0;i<=len;++i){var kind=classifyChar(exprString,i);if(kind==2||kind==3){for(var j=i+1;j<=len;++j){var kind2=classifyChar(exprString,j);if(kind2!=kind&&(kind2!=2||kind!=3)){out.push(exprString.substring(i,j));i=j-1;break}}}else if(kind==1){var op2=exprString.substr(i,2);if(["<=",">=","==","!=","&&","||"].includes(op2)){out.push(op2);++i}else{out.push(exprString[i])}}}return out}function expandMacros(str,lineStart,lineEnd){if(lineEnd===undefined)lineEnd=str.length;var len=str.length;var out="";for(var i=lineStart;i<lineEnd;++i){var kind=classifyChar(str,i);if(kind==3){for(var j=i+1;j<=lineEnd;++j){var kind2=classifyChar(str,j);if(kind2!=2&&kind2!=3){var symbol=str.substring(i,j);var pp=defs[symbol];if(pp){var expanded=str.substring(lineStart,i);if(pp.length&&str[j]=="("){var closeParens=find_closing_parens_index(str,j);expanded+=pp(str.substring(j+1,closeParens).split(","))+str.substring(closeParens+1,lineEnd)}else{expanded+=pp()+str.substring(j,lineEnd)}return expandMacros(expanded,0)}else{out+=symbol;i=j-1;break}}}}else{out+=str[i]}}return out}function buildExprTree(tokens){while(tokens.length>1||typeof tokens[0]!="function"){tokens=function(tokens){var i,j,p,operatorAndPriority=-2;for(j=0;j<tokens.length;++j){if((p=["*","/","+","-","!","<","<=",">",">=","==","!=","&&","||","("].indexOf(tokens[j]))>operatorAndPriority){i=j;operatorAndPriority=p}}if(operatorAndPriority==13){var j=find_closing_parens_index(tokens,i);if(j){tokens.splice(i,j+1-i,buildExprTree(tokens.slice(i+1,j)));return tokens}}if(operatorAndPriority==4){i=tokens.lastIndexOf("!");var innerExpr=buildExprTree(tokens.slice(i+1,i+2));tokens.splice(i,2,function(){return!innerExpr()});return tokens}if(operatorAndPriority>=0){var left=buildExprTree(tokens.slice(0,i));var right=buildExprTree(tokens.slice(i+1));switch(tokens[i]){case"&&":return[function(){return left()&&right()}];case"||":return[function(){return left()||right()}];case"==":return[function(){return left()==right()}];case"!=":return[function(){return left()!=right()}];case"<":return[function(){return left()<right()}];case"<=":return[function(){return left()<=right()}];case">":return[function(){return left()>right()}];case">=":return[function(){return left()>=right()}];case"+":return[function(){return left()+right()}];case"-":return[function(){return left()-right()}];case"*":return[function(){return left()*right()}];case"/":return[function(){return Math.floor(left()/right())}]}}var num=jstoi_q(tokens[i]);return[function(){return num}]}(tokens)}return tokens[0]}for(;i<len;++i){var lineStart=i;i=code.indexOf("\n",i);if(i<0)i=len;for(var j=lineStart;j<i&&isWhitespace(code,j);++j);var thisLineIsInActivePreprocessingBlock=stack[stack.length-1];if(code[j]!="#"){if(thisLineIsInActivePreprocessingBlock){out+=expandMacros(code,lineStart,i)+"\n"}continue}var space=nextWhitespace(code,j);var directive=code.substring(j+1,space);var expression=code.substring(space,i).trim();switch(directive){case"if":var tokens=tokenize(expandMacros(expression,0));var exprTree=buildExprTree(tokens);var evaluated=exprTree();stack.push(!!evaluated*stack[stack.length-1]);break;case"ifdef":stack.push(!!defs[expression]*stack[stack.length-1]);break;case"ifndef":stack.push(!defs[expression]*stack[stack.length-1]);break;case"else":stack[stack.length-1]=1-stack[stack.length-1];break;case"endif":stack.pop();break;case"define":if(thisLineIsInActivePreprocessingBlock){var macroStart=expression.indexOf("(");var firstWs=nextWhitespace(expression,0);if(firstWs<macroStart)macroStart=0;if(macroStart>0){var macroEnd=expression.indexOf(")",macroStart);let params=expression.substring(macroStart+1,macroEnd).split(",").map(x=>x.trim());let value=tokenize(expression.substring(macroEnd+1).trim());defs[expression.substring(0,macroStart)]=(args=>{var ret="";value.forEach(x=>{var argIndex=params.indexOf(x);ret+=argIndex>=0?args[argIndex]:x});return ret})}else{let value=expandMacros(expression.substring(firstWs+1).trim(),0);defs[expression.substring(0,firstWs)]=(()=>value)}}break;case"undef":if(thisLineIsInActivePreprocessingBlock)delete defs[expression];break;default:if(directive!="version"&&directive!="pragma"&&directive!="extension"){}out+=expandMacros(code,lineStart,i)+"\n"}}return out}function remove_cpp_comments_in_shaders(code){var i=0,out="",ch,next,len=code.length;for(;i<len;++i){ch=code[i];if(ch=="/"){next=code[i+1];if(next=="/"){while(i<len&&code[i+1]!="\n")++i}else if(next=="*"){while(i<len&&(code[i-1]!="*"||code[i]!="/"))++i}else{out+=ch}}else{out+=ch}}return out}function _glShaderSource(shader,count,string,length){var source=GL.getSource(shader,count,string,length);source=preprocess_c_code(remove_cpp_comments_in_shaders(source),{"GL_FRAGMENT_PRECISION_HIGH":()=>1,"GL_ES":()=>1,"__VERSION__":()=>source.includes("#version 300")?300:100});var regex=/layout\s*\(\s*location\s*=\s*(-?\d+)\s*\)\s*(uniform\s+((lowp|mediump|highp)\s+)?\w+\s+(\w+))/g,explicitUniformLocations={},match;while(match=regex.exec(source)){explicitUniformLocations[match[5]]=jstoi_q(match[1]);if(!(explicitUniformLocations[match[5]]>=0&&explicitUniformLocations[match[5]]<1048576)){err('Specified an out of range layout(location=x) directive "'+explicitUniformLocations[match[5]]+'"! ('+match[0]+")");GL.recordError(1281);return}}source=source.replace(regex,"$2");GL.shaders[shader].explicitUniformLocations=explicitUniformLocations;var bindingRegex=/layout\s*\(.*?binding\s*=\s*(-?\d+).*?\)\s*uniform\s+(\w+)\s+(\w+)?/g,samplerBindings={},uniformBindings={},bindingMatch;while(bindingMatch=bindingRegex.exec(source)){var arrayLength=1;for(var i=bindingMatch.index;i<source.length&&source[i]!=";";++i){if(source[i]=="["){arrayLength=jstoi_q(source.slice(i+1));break}if(source[i]=="{")i=find_closing_parens_index(source,i,"{","}")-1}var binding=jstoi_q(bindingMatch[1]);var bindingsType=34930;if(bindingMatch[3]&&bindingMatch[2].indexOf("sampler")!=-1){samplerBindings[bindingMatch[3]]=[binding,arrayLength]}else{bindingsType=35374;uniformBindings[bindingMatch[2]]=[binding,arrayLength]}var numBindingPoints=GLctx.getParameter(bindingsType);if(!(binding>=0&&binding+arrayLength<=numBindingPoints)){err('Specified an out of range layout(binding=x) directive "'+binding+'"! ('+bindingMatch[0]+"). Valid range is [0, "+numBindingPoints+"-1]");GL.recordError(1281);return}}source=source.replace(/layout\s*\(.*?binding\s*=\s*([-\d]+).*?\)/g,"");source=source.replace(/(layout\s*\((.*?)),\s*binding\s*=\s*([-\d]+)\)/g,"$1)");source=source.replace(/layout\s*\(\s*binding\s*=\s*([-\d]+)\s*,(.*?)\)/g,"layout($2)");GL.shaders[shader].explicitSamplerBindings=samplerBindings;GL.shaders[shader].explicitUniformBindings=uniformBindings;GLctx.shaderSource(GL.shaders[shader],source)}function _glStencilFuncSeparate(x0,x1,x2,x3){GLctx["stencilFuncSeparate"](x0,x1,x2,x3)}function _glStencilMask(x0){GLctx["stencilMask"](x0)}function _glStencilOpSeparate(x0,x1,x2,x3){GLctx["stencilOpSeparate"](x0,x1,x2,x3)}function _glTexImage2D(target,level,internalFormat,width,height,border,format,type,pixels){if(GL.currentContext.version>=2){if(GLctx.currentPixelUnpackBufferBinding){GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,pixels)}else if(pixels){var heap=heapObjectForWebGLType(type);GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,heap,pixels>>heapAccessShiftForWebGLHeap(heap))}else{GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,null)}return}GLctx.texImage2D(target,level,internalFormat,width,height,border,format,type,pixels?emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,internalFormat):null)}function _glTexImage3D(target,level,internalFormat,width,height,depth,border,format,type,pixels){if(GLctx.currentPixelUnpackBufferBinding){GLctx["texImage3D"](target,level,internalFormat,width,height,depth,border,format,type,pixels)}else if(pixels){var heap=heapObjectForWebGLType(type);GLctx["texImage3D"](target,level,internalFormat,width,height,depth,border,format,type,heap,pixels>>heapAccessShiftForWebGLHeap(heap))}else{GLctx["texImage3D"](target,level,internalFormat,width,height,depth,border,format,type,null)}}function _glTexParameterf(x0,x1,x2){GLctx["texParameterf"](x0,x1,x2)}function _glTexParameteri(x0,x1,x2){GLctx["texParameteri"](x0,x1,x2)}function _glTexParameteriv(target,pname,params){var param=HEAP32[params>>2];GLctx.texParameteri(target,pname,param)}function _glTexStorage2D(x0,x1,x2,x3,x4){GLctx["texStorage2D"](x0,x1,x2,x3,x4)}function _glTexStorage3D(x0,x1,x2,x3,x4,x5){GLctx["texStorage3D"](x0,x1,x2,x3,x4,x5)}function _glTexSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixels){if(GL.currentContext.version>=2){if(GLctx.currentPixelUnpackBufferBinding){GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixels)}else if(pixels){var heap=heapObjectForWebGLType(type);GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,heap,pixels>>heapAccessShiftForWebGLHeap(heap))}else{GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,null)}return}var pixelData=null;if(pixels)pixelData=emscriptenWebGLGetTexPixelData(type,format,width,height,pixels,0);GLctx.texSubImage2D(target,level,xoffset,yoffset,width,height,format,type,pixelData)}function _glTexSubImage3D(target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,pixels){if(GLctx.currentPixelUnpackBufferBinding){GLctx["texSubImage3D"](target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,pixels)}else if(pixels){var heap=heapObjectForWebGLType(type);GLctx["texSubImage3D"](target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,heap,pixels>>heapAccessShiftForWebGLHeap(heap))}else{GLctx["texSubImage3D"](target,level,xoffset,yoffset,zoffset,width,height,depth,format,type,null)}}var miniTempWebGLFloatBuffers=[];function _glUniform1fv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform1fv(webglGetUniformLocation(location),HEAPF32,value>>2,count);return}if(count<=288){var view=miniTempWebGLFloatBuffers[count-1];for(var i=0;i<count;++i){view[i]=HEAPF32[value+4*i>>2]}}else{var view=HEAPF32.subarray(value>>2,value+count*4>>2)}GLctx.uniform1fv(webglGetUniformLocation(location),view)}function _glUniform1i(location,v0){GLctx.uniform1i(webglGetUniformLocation(location),v0)}var __miniTempWebGLIntBuffers=[];function _glUniform1iv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform1iv(webglGetUniformLocation(location),HEAP32,value>>2,count);return}if(count<=288){var view=__miniTempWebGLIntBuffers[count-1];for(var i=0;i<count;++i){view[i]=HEAP32[value+4*i>>2]}}else{var view=HEAP32.subarray(value>>2,value+count*4>>2)}GLctx.uniform1iv(webglGetUniformLocation(location),view)}function _glUniform1uiv(location,count,value){GLctx.uniform1uiv(webglGetUniformLocation(location),HEAPU32,value>>2,count)}function _glUniform2fv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform2fv(webglGetUniformLocation(location),HEAPF32,value>>2,count*2);return}if(count<=144){var view=miniTempWebGLFloatBuffers[2*count-1];for(var i=0;i<2*count;i+=2){view[i]=HEAPF32[value+4*i>>2];view[i+1]=HEAPF32[value+(4*i+4)>>2]}}else{var view=HEAPF32.subarray(value>>2,value+count*8>>2)}GLctx.uniform2fv(webglGetUniformLocation(location),view)}function _glUniform2iv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform2iv(webglGetUniformLocation(location),HEAP32,value>>2,count*2);return}if(count<=144){var view=__miniTempWebGLIntBuffers[2*count-1];for(var i=0;i<2*count;i+=2){view[i]=HEAP32[value+4*i>>2];view[i+1]=HEAP32[value+(4*i+4)>>2]}}else{var view=HEAP32.subarray(value>>2,value+count*8>>2)}GLctx.uniform2iv(webglGetUniformLocation(location),view)}function _glUniform2uiv(location,count,value){GLctx.uniform2uiv(webglGetUniformLocation(location),HEAPU32,value>>2,count*2)}function _glUniform3fv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform3fv(webglGetUniformLocation(location),HEAPF32,value>>2,count*3);return}if(count<=96){var view=miniTempWebGLFloatBuffers[3*count-1];for(var i=0;i<3*count;i+=3){view[i]=HEAPF32[value+4*i>>2];view[i+1]=HEAPF32[value+(4*i+4)>>2];view[i+2]=HEAPF32[value+(4*i+8)>>2]}}else{var view=HEAPF32.subarray(value>>2,value+count*12>>2)}GLctx.uniform3fv(webglGetUniformLocation(location),view)}function _glUniform3iv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform3iv(webglGetUniformLocation(location),HEAP32,value>>2,count*3);return}if(count<=96){var view=__miniTempWebGLIntBuffers[3*count-1];for(var i=0;i<3*count;i+=3){view[i]=HEAP32[value+4*i>>2];view[i+1]=HEAP32[value+(4*i+4)>>2];view[i+2]=HEAP32[value+(4*i+8)>>2]}}else{var view=HEAP32.subarray(value>>2,value+count*12>>2)}GLctx.uniform3iv(webglGetUniformLocation(location),view)}function _glUniform3uiv(location,count,value){GLctx.uniform3uiv(webglGetUniformLocation(location),HEAPU32,value>>2,count*3)}function _glUniform4fv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform4fv(webglGetUniformLocation(location),HEAPF32,value>>2,count*4);return}if(count<=72){var view=miniTempWebGLFloatBuffers[4*count-1];var heap=HEAPF32;value>>=2;for(var i=0;i<4*count;i+=4){var dst=value+i;view[i]=heap[dst];view[i+1]=heap[dst+1];view[i+2]=heap[dst+2];view[i+3]=heap[dst+3]}}else{var view=HEAPF32.subarray(value>>2,value+count*16>>2)}GLctx.uniform4fv(webglGetUniformLocation(location),view)}function _glUniform4iv(location,count,value){if(GL.currentContext.version>=2){GLctx.uniform4iv(webglGetUniformLocation(location),HEAP32,value>>2,count*4);return}if(count<=72){var view=__miniTempWebGLIntBuffers[4*count-1];for(var i=0;i<4*count;i+=4){view[i]=HEAP32[value+4*i>>2];view[i+1]=HEAP32[value+(4*i+4)>>2];view[i+2]=HEAP32[value+(4*i+8)>>2];view[i+3]=HEAP32[value+(4*i+12)>>2]}}else{var view=HEAP32.subarray(value>>2,value+count*16>>2)}GLctx.uniform4iv(webglGetUniformLocation(location),view)}function _glUniform4uiv(location,count,value){GLctx.uniform4uiv(webglGetUniformLocation(location),HEAPU32,value>>2,count*4)}function _glUniformBlockBinding(program,uniformBlockIndex,uniformBlockBinding){program=GL.programs[program];GLctx["uniformBlockBinding"](program,uniformBlockIndex,uniformBlockBinding)}function _glUniformMatrix3fv(location,count,transpose,value){if(GL.currentContext.version>=2){GLctx.uniformMatrix3fv(webglGetUniformLocation(location),!!transpose,HEAPF32,value>>2,count*9);return}if(count<=32){var view=miniTempWebGLFloatBuffers[9*count-1];for(var i=0;i<9*count;i+=9){view[i]=HEAPF32[value+4*i>>2];view[i+1]=HEAPF32[value+(4*i+4)>>2];view[i+2]=HEAPF32[value+(4*i+8)>>2];view[i+3]=HEAPF32[value+(4*i+12)>>2];view[i+4]=HEAPF32[value+(4*i+16)>>2];view[i+5]=HEAPF32[value+(4*i+20)>>2];view[i+6]=HEAPF32[value+(4*i+24)>>2];view[i+7]=HEAPF32[value+(4*i+28)>>2];view[i+8]=HEAPF32[value+(4*i+32)>>2]}}else{var view=HEAPF32.subarray(value>>2,value+count*36>>2)}GLctx.uniformMatrix3fv(webglGetUniformLocation(location),!!transpose,view)}function _glUniformMatrix4fv(location,count,transpose,value){if(GL.currentContext.version>=2){GLctx.uniformMatrix4fv(webglGetUniformLocation(location),!!transpose,HEAPF32,value>>2,count*16);return}if(count<=18){var view=miniTempWebGLFloatBuffers[16*count-1];var heap=HEAPF32;value>>=2;for(var i=0;i<16*count;i+=16){var dst=value+i;view[i]=heap[dst];view[i+1]=heap[dst+1];view[i+2]=heap[dst+2];view[i+3]=heap[dst+3];view[i+4]=heap[dst+4];view[i+5]=heap[dst+5];view[i+6]=heap[dst+6];view[i+7]=heap[dst+7];view[i+8]=heap[dst+8];view[i+9]=heap[dst+9];view[i+10]=heap[dst+10];view[i+11]=heap[dst+11];view[i+12]=heap[dst+12];view[i+13]=heap[dst+13];view[i+14]=heap[dst+14];view[i+15]=heap[dst+15]}}else{var view=HEAPF32.subarray(value>>2,value+count*64>>2)}GLctx.uniformMatrix4fv(webglGetUniformLocation(location),!!transpose,view)}function _glUnmapBuffer(target){if(!emscriptenWebGLValidateMapBufferTarget(target)){GL.recordError(1280);err("GL_INVALID_ENUM in glUnmapBuffer");return 0}var buffer=emscriptenWebGLGetBufferBinding(target);var mapping=GL.mappedBuffers[buffer];if(!mapping){GL.recordError(1282);err("buffer was never mapped in glUnmapBuffer");return 0}GL.mappedBuffers[buffer]=null;if(!(mapping.access&16))if(GL.currentContext.version>=2){GLctx.bufferSubData(target,mapping.offset,HEAPU8,mapping.mem,mapping.length)}else{GLctx.bufferSubData(target,mapping.offset,HEAPU8.subarray(mapping.mem,mapping.mem+mapping.length))}_free(mapping.mem);return 1}function webglApplyExplicitProgramBindings(){var p=GLctx.currentProgram;if(!p.explicitProgramBindingsApplied){if(GL.currentContext.version>=2){Object.keys(p.explicitUniformBindings).forEach(function(ubo){var bindings=p.explicitUniformBindings[ubo];for(var i=0;i<bindings[1];++i){var blockIndex=GLctx.getUniformBlockIndex(p,ubo+(bindings[1]>1?"["+i+"]":""));GLctx.uniformBlockBinding(p,blockIndex,bindings[0]+i)}})}Object.keys(p.explicitSamplerBindings).forEach(function(sampler){var bindings=p.explicitSamplerBindings[sampler];for(var i=0;i<bindings[1];++i){GLctx.uniform1i(GLctx.getUniformLocation(p,sampler+(i?"["+i+"]":"")),bindings[0]+i)}});p.explicitProgramBindingsApplied=1}}function _glUseProgram(program){program=GL.programs[program];GLctx.useProgram(program);if(GLctx.currentProgram=program){webglApplyExplicitProgramBindings()}}function _glValidateProgram(program){GLctx.validateProgram(GL.programs[program])}function _glVertexAttrib4f(x0,x1,x2,x3,x4){GLctx["vertexAttrib4f"](x0,x1,x2,x3,x4)}function _glVertexAttrib4fv(index,v){GLctx.vertexAttrib4f(index,HEAPF32[v>>2],HEAPF32[v+4>>2],HEAPF32[v+8>>2],HEAPF32[v+12>>2])}function _glVertexAttribIPointer(index,size,type,stride,ptr){var cb=GL.currentContext.clientBuffers[index];if(!GLctx.currentArrayBufferBinding){cb.size=size;cb.type=type;cb.normalized=false;cb.stride=stride;cb.ptr=ptr;cb.clientside=true;cb.vertexAttribPointerAdaptor=function(index,size,type,normalized,stride,ptr){this.vertexAttribIPointer(index,size,type,stride,ptr)};return}cb.clientside=false;GLctx["vertexAttribIPointer"](index,size,type,stride,ptr)}function _glVertexAttribPointer(index,size,type,normalized,stride,ptr){var cb=GL.currentContext.clientBuffers[index];if(!GLctx.currentArrayBufferBinding){cb.size=size;cb.type=type;cb.normalized=normalized;cb.stride=stride;cb.ptr=ptr;cb.clientside=true;cb.vertexAttribPointerAdaptor=function(index,size,type,normalized,stride,ptr){this.vertexAttribPointer(index,size,type,normalized,stride,ptr)};return}cb.clientside=false;GLctx.vertexAttribPointer(index,size,type,!!normalized,stride,ptr)}function _glViewport(x0,x1,x2,x3){GLctx["viewport"](x0,x1,x2,x3)}function _llvm_eh_typeid_for(type){return type}function _setTempRet0(val){setTempRet0(val)}function __isLeapYear(year){return year%4===0&&(year%100!==0||year%400===0)}function __arraySum(array,index){var sum=0;for(var i=0;i<=index;sum+=array[i++]){}return sum}var __MONTH_DAYS_LEAP=[31,29,31,30,31,30,31,31,30,31,30,31];var __MONTH_DAYS_REGULAR=[31,28,31,30,31,30,31,31,30,31,30,31];function __addDays(date,days){var newDate=new Date(date.getTime());while(days>0){var leap=__isLeapYear(newDate.getFullYear());var currentMonth=newDate.getMonth();var daysInCurrentMonth=(leap?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR)[currentMonth];if(days>daysInCurrentMonth-newDate.getDate()){days-=daysInCurrentMonth-newDate.getDate()+1;newDate.setDate(1);if(currentMonth<11){newDate.setMonth(currentMonth+1)}else{newDate.setMonth(0);newDate.setFullYear(newDate.getFullYear()+1)}}else{newDate.setDate(newDate.getDate()+days);return newDate}}return newDate}function _strftime(s,maxsize,format,tm){var tm_zone=HEAP32[tm+40>>2];var date={tm_sec:HEAP32[tm>>2],tm_min:HEAP32[tm+4>>2],tm_hour:HEAP32[tm+8>>2],tm_mday:HEAP32[tm+12>>2],tm_mon:HEAP32[tm+16>>2],tm_year:HEAP32[tm+20>>2],tm_wday:HEAP32[tm+24>>2],tm_yday:HEAP32[tm+28>>2],tm_isdst:HEAP32[tm+32>>2],tm_gmtoff:HEAP32[tm+36>>2],tm_zone:tm_zone?UTF8ToString(tm_zone):""};var pattern=UTF8ToString(format);var EXPANSION_RULES_1={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var rule in EXPANSION_RULES_1){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_1[rule])}var WEEKDAYS=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];var MONTHS=["January","February","March","April","May","June","July","August","September","October","November","December"];function leadingSomething(value,digits,character){var str=typeof value=="number"?value.toString():value||"";while(str.length<digits){str=character[0]+str}return str}function leadingNulls(value,digits){return leadingSomething(value,digits,"0")}function compareByDay(date1,date2){function sgn(value){return value<0?-1:value>0?1:0}var compare;if((compare=sgn(date1.getFullYear()-date2.getFullYear()))===0){if((compare=sgn(date1.getMonth()-date2.getMonth()))===0){compare=sgn(date1.getDate()-date2.getDate())}}return compare}function getFirstWeekStartDate(janFourth){switch(janFourth.getDay()){case 0:return new Date(janFourth.getFullYear()-1,11,29);case 1:return janFourth;case 2:return new Date(janFourth.getFullYear(),0,3);case 3:return new Date(janFourth.getFullYear(),0,2);case 4:return new Date(janFourth.getFullYear(),0,1);case 5:return new Date(janFourth.getFullYear()-1,11,31);case 6:return new Date(janFourth.getFullYear()-1,11,30)}}function getWeekBasedYear(date){var thisDate=__addDays(new Date(date.tm_year+1900,0,1),date.tm_yday);var janFourthThisYear=new Date(thisDate.getFullYear(),0,4);var janFourthNextYear=new Date(thisDate.getFullYear()+1,0,4);var firstWeekStartThisYear=getFirstWeekStartDate(janFourthThisYear);var firstWeekStartNextYear=getFirstWeekStartDate(janFourthNextYear);if(compareByDay(firstWeekStartThisYear,thisDate)<=0){if(compareByDay(firstWeekStartNextYear,thisDate)<=0){return thisDate.getFullYear()+1}else{return thisDate.getFullYear()}}else{return thisDate.getFullYear()-1}}var EXPANSION_RULES_2={"%a":function(date){return WEEKDAYS[date.tm_wday].substring(0,3)},"%A":function(date){return WEEKDAYS[date.tm_wday]},"%b":function(date){return MONTHS[date.tm_mon].substring(0,3)},"%B":function(date){return MONTHS[date.tm_mon]},"%C":function(date){var year=date.tm_year+1900;return leadingNulls(year/100|0,2)},"%d":function(date){return leadingNulls(date.tm_mday,2)},"%e":function(date){return leadingSomething(date.tm_mday,2," ")},"%g":function(date){return getWeekBasedYear(date).toString().substring(2)},"%G":function(date){return getWeekBasedYear(date)},"%H":function(date){return leadingNulls(date.tm_hour,2)},"%I":function(date){var twelveHour=date.tm_hour;if(twelveHour==0)twelveHour=12;else if(twelveHour>12)twelveHour-=12;return leadingNulls(twelveHour,2)},"%j":function(date){return leadingNulls(date.tm_mday+__arraySum(__isLeapYear(date.tm_year+1900)?__MONTH_DAYS_LEAP:__MONTH_DAYS_REGULAR,date.tm_mon-1),3)},"%m":function(date){return leadingNulls(date.tm_mon+1,2)},"%M":function(date){return leadingNulls(date.tm_min,2)},"%n":function(){return"\n"},"%p":function(date){if(date.tm_hour>=0&&date.tm_hour<12){return"AM"}else{return"PM"}},"%S":function(date){return leadingNulls(date.tm_sec,2)},"%t":function(){return"\t"},"%u":function(date){return date.tm_wday||7},"%U":function(date){var days=date.tm_yday+7-date.tm_wday;return leadingNulls(Math.floor(days/7),2)},"%V":function(date){var val=Math.floor((date.tm_yday+7-(date.tm_wday+6)%7)/7);if((date.tm_wday+371-date.tm_yday-2)%7<=2){val++}if(!val){val=52;var dec31=(date.tm_wday+7-date.tm_yday-1)%7;if(dec31==4||dec31==5&&__isLeapYear(date.tm_year%400-1)){val++}}else if(val==53){var jan1=(date.tm_wday+371-date.tm_yday)%7;if(jan1!=4&&(jan1!=3||!__isLeapYear(date.tm_year)))val=1}return leadingNulls(val,2)},"%w":function(date){return date.tm_wday},"%W":function(date){var days=date.tm_yday+7-(date.tm_wday+6)%7;return leadingNulls(Math.floor(days/7),2)},"%y":function(date){return(date.tm_year+1900).toString().substring(2)},"%Y":function(date){return date.tm_year+1900},"%z":function(date){var off=date.tm_gmtoff;var ahead=off>=0;off=Math.abs(off)/60;off=off/60*100+off%60;return(ahead?"+":"-")+String("0000"+off).slice(-4)},"%Z":function(date){return date.tm_zone},"%%":function(){return"%"}};pattern=pattern.replace(/%%/g,"\0\0");for(var rule in EXPANSION_RULES_2){if(pattern.includes(rule)){pattern=pattern.replace(new RegExp(rule,"g"),EXPANSION_RULES_2[rule](date))}}pattern=pattern.replace(/\0\0/g,"%");var bytes=intArrayFromString(pattern,false);if(bytes.length>maxsize){return 0}writeArrayToMemory(bytes,s);return bytes.length-1}var FSNode=function(parent,name,mode,rdev){if(!parent){parent=this}this.parent=parent;this.mount=parent.mount;this.mounted=null;this.id=FS.nextInode++;this.name=name;this.mode=mode;this.node_ops={};this.stream_ops={};this.rdev=rdev};var readMode=292|73;var writeMode=146;Object.defineProperties(FSNode.prototype,{read:{get:function(){return(this.mode&readMode)===readMode},set:function(val){val?this.mode|=readMode:this.mode&=~readMode}},write:{get:function(){return(this.mode&writeMode)===writeMode},set:function(val){val?this.mode|=writeMode:this.mode&=~writeMode}},isFolder:{get:function(){return FS.isDir(this.mode)}},isDevice:{get:function(){return FS.isChrdev(this.mode)}}});FS.FSNode=FSNode;FS.staticInit();Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["requestFullscreen"]=function Module_requestFullscreen(lockPointer,resizeCanvas){Browser.requestFullscreen(lockPointer,resizeCanvas)};Module["requestAnimationFrame"]=function Module_requestAnimationFrame(func){Browser.requestAnimationFrame(func)};Module["setCanvasSize"]=function Module_setCanvasSize(width,height,noUpdates){Browser.setCanvasSize(width,height,noUpdates)};Module["pauseMainLoop"]=function Module_pauseMainLoop(){Browser.mainLoop.pause()};Module["resumeMainLoop"]=function Module_resumeMainLoop(){Browser.mainLoop.resume()};Module["getUserMedia"]=function Module_getUserMedia(){Browser.getUserMedia()};Module["createContext"]=function Module_createContext(canvas,useWebGL,setInModule,webGLContextAttributes){return Browser.createContext(canvas,useWebGL,setInModule,webGLContextAttributes)};var GLctx;for(var i=0;i<32;++i)tempFixedLengthArray.push(new Array(i));var miniTempWebGLFloatBuffersStorage=new Float32Array(288);for(var i=0;i<288;++i){miniTempWebGLFloatBuffers[i]=miniTempWebGLFloatBuffersStorage.subarray(0,i+1)}var __miniTempWebGLIntBuffersStorage=new Int32Array(288);for(var i=0;i<288;++i){__miniTempWebGLIntBuffers[i]=__miniTempWebGLIntBuffersStorage.subarray(0,i+1)}var ASSERTIONS=false;function intArrayFromString(stringy,dontAddNull,length){var len=length>0?length:lengthBytesUTF8(stringy)+1;var u8array=new Array(len);var numBytesWritten=stringToUTF8Array(stringy,u8array,0,u8array.length);if(dontAddNull)u8array.length=numBytesWritten;return u8array}var asmLibraryArg={"GetJSMemoryInfo":_GetJSMemoryInfo,"JS_Accelerometer_IsRunning":_JS_Accelerometer_IsRunning,"JS_Accelerometer_Start":_JS_Accelerometer_Start,"JS_Accelerometer_Stop":_JS_Accelerometer_Stop,"JS_CallAsLongAsNoExceptionsSeen":_JS_CallAsLongAsNoExceptionsSeen,"JS_Cursor_SetImage":_JS_Cursor_SetImage,"JS_Cursor_SetShow":_JS_Cursor_SetShow,"JS_DOM_MapViewportCoordinateToElementLocalCoordinate":_JS_DOM_MapViewportCoordinateToElementLocalCoordinate,"JS_DOM_UnityCanvasSelector":_JS_DOM_UnityCanvasSelector,"JS_Eval_OpenURL":_JS_Eval_OpenURL,"JS_FileSystem_Initialize":_JS_FileSystem_Initialize,"JS_FileSystem_Sync":_JS_FileSystem_Sync,"JS_GravitySensor_IsRunning":_JS_GravitySensor_IsRunning,"JS_GravitySensor_Start":_JS_GravitySensor_Start,"JS_GravitySensor_Stop":_JS_GravitySensor_Stop,"JS_GuardAgainstJsExceptions":_JS_GuardAgainstJsExceptions,"JS_Gyroscope_IsRunning":_JS_Gyroscope_IsRunning,"JS_Gyroscope_Start":_JS_Gyroscope_Start,"JS_Gyroscope_Stop":_JS_Gyroscope_Stop,"JS_Init_ContextMenuHandler":_JS_Init_ContextMenuHandler,"JS_LinearAccelerationSensor_IsRunning":_JS_LinearAccelerationSensor_IsRunning,"JS_LinearAccelerationSensor_Start":_JS_LinearAccelerationSensor_Start,"JS_LinearAccelerationSensor_Stop":_JS_LinearAccelerationSensor_Stop,"JS_Log_Dump":_JS_Log_Dump,"JS_Log_StackTrace":_JS_Log_StackTrace,"JS_MobileKeybard_GetIgnoreBlurEvent":_JS_MobileKeybard_GetIgnoreBlurEvent,"JS_MobileKeyboard_GetKeyboardStatus":_JS_MobileKeyboard_GetKeyboardStatus,"JS_MobileKeyboard_GetText":_JS_MobileKeyboard_GetText,"JS_MobileKeyboard_GetTextSelection":_JS_MobileKeyboard_GetTextSelection,"JS_MobileKeyboard_Hide":_JS_MobileKeyboard_Hide,"JS_MobileKeyboard_SetCharacterLimit":_JS_MobileKeyboard_SetCharacterLimit,"JS_MobileKeyboard_SetText":_JS_MobileKeyboard_SetText,"JS_MobileKeyboard_SetTextSelection":_JS_MobileKeyboard_SetTextSelection,"JS_MobileKeyboard_Show":_JS_MobileKeyboard_Show,"JS_OrientationSensor_IsRunning":_JS_OrientationSensor_IsRunning,"JS_OrientationSensor_Start":_JS_OrientationSensor_Start,"JS_OrientationSensor_Stop":_JS_OrientationSensor_Stop,"JS_RequestDeviceSensorPermissionsOnTouch":_JS_RequestDeviceSensorPermissionsOnTouch,"JS_RunQuitCallbacks":_JS_RunQuitCallbacks,"JS_ScreenOrientation_DeInit":_JS_ScreenOrientation_DeInit,"JS_ScreenOrientation_Init":_JS_ScreenOrientation_Init,"JS_ScreenOrientation_Lock":_JS_ScreenOrientation_Lock,"JS_Sound_Create_Channel":_JS_Sound_Create_Channel,"JS_Sound_GetLength":_JS_Sound_GetLength,"JS_Sound_GetLoadState":_JS_Sound_GetLoadState,"JS_Sound_Init":_JS_Sound_Init,"JS_Sound_Load":_JS_Sound_Load,"JS_Sound_Load_PCM":_JS_Sound_Load_PCM,"JS_Sound_Play":_JS_Sound_Play,"JS_Sound_ReleaseInstance":_JS_Sound_ReleaseInstance,"JS_Sound_ResumeIfNeeded":_JS_Sound_ResumeIfNeeded,"JS_Sound_Set3D":_JS_Sound_Set3D,"JS_Sound_SetListenerOrientation":_JS_Sound_SetListenerOrientation,"JS_Sound_SetListenerPosition":_JS_Sound_SetListenerPosition,"JS_Sound_SetLoop":_JS_Sound_SetLoop,"JS_Sound_SetLoopPoints":_JS_Sound_SetLoopPoints,"JS_Sound_SetPaused":_JS_Sound_SetPaused,"JS_Sound_SetPitch":_JS_Sound_SetPitch,"JS_Sound_SetPosition":_JS_Sound_SetPosition,"JS_Sound_SetVolume":_JS_Sound_SetVolume,"JS_Sound_Stop":_JS_Sound_Stop,"JS_SystemInfo_GetCanvasClientSize":_JS_SystemInfo_GetCanvasClientSize,"JS_SystemInfo_GetDocumentURL":_JS_SystemInfo_GetDocumentURL,"JS_SystemInfo_GetGPUInfo":_JS_SystemInfo_GetGPUInfo,"JS_SystemInfo_GetMatchWebGLToCanvasSize":_JS_SystemInfo_GetMatchWebGLToCanvasSize,"JS_SystemInfo_GetMemory":_JS_SystemInfo_GetMemory,"JS_SystemInfo_GetOS":_JS_SystemInfo_GetOS,"JS_SystemInfo_GetPreferredDevicePixelRatio":_JS_SystemInfo_GetPreferredDevicePixelRatio,"JS_SystemInfo_GetScreenSize":_JS_SystemInfo_GetScreenSize,"JS_SystemInfo_GetStreamingAssetsURL":_JS_SystemInfo_GetStreamingAssetsURL,"JS_SystemInfo_HasAstcHdr":_JS_SystemInfo_HasAstcHdr,"JS_SystemInfo_HasCursorLock":_JS_SystemInfo_HasCursorLock,"JS_SystemInfo_HasFullscreen":_JS_SystemInfo_HasFullscreen,"JS_SystemInfo_HasWebGL":_JS_SystemInfo_HasWebGL,"JS_SystemInfo_IsMobile":_JS_SystemInfo_IsMobile,"JS_UnityEngineShouldQuit":_JS_UnityEngineShouldQuit,"JS_WebRequest_Abort":_JS_WebRequest_Abort,"JS_WebRequest_Create":_JS_WebRequest_Create,"JS_WebRequest_GetResponseMetaData":_JS_WebRequest_GetResponseMetaData,"JS_WebRequest_GetResponseMetaDataLengths":_JS_WebRequest_GetResponseMetaDataLengths,"JS_WebRequest_Release":_JS_WebRequest_Release,"JS_WebRequest_Send":_JS_WebRequest_Send,"JS_WebRequest_SetRedirectLimit":_JS_WebRequest_SetRedirectLimit,"JS_WebRequest_SetRequestHeader":_JS_WebRequest_SetRequestHeader,"JS_WebRequest_SetTimeout":_JS_WebRequest_SetTimeout,"LSDelete":_LSDelete,"LSExists":_LSExists,"LSRead":_LSRead,"LSWrite":_LSWrite,"OpenMetaMaskDeeplink":_OpenMetaMaskDeeplink,"ThirdwebConnect":_ThirdwebConnect,"ThirdwebCopyBuffer":_ThirdwebCopyBuffer,"ThirdwebDisconnect":_ThirdwebDisconnect,"ThirdwebExportWallet":_ThirdwebExportWallet,"ThirdwebFundWallet":_ThirdwebFundWallet,"ThirdwebGetBlock":_ThirdwebGetBlock,"ThirdwebGetBlockWithTransactions":_ThirdwebGetBlockWithTransactions,"ThirdwebGetEmail":_ThirdwebGetEmail,"ThirdwebGetLatestBlockNumber":_ThirdwebGetLatestBlockNumber,"ThirdwebGetNonce":_ThirdwebGetNonce,"ThirdwebGetSignerAddress":_ThirdwebGetSignerAddress,"ThirdwebInitialize":_ThirdwebInitialize,"ThirdwebInvoke":_ThirdwebInvoke,"ThirdwebInvokeListener":_ThirdwebInvokeListener,"ThirdwebResolveAddressFromENS":_ThirdwebResolveAddressFromENS,"ThirdwebResolveENSFromAddress":_ThirdwebResolveENSFromAddress,"ThirdwebSmartWalletAddAdmin":_ThirdwebSmartWalletAddAdmin,"ThirdwebSmartWalletCreateSessionKey":_ThirdwebSmartWalletCreateSessionKey,"ThirdwebSmartWalletGetAllActiveSigners":_ThirdwebSmartWalletGetAllActiveSigners,"ThirdwebSmartWalletIsDeployed":_ThirdwebSmartWalletIsDeployed,"ThirdwebSmartWalletRemoveAdmin":_ThirdwebSmartWalletRemoveAdmin,"ThirdwebSmartWalletRevokeSessionKey":_ThirdwebSmartWalletRevokeSessionKey,"ThirdwebSwitchNetwork":_ThirdwebSwitchNetwork,"ThirdwebWaitForTransactionResult":_ThirdwebWaitForTransactionResult,"WebGLIsMobile":_WebGLIsMobile,"WebSocketAddSubProtocol":_WebSocketAddSubProtocol,"WebSocketAllocate":_WebSocketAllocate,"WebSocketClose":_WebSocketClose,"WebSocketConnect":_WebSocketConnect,"WebSocketFree":_WebSocketFree,"WebSocketGetState":_WebSocketGetState,"WebSocketSend":_WebSocketSend,"WebSocketSendText":_WebSocketSendText,"WebSocketSetOnClose":_WebSocketSetOnClose,"WebSocketSetOnError":_WebSocketSetOnError,"WebSocketSetOnMessage":_WebSocketSetOnMessage,"WebSocketSetOnOpen":_WebSocketSetOnOpen,"WebSocketSetOnTextMessage":_WebSocketSetOnTextMessage,"_DisconnectMetaMaskJS":__DisconnectMetaMaskJS,"_HasMetaMaskJSSession":__HasMetaMaskJSSession,"_InitMetaMaskJS":__InitMetaMaskJS,"_SendMetaMaskJS":__SendMetaMaskJS,"_SendRequestFetch":__SendRequestFetch,"_TerminateMetaMaskJS":__TerminateMetaMaskJS,"__cxa_allocate_exception":___cxa_allocate_exception,"__cxa_begin_catch":___cxa_begin_catch,"__cxa_end_catch":___cxa_end_catch,"__cxa_find_matching_catch_2":___cxa_find_matching_catch_2,"__cxa_find_matching_catch_3":___cxa_find_matching_catch_3,"__cxa_find_matching_catch_4":___cxa_find_matching_catch_4,"__cxa_free_exception":___cxa_free_exception,"__cxa_rethrow":___cxa_rethrow,"__cxa_throw":___cxa_throw,"__resumeException":___resumeException,"__syscall__newselect":___syscall__newselect,"__syscall_accept4":___syscall_accept4,"__syscall_bind":___syscall_bind,"__syscall_chmod":___syscall_chmod,"__syscall_connect":___syscall_connect,"__syscall_dup3":___syscall_dup3,"__syscall_faccessat":___syscall_faccessat,"__syscall_fcntl64":___syscall_fcntl64,"__syscall_fstat64":___syscall_fstat64,"__syscall_ftruncate64":___syscall_ftruncate64,"__syscall_getcwd":___syscall_getcwd,"__syscall_getdents64":___syscall_getdents64,"__syscall_getpeername":___syscall_getpeername,"__syscall_getsockname":___syscall_getsockname,"__syscall_getsockopt":___syscall_getsockopt,"__syscall_ioctl":___syscall_ioctl,"__syscall_listen":___syscall_listen,"__syscall_lstat64":___syscall_lstat64,"__syscall_mkdir":___syscall_mkdir,"__syscall_newfstatat":___syscall_newfstatat,"__syscall_openat":___syscall_openat,"__syscall_pipe":___syscall_pipe,"__syscall_poll":___syscall_poll,"__syscall_readlinkat":___syscall_readlinkat,"__syscall_recvfrom":___syscall_recvfrom,"__syscall_recvmsg":___syscall_recvmsg,"__syscall_renameat":___syscall_renameat,"__syscall_rmdir":___syscall_rmdir,"__syscall_sendmsg":___syscall_sendmsg,"__syscall_sendto":___syscall_sendto,"__syscall_socket":___syscall_socket,"__syscall_stat64":___syscall_stat64,"__syscall_statfs64":___syscall_statfs64,"__syscall_truncate64":___syscall_truncate64,"__syscall_unlinkat":___syscall_unlinkat,"__syscall_utimensat":___syscall_utimensat,"_dlopen_js":__dlopen_js,"_dlsym_js":__dlsym_js,"_emscripten_date_now":__emscripten_date_now,"_emscripten_get_now_is_monotonic":__emscripten_get_now_is_monotonic,"_emscripten_throw_longjmp":__emscripten_throw_longjmp,"_gmtime_js":__gmtime_js,"_localtime_js":__localtime_js,"_mktime_js":__mktime_js,"_mmap_js":__mmap_js,"_munmap_js":__munmap_js,"_tzset_js":__tzset_js,"abort":_abort,"emscripten_asm_const_int_sync_on_main_thread":_emscripten_asm_const_int_sync_on_main_thread,"emscripten_cancel_main_loop":_emscripten_cancel_main_loop,"emscripten_clear_interval":_emscripten_clear_interval,"emscripten_exit_fullscreen":_emscripten_exit_fullscreen,"emscripten_exit_pointerlock":_emscripten_exit_pointerlock,"emscripten_get_canvas_element_size":_emscripten_get_canvas_element_size,"emscripten_get_fullscreen_status":_emscripten_get_fullscreen_status,"emscripten_get_gamepad_status":_emscripten_get_gamepad_status,"emscripten_get_heap_max":_emscripten_get_heap_max,"emscripten_get_now":_emscripten_get_now,"emscripten_get_now_res":_emscripten_get_now_res,"emscripten_get_num_gamepads":_emscripten_get_num_gamepads,"emscripten_html5_remove_all_event_listeners":_emscripten_html5_remove_all_event_listeners,"emscripten_is_webgl_context_lost":_emscripten_is_webgl_context_lost,"emscripten_log":_emscripten_log,"emscripten_memcpy_big":_emscripten_memcpy_big,"emscripten_request_fullscreen":_emscripten_request_fullscreen,"emscripten_request_pointerlock":_emscripten_request_pointerlock,"emscripten_resize_heap":_emscripten_resize_heap,"emscripten_sample_gamepad_data":_emscripten_sample_gamepad_data,"emscripten_set_blur_callback_on_thread":_emscripten_set_blur_callback_on_thread,"emscripten_set_canvas_element_size":_emscripten_set_canvas_element_size,"emscripten_set_focus_callback_on_thread":_emscripten_set_focus_callback_on_thread,"emscripten_set_fullscreenchange_callback_on_thread":_emscripten_set_fullscreenchange_callback_on_thread,"emscripten_set_gamepadconnected_callback_on_thread":_emscripten_set_gamepadconnected_callback_on_thread,"emscripten_set_gamepaddisconnected_callback_on_thread":_emscripten_set_gamepaddisconnected_callback_on_thread,"emscripten_set_interval":_emscripten_set_interval,"emscripten_set_keydown_callback_on_thread":_emscripten_set_keydown_callback_on_thread,"emscripten_set_keypress_callback_on_thread":_emscripten_set_keypress_callback_on_thread,"emscripten_set_keyup_callback_on_thread":_emscripten_set_keyup_callback_on_thread,"emscripten_set_main_loop":_emscripten_set_main_loop,"emscripten_set_main_loop_timing":_emscripten_set_main_loop_timing,"emscripten_set_mousedown_callback_on_thread":_emscripten_set_mousedown_callback_on_thread,"emscripten_set_mousemove_callback_on_thread":_emscripten_set_mousemove_callback_on_thread,"emscripten_set_mouseup_callback_on_thread":_emscripten_set_mouseup_callback_on_thread,"emscripten_set_pointerlockchange_callback_on_thread":_emscripten_set_pointerlockchange_callback_on_thread,"emscripten_set_touchcancel_callback_on_thread":_emscripten_set_touchcancel_callback_on_thread,"emscripten_set_touchend_callback_on_thread":_emscripten_set_touchend_callback_on_thread,"emscripten_set_touchmove_callback_on_thread":_emscripten_set_touchmove_callback_on_thread,"emscripten_set_touchstart_callback_on_thread":_emscripten_set_touchstart_callback_on_thread,"emscripten_set_wheel_callback_on_thread":_emscripten_set_wheel_callback_on_thread,"emscripten_webgl_create_context":_emscripten_webgl_create_context,"emscripten_webgl_destroy_context":_emscripten_webgl_destroy_context,"emscripten_webgl_enable_extension":_emscripten_webgl_enable_extension,"emscripten_webgl_get_current_context":_emscripten_webgl_get_current_context,"emscripten_webgl_init_context_attributes":_emscripten_webgl_init_context_attributes,"emscripten_webgl_make_context_current":_emscripten_webgl_make_context_current,"environ_get":_environ_get,"environ_sizes_get":_environ_sizes_get,"exit":_exit,"fd_close":_fd_close,"fd_fdstat_get":_fd_fdstat_get,"fd_read":_fd_read,"fd_seek":_fd_seek,"fd_write":_fd_write,"getTempRet0":_getTempRet0,"getaddrinfo":_getaddrinfo,"gethostbyaddr":_gethostbyaddr,"gethostbyname":_gethostbyname,"getnameinfo":_getnameinfo,"glActiveTexture":_glActiveTexture,"glAttachShader":_glAttachShader,"glBeginQuery":_glBeginQuery,"glBindAttribLocation":_glBindAttribLocation,"glBindBuffer":_glBindBuffer,"glBindBufferBase":_glBindBufferBase,"glBindBufferRange":_glBindBufferRange,"glBindFramebuffer":_glBindFramebuffer,"glBindRenderbuffer":_glBindRenderbuffer,"glBindSampler":_glBindSampler,"glBindTexture":_glBindTexture,"glBindVertexArray":_glBindVertexArray,"glBlendEquation":_glBlendEquation,"glBlendEquationSeparate":_glBlendEquationSeparate,"glBlendFuncSeparate":_glBlendFuncSeparate,"glBlitFramebuffer":_glBlitFramebuffer,"glBufferData":_glBufferData,"glBufferSubData":_glBufferSubData,"glCheckFramebufferStatus":_glCheckFramebufferStatus,"glClear":_glClear,"glClearBufferfi":_glClearBufferfi,"glClearBufferfv":_glClearBufferfv,"glClearBufferuiv":_glClearBufferuiv,"glClearColor":_glClearColor,"glClearDepthf":_glClearDepthf,"glClearStencil":_glClearStencil,"glClientWaitSync":_glClientWaitSync,"glColorMask":_glColorMask,"glCompileShader":_glCompileShader,"glCompressedTexImage2D":_glCompressedTexImage2D,"glCompressedTexImage3D":_glCompressedTexImage3D,"glCompressedTexSubImage2D":_glCompressedTexSubImage2D,"glCompressedTexSubImage3D":_glCompressedTexSubImage3D,"glCopyBufferSubData":_glCopyBufferSubData,"glCopyTexImage2D":_glCopyTexImage2D,"glCopyTexSubImage2D":_glCopyTexSubImage2D,"glCreateProgram":_glCreateProgram,"glCreateShader":_glCreateShader,"glCullFace":_glCullFace,"glDeleteBuffers":_glDeleteBuffers,"glDeleteFramebuffers":_glDeleteFramebuffers,"glDeleteProgram":_glDeleteProgram,"glDeleteQueries":_glDeleteQueries,"glDeleteRenderbuffers":_glDeleteRenderbuffers,"glDeleteSamplers":_glDeleteSamplers,"glDeleteShader":_glDeleteShader,"glDeleteSync":_glDeleteSync,"glDeleteTextures":_glDeleteTextures,"glDeleteVertexArrays":_glDeleteVertexArrays,"glDepthFunc":_glDepthFunc,"glDepthMask":_glDepthMask,"glDetachShader":_glDetachShader,"glDisable":_glDisable,"glDisableVertexAttribArray":_glDisableVertexAttribArray,"glDrawArrays":_glDrawArrays,"glDrawArraysInstanced":_glDrawArraysInstanced,"glDrawBuffers":_glDrawBuffers,"glDrawElements":_glDrawElements,"glDrawElementsInstanced":_glDrawElementsInstanced,"glEnable":_glEnable,"glEnableVertexAttribArray":_glEnableVertexAttribArray,"glEndQuery":_glEndQuery,"glFenceSync":_glFenceSync,"glFinish":_glFinish,"glFlush":_glFlush,"glFlushMappedBufferRange":_glFlushMappedBufferRange,"glFramebufferRenderbuffer":_glFramebufferRenderbuffer,"glFramebufferTexture2D":_glFramebufferTexture2D,"glFramebufferTextureLayer":_glFramebufferTextureLayer,"glFrontFace":_glFrontFace,"glGenBuffers":_glGenBuffers,"glGenFramebuffers":_glGenFramebuffers,"glGenQueries":_glGenQueries,"glGenRenderbuffers":_glGenRenderbuffers,"glGenSamplers":_glGenSamplers,"glGenTextures":_glGenTextures,"glGenVertexArrays":_glGenVertexArrays,"glGenerateMipmap":_glGenerateMipmap,"glGetActiveAttrib":_glGetActiveAttrib,"glGetActiveUniform":_glGetActiveUniform,"glGetActiveUniformBlockName":_glGetActiveUniformBlockName,"glGetActiveUniformBlockiv":_glGetActiveUniformBlockiv,"glGetActiveUniformsiv":_glGetActiveUniformsiv,"glGetAttribLocation":_glGetAttribLocation,"glGetBufferSubData":_glGetBufferSubData,"glGetError":_glGetError,"glGetFramebufferAttachmentParameteriv":_glGetFramebufferAttachmentParameteriv,"glGetIntegeri_v":_glGetIntegeri_v,"glGetIntegerv":_glGetIntegerv,"glGetInternalformativ":_glGetInternalformativ,"glGetProgramBinary":_glGetProgramBinary,"glGetProgramInfoLog":_glGetProgramInfoLog,"glGetProgramiv":_glGetProgramiv,"glGetQueryObjectuiv":_glGetQueryObjectuiv,"glGetQueryiv":_glGetQueryiv,"glGetRenderbufferParameteriv":_glGetRenderbufferParameteriv,"glGetShaderInfoLog":_glGetShaderInfoLog,"glGetShaderPrecisionFormat":_glGetShaderPrecisionFormat,"glGetShaderSource":_glGetShaderSource,"glGetShaderiv":_glGetShaderiv,"glGetString":_glGetString,"glGetStringi":_glGetStringi,"glGetTexParameteriv":_glGetTexParameteriv,"glGetUniformBlockIndex":_glGetUniformBlockIndex,"glGetUniformIndices":_glGetUniformIndices,"glGetUniformLocation":_glGetUniformLocation,"glGetUniformiv":_glGetUniformiv,"glGetVertexAttribiv":_glGetVertexAttribiv,"glInvalidateFramebuffer":_glInvalidateFramebuffer,"glIsEnabled":_glIsEnabled,"glIsVertexArray":_glIsVertexArray,"glLinkProgram":_glLinkProgram,"glMapBufferRange":_glMapBufferRange,"glPixelStorei":_glPixelStorei,"glPolygonOffset":_glPolygonOffset,"glProgramBinary":_glProgramBinary,"glProgramParameteri":_glProgramParameteri,"glReadBuffer":_glReadBuffer,"glReadPixels":_glReadPixels,"glRenderbufferStorage":_glRenderbufferStorage,"glRenderbufferStorageMultisample":_glRenderbufferStorageMultisample,"glSamplerParameteri":_glSamplerParameteri,"glScissor":_glScissor,"glShaderSource":_glShaderSource,"glStencilFuncSeparate":_glStencilFuncSeparate,"glStencilMask":_glStencilMask,"glStencilOpSeparate":_glStencilOpSeparate,"glTexImage2D":_glTexImage2D,"glTexImage3D":_glTexImage3D,"glTexParameterf":_glTexParameterf,"glTexParameteri":_glTexParameteri,"glTexParameteriv":_glTexParameteriv,"glTexStorage2D":_glTexStorage2D,"glTexStorage3D":_glTexStorage3D,"glTexSubImage2D":_glTexSubImage2D,"glTexSubImage3D":_glTexSubImage3D,"glUniform1fv":_glUniform1fv,"glUniform1i":_glUniform1i,"glUniform1iv":_glUniform1iv,"glUniform1uiv":_glUniform1uiv,"glUniform2fv":_glUniform2fv,"glUniform2iv":_glUniform2iv,"glUniform2uiv":_glUniform2uiv,"glUniform3fv":_glUniform3fv,"glUniform3iv":_glUniform3iv,"glUniform3uiv":_glUniform3uiv,"glUniform4fv":_glUniform4fv,"glUniform4iv":_glUniform4iv,"glUniform4uiv":_glUniform4uiv,"glUniformBlockBinding":_glUniformBlockBinding,"glUniformMatrix3fv":_glUniformMatrix3fv,"glUniformMatrix4fv":_glUniformMatrix4fv,"glUnmapBuffer":_glUnmapBuffer,"glUseProgram":_glUseProgram,"glValidateProgram":_glValidateProgram,"glVertexAttrib4f":_glVertexAttrib4f,"glVertexAttrib4fv":_glVertexAttrib4fv,"glVertexAttribIPointer":_glVertexAttribIPointer,"glVertexAttribPointer":_glVertexAttribPointer,"glViewport":_glViewport,"invoke_dddi":invoke_dddi,"invoke_ddi":invoke_ddi,"invoke_ddiii":invoke_ddiii,"invoke_didi":invoke_didi,"invoke_dii":invoke_dii,"invoke_diidi":invoke_diidi,"invoke_diii":invoke_diii,"invoke_diiii":invoke_diiii,"invoke_dji":invoke_dji,"invoke_fffi":invoke_fffi,"invoke_ffi":invoke_ffi,"invoke_fi":invoke_fi,"invoke_fifi":invoke_fifi,"invoke_fii":invoke_fii,"invoke_fiifi":invoke_fiifi,"invoke_fiii":invoke_fiii,"invoke_fiiii":invoke_fiiii,"invoke_fiiiii":invoke_fiiiii,"invoke_fiji":invoke_fiji,"invoke_i":invoke_i,"invoke_idi":invoke_idi,"invoke_ifi":invoke_ifi,"invoke_ii":invoke_ii,"invoke_iidi":invoke_iidi,"invoke_iidiii":invoke_iidiii,"invoke_iifi":invoke_iifi,"invoke_iifii":invoke_iifii,"invoke_iii":invoke_iii,"invoke_iiifi":invoke_iiifi,"invoke_iiifii":invoke_iiifii,"invoke_iiii":invoke_iiii,"invoke_iiiidii":invoke_iiiidii,"invoke_iiiifi":invoke_iiiifi,"invoke_iiiifii":invoke_iiiifii,"invoke_iiiii":invoke_iiiii,"invoke_iiiiifi":invoke_iiiiifi,"invoke_iiiiifiiiii":invoke_iiiiifiiiii,"invoke_iiiiii":invoke_iiiiii,"invoke_iiiiiifii":invoke_iiiiiifii,"invoke_iiiiiii":invoke_iiiiiii,"invoke_iiiiiiifii":invoke_iiiiiiifii,"invoke_iiiiiiii":invoke_iiiiiiii,"invoke_iiiiiiiifiii":invoke_iiiiiiiifiii,"invoke_iiiiiiiii":invoke_iiiiiiiii,"invoke_iiiiiiiiii":invoke_iiiiiiiiii,"invoke_iiiiiiiiiii":invoke_iiiiiiiiiii,"invoke_iiiiiiiiiiii":invoke_iiiiiiiiiiii,"invoke_iiiiiiiiiji":invoke_iiiiiiiiiji,"invoke_iiiiij":invoke_iiiiij,"invoke_iiiiiji":invoke_iiiiiji,"invoke_iiiiijii":invoke_iiiiijii,"invoke_iiiiijiii":invoke_iiiiijiii,"invoke_iiiiji":invoke_iiiiji,"invoke_iiiijii":invoke_iiiijii,"invoke_iiiijiii":invoke_iiiijiii,"invoke_iiiijjii":invoke_iiiijjii,"invoke_iiiijjiii":invoke_iiiijjiii,"invoke_iiiji":invoke_iiiji,"invoke_iiijii":invoke_iiijii,"invoke_iiijiii":invoke_iiijiii,"invoke_iiijjji":invoke_iiijjji,"invoke_iij":invoke_iij,"invoke_iiji":invoke_iiji,"invoke_iijii":invoke_iijii,"invoke_iijiii":invoke_iijiii,"invoke_iijiiii":invoke_iijiiii,"invoke_iijiiiiii":invoke_iijiiiiii,"invoke_iijji":invoke_iijji,"invoke_iijjiiiiii":invoke_iijjiiiiii,"invoke_iji":invoke_iji,"invoke_ijii":invoke_ijii,"invoke_ijji":invoke_ijji,"invoke_j":invoke_j,"invoke_jdi":invoke_jdi,"invoke_ji":invoke_ji,"invoke_jidi":invoke_jidi,"invoke_jii":invoke_jii,"invoke_jiii":invoke_jiii,"invoke_jiiii":invoke_jiiii,"invoke_jiiiii":invoke_jiiiii,"invoke_jiiiiiiiiii":invoke_jiiiiiiiiii,"invoke_jiiji":invoke_jiiji,"invoke_jiji":invoke_jiji,"invoke_jijii":invoke_jijii,"invoke_jji":invoke_jji,"invoke_jjii":invoke_jjii,"invoke_jjji":invoke_jjji,"invoke_v":invoke_v,"invoke_vfi":invoke_vfi,"invoke_vi":invoke_vi,"invoke_vidd":invoke_vidd,"invoke_viddii":invoke_viddii,"invoke_vidi":invoke_vidi,"invoke_viffffi":invoke_viffffi,"invoke_vifffi":invoke_vifffi,"invoke_viffi":invoke_viffi,"invoke_vifi":invoke_vifi,"invoke_vifii":invoke_vifii,"invoke_vii":invoke_vii,"invoke_viidi":invoke_viidi,"invoke_viidii":invoke_viidii,"invoke_viifffffi":invoke_viifffffi,"invoke_viiffi":invoke_viiffi,"invoke_viifi":invoke_viifi,"invoke_viifii":invoke_viifii,"invoke_viifiiiiii":invoke_viifiiiiii,"invoke_viii":invoke_viii,"invoke_viiifi":invoke_viiifi,"invoke_viiifii":invoke_viiifii,"invoke_viiii":invoke_viiii,"invoke_viiiidi":invoke_viiiidi,"invoke_viiiifi":invoke_viiiifi,"invoke_viiiifii":invoke_viiiifii,"invoke_viiiii":invoke_viiiii,"invoke_viiiiifffiii":invoke_viiiiifffiii,"invoke_viiiiiffi":invoke_viiiiiffi,"invoke_viiiiifi":invoke_viiiiifi,"invoke_viiiiii":invoke_viiiiii,"invoke_viiiiiifddfiiii":invoke_viiiiiifddfiiii,"invoke_viiiiiiffffiiii":invoke_viiiiiiffffiiii,"invoke_viiiiiifiifiiii":invoke_viiiiiifiifiiii,"invoke_viiiiiifjjfiiii":invoke_viiiiiifjjfiiii,"invoke_viiiiiii":invoke_viiiiiii,"invoke_viiiiiiii":invoke_viiiiiiii,"invoke_viiiiiiiii":invoke_viiiiiiiii,"invoke_viiiiiiiiii":invoke_viiiiiiiiii,"invoke_viiiiiiiiiiii":invoke_viiiiiiiiiiii,"invoke_viiiiiiiiiiiii":invoke_viiiiiiiiiiiii,"invoke_viiiiiiiiiiiiii":invoke_viiiiiiiiiiiiii,"invoke_viiiiji":invoke_viiiiji,"invoke_viiiijii":invoke_viiiijii,"invoke_viiiji":invoke_viiiji,"invoke_viiji":invoke_viiji,"invoke_viijii":invoke_viijii,"invoke_viijiiijiiii":invoke_viijiiijiiii,"invoke_viijji":invoke_viijji,"invoke_viji":invoke_viji,"invoke_vijii":invoke_vijii,"invoke_vijiii":invoke_vijiii,"invoke_vijiiii":invoke_vijiiii,"invoke_vijiiiii":invoke_vijiiiii,"invoke_vijji":invoke_vijji,"invoke_vijjji":invoke_vijjji,"invoke_vji":invoke_vji,"invoke_vjiiiii":invoke_vjiiiii,"invoke_vjjjiiii":invoke_vjjjiiii,"llvm_eh_typeid_for":_llvm_eh_typeid_for,"setTempRet0":_setTempRet0,"strftime":_strftime};var asm=createWasm();var ___wasm_call_ctors=Module["___wasm_call_ctors"]=function(){return(___wasm_call_ctors=Module["___wasm_call_ctors"]=Module["asm"]["__wasm_call_ctors"]).apply(null,arguments)};var _ReleaseKeys=Module["_ReleaseKeys"]=function(){return(_ReleaseKeys=Module["_ReleaseKeys"]=Module["asm"]["ReleaseKeys"]).apply(null,arguments)};var _getMemInfo=Module["_getMemInfo"]=function(){return(_getMemInfo=Module["_getMemInfo"]=Module["asm"]["getMemInfo"]).apply(null,arguments)};var _SendMessageFloat=Module["_SendMessageFloat"]=function(){return(_SendMessageFloat=Module["_SendMessageFloat"]=Module["asm"]["SendMessageFloat"]).apply(null,arguments)};var _SendMessageString=Module["_SendMessageString"]=function(){return(_SendMessageString=Module["_SendMessageString"]=Module["asm"]["SendMessageString"]).apply(null,arguments)};var _SendMessage=Module["_SendMessage"]=function(){return(_SendMessage=Module["_SendMessage"]=Module["asm"]["SendMessage"]).apply(null,arguments)};var _SetFullscreen=Module["_SetFullscreen"]=function(){return(_SetFullscreen=Module["_SetFullscreen"]=Module["asm"]["SetFullscreen"]).apply(null,arguments)};var _main=Module["_main"]=function(){return(_main=Module["_main"]=Module["asm"]["main"]).apply(null,arguments)};var ___errno_location=Module["___errno_location"]=function(){return(___errno_location=Module["___errno_location"]=Module["asm"]["__errno_location"]).apply(null,arguments)};var ___dl_seterr=Module["___dl_seterr"]=function(){return(___dl_seterr=Module["___dl_seterr"]=Module["asm"]["__dl_seterr"]).apply(null,arguments)};var _htonl=Module["_htonl"]=function(){return(_htonl=Module["_htonl"]=Module["asm"]["htonl"]).apply(null,arguments)};var _htons=Module["_htons"]=function(){return(_htons=Module["_htons"]=Module["asm"]["htons"]).apply(null,arguments)};var _ntohs=Module["_ntohs"]=function(){return(_ntohs=Module["_ntohs"]=Module["asm"]["ntohs"]).apply(null,arguments)};var _strlen=Module["_strlen"]=function(){return(_strlen=Module["_strlen"]=Module["asm"]["strlen"]).apply(null,arguments)};var _malloc=Module["_malloc"]=function(){return(_malloc=Module["_malloc"]=Module["asm"]["malloc"]).apply(null,arguments)};var _free=Module["_free"]=function(){return(_free=Module["_free"]=Module["asm"]["free"]).apply(null,arguments)};var _emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=function(){return(_emscripten_builtin_memalign=Module["_emscripten_builtin_memalign"]=Module["asm"]["emscripten_builtin_memalign"]).apply(null,arguments)};var _setThrew=Module["_setThrew"]=function(){return(_setThrew=Module["_setThrew"]=Module["asm"]["setThrew"]).apply(null,arguments)};var _saveSetjmp=Module["_saveSetjmp"]=function(){return(_saveSetjmp=Module["_saveSetjmp"]=Module["asm"]["saveSetjmp"]).apply(null,arguments)};var stackSave=Module["stackSave"]=function(){return(stackSave=Module["stackSave"]=Module["asm"]["stackSave"]).apply(null,arguments)};var stackRestore=Module["stackRestore"]=function(){return(stackRestore=Module["stackRestore"]=Module["asm"]["stackRestore"]).apply(null,arguments)};var stackAlloc=Module["stackAlloc"]=function(){return(stackAlloc=Module["stackAlloc"]=Module["asm"]["stackAlloc"]).apply(null,arguments)};var ___cxa_can_catch=Module["___cxa_can_catch"]=function(){return(___cxa_can_catch=Module["___cxa_can_catch"]=Module["asm"]["__cxa_can_catch"]).apply(null,arguments)};var ___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=function(){return(___cxa_is_pointer_type=Module["___cxa_is_pointer_type"]=Module["asm"]["__cxa_is_pointer_type"]).apply(null,arguments)};var dynCall_iidiiii=Module["dynCall_iidiiii"]=function(){return(dynCall_iidiiii=Module["dynCall_iidiiii"]=Module["asm"]["dynCall_iidiiii"]).apply(null,arguments)};var dynCall_vii=Module["dynCall_vii"]=function(){return(dynCall_vii=Module["dynCall_vii"]=Module["asm"]["dynCall_vii"]).apply(null,arguments)};var dynCall_iiii=Module["dynCall_iiii"]=function(){return(dynCall_iiii=Module["dynCall_iiii"]=Module["asm"]["dynCall_iiii"]).apply(null,arguments)};var dynCall_iii=Module["dynCall_iii"]=function(){return(dynCall_iii=Module["dynCall_iii"]=Module["asm"]["dynCall_iii"]).apply(null,arguments)};var dynCall_ii=Module["dynCall_ii"]=function(){return(dynCall_ii=Module["dynCall_ii"]=Module["asm"]["dynCall_ii"]).apply(null,arguments)};var dynCall_jiji=Module["dynCall_jiji"]=function(){return(dynCall_jiji=Module["dynCall_jiji"]=Module["asm"]["dynCall_jiji"]).apply(null,arguments)};var dynCall_vi=Module["dynCall_vi"]=function(){return(dynCall_vi=Module["dynCall_vi"]=Module["asm"]["dynCall_vi"]).apply(null,arguments)};var dynCall_viii=Module["dynCall_viii"]=function(){return(dynCall_viii=Module["dynCall_viii"]=Module["asm"]["dynCall_viii"]).apply(null,arguments)};var dynCall_iiiii=Module["dynCall_iiiii"]=function(){return(dynCall_iiiii=Module["dynCall_iiiii"]=Module["asm"]["dynCall_iiiii"]).apply(null,arguments)};var dynCall_v=Module["dynCall_v"]=function(){return(dynCall_v=Module["dynCall_v"]=Module["asm"]["dynCall_v"]).apply(null,arguments)};var dynCall_viiiiii=Module["dynCall_viiiiii"]=function(){return(dynCall_viiiiii=Module["dynCall_viiiiii"]=Module["asm"]["dynCall_viiiiii"]).apply(null,arguments)};var dynCall_viiiii=Module["dynCall_viiiii"]=function(){return(dynCall_viiiii=Module["dynCall_viiiii"]=Module["asm"]["dynCall_viiiii"]).apply(null,arguments)};var dynCall_viiii=Module["dynCall_viiii"]=function(){return(dynCall_viiii=Module["dynCall_viiii"]=Module["asm"]["dynCall_viiii"]).apply(null,arguments)};var dynCall_iiiiii=Module["dynCall_iiiiii"]=function(){return(dynCall_iiiiii=Module["dynCall_iiiiii"]=Module["asm"]["dynCall_iiiiii"]).apply(null,arguments)};var dynCall_i=Module["dynCall_i"]=function(){return(dynCall_i=Module["dynCall_i"]=Module["asm"]["dynCall_i"]).apply(null,arguments)};var dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=function(){return(dynCall_iiiiiiii=Module["dynCall_iiiiiiii"]=Module["asm"]["dynCall_iiiiiiii"]).apply(null,arguments)};var dynCall_iiijiii=Module["dynCall_iiijiii"]=function(){return(dynCall_iiijiii=Module["dynCall_iiijiii"]=Module["asm"]["dynCall_iiijiii"]).apply(null,arguments)};var dynCall_iij=Module["dynCall_iij"]=function(){return(dynCall_iij=Module["dynCall_iij"]=Module["asm"]["dynCall_iij"]).apply(null,arguments)};var dynCall_iiiiiii=Module["dynCall_iiiiiii"]=function(){return(dynCall_iiiiiii=Module["dynCall_iiiiiii"]=Module["asm"]["dynCall_iiiiiii"]).apply(null,arguments)};var dynCall_jii=Module["dynCall_jii"]=function(){return(dynCall_jii=Module["dynCall_jii"]=Module["asm"]["dynCall_jii"]).apply(null,arguments)};var dynCall_iiifii=Module["dynCall_iiifii"]=function(){return(dynCall_iiifii=Module["dynCall_iiifii"]=Module["asm"]["dynCall_iiifii"]).apply(null,arguments)};var dynCall_viifi=Module["dynCall_viifi"]=function(){return(dynCall_viifi=Module["dynCall_viifi"]=Module["asm"]["dynCall_viifi"]).apply(null,arguments)};var dynCall_iiijii=Module["dynCall_iiijii"]=function(){return(dynCall_iiijii=Module["dynCall_iiijii"]=Module["asm"]["dynCall_iiijii"]).apply(null,arguments)};var dynCall_viiji=Module["dynCall_viiji"]=function(){return(dynCall_viiji=Module["dynCall_viiji"]=Module["asm"]["dynCall_viiji"]).apply(null,arguments)};var dynCall_iiiijii=Module["dynCall_iiiijii"]=function(){return(dynCall_iiiijii=Module["dynCall_iiiijii"]=Module["asm"]["dynCall_iiiijii"]).apply(null,arguments)};var dynCall_iiiidii=Module["dynCall_iiiidii"]=function(){return(dynCall_iiiidii=Module["dynCall_iiiidii"]=Module["asm"]["dynCall_iiiidii"]).apply(null,arguments)};var dynCall_iiiifii=Module["dynCall_iiiifii"]=function(){return(dynCall_iiiifii=Module["dynCall_iiiifii"]=Module["asm"]["dynCall_iiiifii"]).apply(null,arguments)};var dynCall_dii=Module["dynCall_dii"]=function(){return(dynCall_dii=Module["dynCall_dii"]=Module["asm"]["dynCall_dii"]).apply(null,arguments)};var dynCall_fii=Module["dynCall_fii"]=function(){return(dynCall_fii=Module["dynCall_fii"]=Module["asm"]["dynCall_fii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiii=Module["dynCall_iiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiii=Module["dynCall_iiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiii=Module["dynCall_viiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiii=Module["dynCall_viiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_fiii=Module["dynCall_fiii"]=function(){return(dynCall_fiii=Module["dynCall_fiii"]=Module["asm"]["dynCall_fiii"]).apply(null,arguments)};var dynCall_didi=Module["dynCall_didi"]=function(){return(dynCall_didi=Module["dynCall_didi"]=Module["asm"]["dynCall_didi"]).apply(null,arguments)};var dynCall_iiji=Module["dynCall_iiji"]=function(){return(dynCall_iiji=Module["dynCall_iiji"]=Module["asm"]["dynCall_iiji"]).apply(null,arguments)};var dynCall_fiji=Module["dynCall_fiji"]=function(){return(dynCall_fiji=Module["dynCall_fiji"]=Module["asm"]["dynCall_fiji"]).apply(null,arguments)};var dynCall_vifi=Module["dynCall_vifi"]=function(){return(dynCall_vifi=Module["dynCall_vifi"]=Module["asm"]["dynCall_vifi"]).apply(null,arguments)};var dynCall_ddiii=Module["dynCall_ddiii"]=function(){return(dynCall_ddiii=Module["dynCall_ddiii"]=Module["asm"]["dynCall_ddiii"]).apply(null,arguments)};var dynCall_viji=Module["dynCall_viji"]=function(){return(dynCall_viji=Module["dynCall_viji"]=Module["asm"]["dynCall_viji"]).apply(null,arguments)};var dynCall_vidi=Module["dynCall_vidi"]=function(){return(dynCall_vidi=Module["dynCall_vidi"]=Module["asm"]["dynCall_vidi"]).apply(null,arguments)};var dynCall_viidi=Module["dynCall_viidi"]=function(){return(dynCall_viidi=Module["dynCall_viidi"]=Module["asm"]["dynCall_viidi"]).apply(null,arguments)};var dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=function(){return(dynCall_iiiiiiiii=Module["dynCall_iiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=function(){return(dynCall_viiiiiiii=Module["dynCall_viiiiiiii"]=Module["asm"]["dynCall_viiiiiiii"]).apply(null,arguments)};var dynCall_iiiji=Module["dynCall_iiiji"]=function(){return(dynCall_iiiji=Module["dynCall_iiiji"]=Module["asm"]["dynCall_iiiji"]).apply(null,arguments)};var dynCall_iji=Module["dynCall_iji"]=function(){return(dynCall_iji=Module["dynCall_iji"]=Module["asm"]["dynCall_iji"]).apply(null,arguments)};var dynCall_ifi=Module["dynCall_ifi"]=function(){return(dynCall_ifi=Module["dynCall_ifi"]=Module["asm"]["dynCall_ifi"]).apply(null,arguments)};var dynCall_idi=Module["dynCall_idi"]=function(){return(dynCall_idi=Module["dynCall_idi"]=Module["asm"]["dynCall_idi"]).apply(null,arguments)};var dynCall_viiiiiiiii=Module["dynCall_viiiiiiiii"]=function(){return(dynCall_viiiiiiiii=Module["dynCall_viiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiii"]).apply(null,arguments)};var dynCall_ji=Module["dynCall_ji"]=function(){return(dynCall_ji=Module["dynCall_ji"]=Module["asm"]["dynCall_ji"]).apply(null,arguments)};var dynCall_jdi=Module["dynCall_jdi"]=function(){return(dynCall_jdi=Module["dynCall_jdi"]=Module["asm"]["dynCall_jdi"]).apply(null,arguments)};var dynCall_iijii=Module["dynCall_iijii"]=function(){return(dynCall_iijii=Module["dynCall_iijii"]=Module["asm"]["dynCall_iijii"]).apply(null,arguments)};var dynCall_jiii=Module["dynCall_jiii"]=function(){return(dynCall_jiii=Module["dynCall_jiii"]=Module["asm"]["dynCall_jiii"]).apply(null,arguments)};var dynCall_ijji=Module["dynCall_ijji"]=function(){return(dynCall_ijji=Module["dynCall_ijji"]=Module["asm"]["dynCall_ijji"]).apply(null,arguments)};var dynCall_iiiijiii=Module["dynCall_iiiijiii"]=function(){return(dynCall_iiiijiii=Module["dynCall_iiiijiii"]=Module["asm"]["dynCall_iiiijiii"]).apply(null,arguments)};var dynCall_jidi=Module["dynCall_jidi"]=function(){return(dynCall_jidi=Module["dynCall_jidi"]=Module["asm"]["dynCall_jidi"]).apply(null,arguments)};var dynCall_viiiiiii=Module["dynCall_viiiiiii"]=function(){return(dynCall_viiiiiii=Module["dynCall_viiiiiii"]=Module["asm"]["dynCall_viiiiiii"]).apply(null,arguments)};var dynCall_vifii=Module["dynCall_vifii"]=function(){return(dynCall_vifii=Module["dynCall_vifii"]=Module["asm"]["dynCall_vifii"]).apply(null,arguments)};var dynCall_jiiijii=Module["dynCall_jiiijii"]=function(){return(dynCall_jiiijii=Module["dynCall_jiiijii"]=Module["asm"]["dynCall_jiiijii"]).apply(null,arguments)};var dynCall_viiijiii=Module["dynCall_viiijiii"]=function(){return(dynCall_viiijiii=Module["dynCall_viiijiii"]=Module["asm"]["dynCall_viiijiii"]).apply(null,arguments)};var dynCall_viifffffi=Module["dynCall_viifffffi"]=function(){return(dynCall_viifffffi=Module["dynCall_viifffffi"]=Module["asm"]["dynCall_viifffffi"]).apply(null,arguments)};var dynCall_fifi=Module["dynCall_fifi"]=function(){return(dynCall_fifi=Module["dynCall_fifi"]=Module["asm"]["dynCall_fifi"]).apply(null,arguments)};var dynCall_fiiiii=Module["dynCall_fiiiii"]=function(){return(dynCall_fiiiii=Module["dynCall_fiiiii"]=Module["asm"]["dynCall_fiiiii"]).apply(null,arguments)};var dynCall_viiiiifffiii=Module["dynCall_viiiiifffiii"]=function(){return(dynCall_viiiiifffiii=Module["dynCall_viiiiifffiii"]=Module["asm"]["dynCall_viiiiifffiii"]).apply(null,arguments)};var dynCall_fffi=Module["dynCall_fffi"]=function(){return(dynCall_fffi=Module["dynCall_fffi"]=Module["asm"]["dynCall_fffi"]).apply(null,arguments)};var dynCall_iiiiifiiiii=Module["dynCall_iiiiifiiiii"]=function(){return(dynCall_iiiiifiiiii=Module["dynCall_iiiiifiiiii"]=Module["asm"]["dynCall_iiiiifiiiii"]).apply(null,arguments)};var dynCall_iiiiiifii=Module["dynCall_iiiiiifii"]=function(){return(dynCall_iiiiiifii=Module["dynCall_iiiiiifii"]=Module["asm"]["dynCall_iiiiiifii"]).apply(null,arguments)};var dynCall_viiiiifi=Module["dynCall_viiiiifi"]=function(){return(dynCall_viiiiifi=Module["dynCall_viiiiifi"]=Module["asm"]["dynCall_viiiiifi"]).apply(null,arguments)};var dynCall_dddi=Module["dynCall_dddi"]=function(){return(dynCall_dddi=Module["dynCall_dddi"]=Module["asm"]["dynCall_dddi"]).apply(null,arguments)};var dynCall_viffi=Module["dynCall_viffi"]=function(){return(dynCall_viffi=Module["dynCall_viffi"]=Module["asm"]["dynCall_viffi"]).apply(null,arguments)};var dynCall_viiifi=Module["dynCall_viiifi"]=function(){return(dynCall_viiifi=Module["dynCall_viiifi"]=Module["asm"]["dynCall_viiifi"]).apply(null,arguments)};var dynCall_ffi=Module["dynCall_ffi"]=function(){return(dynCall_ffi=Module["dynCall_ffi"]=Module["asm"]["dynCall_ffi"]).apply(null,arguments)};var dynCall_iiiiiiiifiii=Module["dynCall_iiiiiiiifiii"]=function(){return(dynCall_iiiiiiiifiii=Module["dynCall_iiiiiiiifiii"]=Module["asm"]["dynCall_iiiiiiiifiii"]).apply(null,arguments)};var dynCall_iiiiiiifii=Module["dynCall_iiiiiiifii"]=function(){return(dynCall_iiiiiiifii=Module["dynCall_iiiiiiifii"]=Module["asm"]["dynCall_iiiiiiifii"]).apply(null,arguments)};var dynCall_viifiiiiii=Module["dynCall_viifiiiiii"]=function(){return(dynCall_viifiiiiii=Module["dynCall_viifiiiiii"]=Module["asm"]["dynCall_viifiiiiii"]).apply(null,arguments)};var dynCall_iifii=Module["dynCall_iifii"]=function(){return(dynCall_iifii=Module["dynCall_iifii"]=Module["asm"]["dynCall_iifii"]).apply(null,arguments)};var dynCall_vfi=Module["dynCall_vfi"]=function(){return(dynCall_vfi=Module["dynCall_vfi"]=Module["asm"]["dynCall_vfi"]).apply(null,arguments)};var dynCall_fiiii=Module["dynCall_fiiii"]=function(){return(dynCall_fiiii=Module["dynCall_fiiii"]=Module["asm"]["dynCall_fiiii"]).apply(null,arguments)};var dynCall_fi=Module["dynCall_fi"]=function(){return(dynCall_fi=Module["dynCall_fi"]=Module["asm"]["dynCall_fi"]).apply(null,arguments)};var dynCall_viiiji=Module["dynCall_viiiji"]=function(){return(dynCall_viiiji=Module["dynCall_viiiji"]=Module["asm"]["dynCall_viiiji"]).apply(null,arguments)};var dynCall_viiiiiiiiii=Module["dynCall_viiiiiiiiii"]=function(){return(dynCall_viiiiiiiiii=Module["dynCall_viiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiffi=Module["dynCall_viiiiiffi"]=function(){return(dynCall_viiiiiffi=Module["dynCall_viiiiiffi"]=Module["asm"]["dynCall_viiiiiffi"]).apply(null,arguments)};var dynCall_viiifii=Module["dynCall_viiifii"]=function(){return(dynCall_viiifii=Module["dynCall_viiifii"]=Module["asm"]["dynCall_viiifii"]).apply(null,arguments)};var dynCall_viffffi=Module["dynCall_viffffi"]=function(){return(dynCall_viffffi=Module["dynCall_viffffi"]=Module["asm"]["dynCall_viffffi"]).apply(null,arguments)};var dynCall_viifii=Module["dynCall_viifii"]=function(){return(dynCall_viifii=Module["dynCall_viifii"]=Module["asm"]["dynCall_viifii"]).apply(null,arguments)};var dynCall_vifffi=Module["dynCall_vifffi"]=function(){return(dynCall_vifffi=Module["dynCall_vifffi"]=Module["asm"]["dynCall_vifffi"]).apply(null,arguments)};var dynCall_viiiiiiiiiii=Module["dynCall_viiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiii=Module["dynCall_viiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_fiffffi=Module["dynCall_fiffffi"]=function(){return(dynCall_fiffffi=Module["dynCall_fiffffi"]=Module["asm"]["dynCall_fiffffi"]).apply(null,arguments)};var dynCall_jjji=Module["dynCall_jjji"]=function(){return(dynCall_jjji=Module["dynCall_jjji"]=Module["asm"]["dynCall_jjji"]).apply(null,arguments)};var dynCall_ddi=Module["dynCall_ddi"]=function(){return(dynCall_ddi=Module["dynCall_ddi"]=Module["asm"]["dynCall_ddi"]).apply(null,arguments)};var dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=function(){return(dynCall_iiiiiiiiii=Module["dynCall_iiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiii"]).apply(null,arguments)};var dynCall_jjii=Module["dynCall_jjii"]=function(){return(dynCall_jjii=Module["dynCall_jjii"]=Module["asm"]["dynCall_jjii"]).apply(null,arguments)};var dynCall_jji=Module["dynCall_jji"]=function(){return(dynCall_jji=Module["dynCall_jji"]=Module["asm"]["dynCall_jji"]).apply(null,arguments)};var dynCall_diii=Module["dynCall_diii"]=function(){return(dynCall_diii=Module["dynCall_diii"]=Module["asm"]["dynCall_diii"]).apply(null,arguments)};var dynCall_iidi=Module["dynCall_iidi"]=function(){return(dynCall_iidi=Module["dynCall_iidi"]=Module["asm"]["dynCall_iidi"]).apply(null,arguments)};var dynCall_iifi=Module["dynCall_iifi"]=function(){return(dynCall_iifi=Module["dynCall_iifi"]=Module["asm"]["dynCall_iifi"]).apply(null,arguments)};var dynCall_jiiii=Module["dynCall_jiiii"]=function(){return(dynCall_jiiii=Module["dynCall_jiiii"]=Module["asm"]["dynCall_jiiii"]).apply(null,arguments)};var dynCall_diiii=Module["dynCall_diiii"]=function(){return(dynCall_diiii=Module["dynCall_diiii"]=Module["asm"]["dynCall_diiii"]).apply(null,arguments)};var dynCall_vijiiii=Module["dynCall_vijiiii"]=function(){return(dynCall_vijiiii=Module["dynCall_vijiiii"]=Module["asm"]["dynCall_vijiiii"]).apply(null,arguments)};var dynCall_viiiidi=Module["dynCall_viiiidi"]=function(){return(dynCall_viiiidi=Module["dynCall_viiiidi"]=Module["asm"]["dynCall_viiiidi"]).apply(null,arguments)};var dynCall_ijii=Module["dynCall_ijii"]=function(){return(dynCall_ijii=Module["dynCall_ijii"]=Module["asm"]["dynCall_ijii"]).apply(null,arguments)};var dynCall_viiffi=Module["dynCall_viiffi"]=function(){return(dynCall_viiffi=Module["dynCall_viiffi"]=Module["asm"]["dynCall_viiffi"]).apply(null,arguments)};var dynCall_viiiifii=Module["dynCall_viiiifii"]=function(){return(dynCall_viiiifii=Module["dynCall_viiiifii"]=Module["asm"]["dynCall_viiiifii"]).apply(null,arguments)};var dynCall_iiiifi=Module["dynCall_iiiifi"]=function(){return(dynCall_iiiifi=Module["dynCall_iiiifi"]=Module["asm"]["dynCall_iiiifi"]).apply(null,arguments)};var dynCall_iiiiiji=Module["dynCall_iiiiiji"]=function(){return(dynCall_iiiiiji=Module["dynCall_iiiiiji"]=Module["asm"]["dynCall_iiiiiji"]).apply(null,arguments)};var dynCall_iiiiifi=Module["dynCall_iiiiifi"]=function(){return(dynCall_iiiiifi=Module["dynCall_iiiiifi"]=Module["asm"]["dynCall_iiiiifi"]).apply(null,arguments)};var dynCall_iijji=Module["dynCall_iijji"]=function(){return(dynCall_iijji=Module["dynCall_iijji"]=Module["asm"]["dynCall_iijji"]).apply(null,arguments)};var dynCall_iiijjji=Module["dynCall_iiijjji"]=function(){return(dynCall_iiijjji=Module["dynCall_iiijjji"]=Module["asm"]["dynCall_iiijjji"]).apply(null,arguments)};var dynCall_vijiiiii=Module["dynCall_vijiiiii"]=function(){return(dynCall_vijiiiii=Module["dynCall_vijiiiii"]=Module["asm"]["dynCall_vijiiiii"]).apply(null,arguments)};var dynCall_vijii=Module["dynCall_vijii"]=function(){return(dynCall_vijii=Module["dynCall_vijii"]=Module["asm"]["dynCall_vijii"]).apply(null,arguments)};var dynCall_iiiijjiii=Module["dynCall_iiiijjiii"]=function(){return(dynCall_iiiijjiii=Module["dynCall_iiiijjiii"]=Module["asm"]["dynCall_iiiijjiii"]).apply(null,arguments)};var dynCall_vijiii=Module["dynCall_vijiii"]=function(){return(dynCall_vijiii=Module["dynCall_vijiii"]=Module["asm"]["dynCall_vijiii"]).apply(null,arguments)};var dynCall_iiiiij=Module["dynCall_iiiiij"]=function(){return(dynCall_iiiiij=Module["dynCall_iiiiij"]=Module["asm"]["dynCall_iiiiij"]).apply(null,arguments)};var dynCall_vijjji=Module["dynCall_vijjji"]=function(){return(dynCall_vijjji=Module["dynCall_vijjji"]=Module["asm"]["dynCall_vijjji"]).apply(null,arguments)};var dynCall_iiiiijiii=Module["dynCall_iiiiijiii"]=function(){return(dynCall_iiiiijiii=Module["dynCall_iiiiijiii"]=Module["asm"]["dynCall_iiiiijiii"]).apply(null,arguments)};var dynCall_iijiiii=Module["dynCall_iijiiii"]=function(){return(dynCall_iijiiii=Module["dynCall_iijiiii"]=Module["asm"]["dynCall_iijiiii"]).apply(null,arguments)};var dynCall_jijiii=Module["dynCall_jijiii"]=function(){return(dynCall_jijiii=Module["dynCall_jijiii"]=Module["asm"]["dynCall_jijiii"]).apply(null,arguments)};var dynCall_viijii=Module["dynCall_viijii"]=function(){return(dynCall_viijii=Module["dynCall_viijii"]=Module["asm"]["dynCall_viijii"]).apply(null,arguments)};var dynCall_iijiiiiii=Module["dynCall_iijiiiiii"]=function(){return(dynCall_iijiiiiii=Module["dynCall_iijiiiiii"]=Module["asm"]["dynCall_iijiiiiii"]).apply(null,arguments)};var dynCall_iijjiiiiii=Module["dynCall_iijjiiiiii"]=function(){return(dynCall_iijjiiiiii=Module["dynCall_iijjiiiiii"]=Module["asm"]["dynCall_iijjiiiiii"]).apply(null,arguments)};var dynCall_iiiijjii=Module["dynCall_iiiijjii"]=function(){return(dynCall_iiiijjii=Module["dynCall_iiiijjii"]=Module["asm"]["dynCall_iiiijjii"]).apply(null,arguments)};var dynCall_j=Module["dynCall_j"]=function(){return(dynCall_j=Module["dynCall_j"]=Module["asm"]["dynCall_j"]).apply(null,arguments)};var dynCall_iiiiiiiiiji=Module["dynCall_iiiiiiiiiji"]=function(){return(dynCall_iiiiiiiiiji=Module["dynCall_iiiiiiiiiji"]=Module["asm"]["dynCall_iiiiiiiiiji"]).apply(null,arguments)};var dynCall_vji=Module["dynCall_vji"]=function(){return(dynCall_vji=Module["dynCall_vji"]=Module["asm"]["dynCall_vji"]).apply(null,arguments)};var dynCall_viidii=Module["dynCall_viidii"]=function(){return(dynCall_viidii=Module["dynCall_viidii"]=Module["asm"]["dynCall_viidii"]).apply(null,arguments)};var dynCall_fiifii=Module["dynCall_fiifii"]=function(){return(dynCall_fiifii=Module["dynCall_fiifii"]=Module["asm"]["dynCall_fiifii"]).apply(null,arguments)};var dynCall_iiiiji=Module["dynCall_iiiiji"]=function(){return(dynCall_iiiiji=Module["dynCall_iiiiji"]=Module["asm"]["dynCall_iiiiji"]).apply(null,arguments)};var dynCall_viiiiji=Module["dynCall_viiiiji"]=function(){return(dynCall_viiiiji=Module["dynCall_viiiiji"]=Module["asm"]["dynCall_viiiiji"]).apply(null,arguments)};var dynCall_viijiiijiiii=Module["dynCall_viijiiijiiii"]=function(){return(dynCall_viijiiijiiii=Module["dynCall_viijiiijiiii"]=Module["asm"]["dynCall_viijiiijiiii"]).apply(null,arguments)};var dynCall_viiiijjiii=Module["dynCall_viiiijjiii"]=function(){return(dynCall_viiiijjiii=Module["dynCall_viiiijjiii"]=Module["asm"]["dynCall_viiiijjiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiii=Module["dynCall_iiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiii=Module["dynCall_iiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiii"]).apply(null,arguments)};var dynCall_vijji=Module["dynCall_vijji"]=function(){return(dynCall_vijji=Module["dynCall_vijji"]=Module["asm"]["dynCall_vijji"]).apply(null,arguments)};var dynCall_dji=Module["dynCall_dji"]=function(){return(dynCall_dji=Module["dynCall_dji"]=Module["asm"]["dynCall_dji"]).apply(null,arguments)};var dynCall_fiiffi=Module["dynCall_fiiffi"]=function(){return(dynCall_fiiffi=Module["dynCall_fiiffi"]=Module["asm"]["dynCall_fiiffi"]).apply(null,arguments)};var dynCall_viiififii=Module["dynCall_viiififii"]=function(){return(dynCall_viiififii=Module["dynCall_viiififii"]=Module["asm"]["dynCall_viiififii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_iijiii=Module["dynCall_iijiii"]=function(){return(dynCall_iijiii=Module["dynCall_iijiii"]=Module["asm"]["dynCall_iijiii"]).apply(null,arguments)};var dynCall_iiifi=Module["dynCall_iiifi"]=function(){return(dynCall_iiifi=Module["dynCall_iiifi"]=Module["asm"]["dynCall_iiifi"]).apply(null,arguments)};var dynCall_viiiifi=Module["dynCall_viiiifi"]=function(){return(dynCall_viiiifi=Module["dynCall_viiiifi"]=Module["asm"]["dynCall_viiiifi"]).apply(null,arguments)};var dynCall_jijii=Module["dynCall_jijii"]=function(){return(dynCall_jijii=Module["dynCall_jijii"]=Module["asm"]["dynCall_jijii"]).apply(null,arguments)};var dynCall_diidi=Module["dynCall_diidi"]=function(){return(dynCall_diidi=Module["dynCall_diidi"]=Module["asm"]["dynCall_diidi"]).apply(null,arguments)};var dynCall_jiiji=Module["dynCall_jiiji"]=function(){return(dynCall_jiiji=Module["dynCall_jiiji"]=Module["asm"]["dynCall_jiiji"]).apply(null,arguments)};var dynCall_fiifi=Module["dynCall_fiifi"]=function(){return(dynCall_fiifi=Module["dynCall_fiifi"]=Module["asm"]["dynCall_fiifi"]).apply(null,arguments)};var dynCall_iiffi=Module["dynCall_iiffi"]=function(){return(dynCall_iiffi=Module["dynCall_iiffi"]=Module["asm"]["dynCall_iiffi"]).apply(null,arguments)};var dynCall_fiffi=Module["dynCall_fiffi"]=function(){return(dynCall_fiffi=Module["dynCall_fiffi"]=Module["asm"]["dynCall_fiffi"]).apply(null,arguments)};var dynCall_viijji=Module["dynCall_viijji"]=function(){return(dynCall_viijji=Module["dynCall_viijji"]=Module["asm"]["dynCall_viijji"]).apply(null,arguments)};var dynCall_viiiijii=Module["dynCall_viiiijii"]=function(){return(dynCall_viiiijii=Module["dynCall_viiiijii"]=Module["asm"]["dynCall_viiiijii"]).apply(null,arguments)};var dynCall_iiddi=Module["dynCall_iiddi"]=function(){return(dynCall_iiddi=Module["dynCall_iiddi"]=Module["asm"]["dynCall_iiddi"]).apply(null,arguments)};var dynCall_vjjjiiii=Module["dynCall_vjjjiiii"]=function(){return(dynCall_vjjjiiii=Module["dynCall_vjjjiiii"]=Module["asm"]["dynCall_vjjjiiii"]).apply(null,arguments)};var dynCall_vjiiiii=Module["dynCall_vjiiiii"]=function(){return(dynCall_vjiiiii=Module["dynCall_vjiiiii"]=Module["asm"]["dynCall_vjiiiii"]).apply(null,arguments)};var dynCall_jiiiii=Module["dynCall_jiiiii"]=function(){return(dynCall_jiiiii=Module["dynCall_jiiiii"]=Module["asm"]["dynCall_jiiiii"]).apply(null,arguments)};var dynCall_iidiii=Module["dynCall_iidiii"]=function(){return(dynCall_iidiii=Module["dynCall_iidiii"]=Module["asm"]["dynCall_iidiii"]).apply(null,arguments)};var dynCall_viiijji=Module["dynCall_viiijji"]=function(){return(dynCall_viiijji=Module["dynCall_viiijji"]=Module["asm"]["dynCall_viiijji"]).apply(null,arguments)};var dynCall_vidddddi=Module["dynCall_vidddddi"]=function(){return(dynCall_vidddddi=Module["dynCall_vidddddi"]=Module["asm"]["dynCall_vidddddi"]).apply(null,arguments)};var dynCall_iidii=Module["dynCall_iidii"]=function(){return(dynCall_iidii=Module["dynCall_iidii"]=Module["asm"]["dynCall_iidii"]).apply(null,arguments)};var dynCall_iidddi=Module["dynCall_iidddi"]=function(){return(dynCall_iidddi=Module["dynCall_iidddi"]=Module["asm"]["dynCall_iidddi"]).apply(null,arguments)};var dynCall_di=Module["dynCall_di"]=function(){return(dynCall_di=Module["dynCall_di"]=Module["asm"]["dynCall_di"]).apply(null,arguments)};var dynCall_jjiiii=Module["dynCall_jjiiii"]=function(){return(dynCall_jjiiii=Module["dynCall_jjiiii"]=Module["asm"]["dynCall_jjiiii"]).apply(null,arguments)};var dynCall_viiijii=Module["dynCall_viiijii"]=function(){return(dynCall_viiijii=Module["dynCall_viiijii"]=Module["asm"]["dynCall_viiijii"]).apply(null,arguments)};var dynCall_iiiijiiiii=Module["dynCall_iiiijiiiii"]=function(){return(dynCall_iiiijiiiii=Module["dynCall_iiiijiiiii"]=Module["asm"]["dynCall_iiiijiiiii"]).apply(null,arguments)};var dynCall_viijiiiii=Module["dynCall_viijiiiii"]=function(){return(dynCall_viijiiiii=Module["dynCall_viijiiiii"]=Module["asm"]["dynCall_viijiiiii"]).apply(null,arguments)};var dynCall_viijiii=Module["dynCall_viijiii"]=function(){return(dynCall_viijiii=Module["dynCall_viijiii"]=Module["asm"]["dynCall_viijiii"]).apply(null,arguments)};var dynCall_iiiiijii=Module["dynCall_iiiiijii"]=function(){return(dynCall_iiiiijii=Module["dynCall_iiiiijii"]=Module["asm"]["dynCall_iiiiijii"]).apply(null,arguments)};var dynCall_viiiijji=Module["dynCall_viiiijji"]=function(){return(dynCall_viiiijji=Module["dynCall_viiiijji"]=Module["asm"]["dynCall_viiiijji"]).apply(null,arguments)};var dynCall_iiiffi=Module["dynCall_iiiffi"]=function(){return(dynCall_iiiffi=Module["dynCall_iiiffi"]=Module["asm"]["dynCall_iiiffi"]).apply(null,arguments)};var dynCall_iiffii=Module["dynCall_iiffii"]=function(){return(dynCall_iiffii=Module["dynCall_iiffii"]=Module["asm"]["dynCall_iiffii"]).apply(null,arguments)};var dynCall_iiifiii=Module["dynCall_iiifiii"]=function(){return(dynCall_iiifiii=Module["dynCall_iiifiii"]=Module["asm"]["dynCall_iiifiii"]).apply(null,arguments)};var dynCall_iiififii=Module["dynCall_iiififii"]=function(){return(dynCall_iiififii=Module["dynCall_iiififii"]=Module["asm"]["dynCall_iiififii"]).apply(null,arguments)};var dynCall_iiifiiiii=Module["dynCall_iiifiiiii"]=function(){return(dynCall_iiifiiiii=Module["dynCall_iiifiiiii"]=Module["asm"]["dynCall_iiifiiiii"]).apply(null,arguments)};var dynCall_iiffifiiii=Module["dynCall_iiffifiiii"]=function(){return(dynCall_iiffifiiii=Module["dynCall_iiffifiiii"]=Module["asm"]["dynCall_iiffifiiii"]).apply(null,arguments)};var dynCall_iifiifiiii=Module["dynCall_iifiifiiii"]=function(){return(dynCall_iifiifiiii=Module["dynCall_iifiifiiii"]=Module["asm"]["dynCall_iifiifiiii"]).apply(null,arguments)};var dynCall_iiiifiii=Module["dynCall_iiiifiii"]=function(){return(dynCall_iiiifiii=Module["dynCall_iiiifiii"]=Module["asm"]["dynCall_iiiifiii"]).apply(null,arguments)};var dynCall_iiifiiii=Module["dynCall_iiifiiii"]=function(){return(dynCall_iiifiiii=Module["dynCall_iiifiiii"]=Module["asm"]["dynCall_iiifiiii"]).apply(null,arguments)};var dynCall_iiiffiii=Module["dynCall_iiiffiii"]=function(){return(dynCall_iiiffiii=Module["dynCall_iiiffiii"]=Module["asm"]["dynCall_iiiffiii"]).apply(null,arguments)};var dynCall_iiiiifii=Module["dynCall_iiiiifii"]=function(){return(dynCall_iiiiifii=Module["dynCall_iiiiifii"]=Module["asm"]["dynCall_iiiiifii"]).apply(null,arguments)};var dynCall_viiiffii=Module["dynCall_viiiffii"]=function(){return(dynCall_viiiffii=Module["dynCall_viiiffii"]=Module["asm"]["dynCall_viiiffii"]).apply(null,arguments)};var dynCall_jjjii=Module["dynCall_jjjii"]=function(){return(dynCall_jjjii=Module["dynCall_jjjii"]=Module["asm"]["dynCall_jjjii"]).apply(null,arguments)};var dynCall_vjiii=Module["dynCall_vjiii"]=function(){return(dynCall_vjiii=Module["dynCall_vjiii"]=Module["asm"]["dynCall_vjiii"]).apply(null,arguments)};var dynCall_jiiijiii=Module["dynCall_jiiijiii"]=function(){return(dynCall_jiiijiii=Module["dynCall_jiiijiii"]=Module["asm"]["dynCall_jiiijiii"]).apply(null,arguments)};var dynCall_jiiiiji=Module["dynCall_jiiiiji"]=function(){return(dynCall_jiiiiji=Module["dynCall_jiiiiji"]=Module["asm"]["dynCall_jiiiiji"]).apply(null,arguments)};var dynCall_jiiiijiii=Module["dynCall_jiiiijiii"]=function(){return(dynCall_jiiiijiii=Module["dynCall_jiiiijiii"]=Module["asm"]["dynCall_jiiiijiii"]).apply(null,arguments)};var dynCall_jiiiiiiii=Module["dynCall_jiiiiiiii"]=function(){return(dynCall_jiiiiiiii=Module["dynCall_jiiiiiiii"]=Module["asm"]["dynCall_jiiiiiiii"]).apply(null,arguments)};var dynCall_jiiiiiii=Module["dynCall_jiiiiiii"]=function(){return(dynCall_jiiiiiii=Module["dynCall_jiiiiiii"]=Module["asm"]["dynCall_jiiiiiii"]).apply(null,arguments)};var dynCall_vijjiii=Module["dynCall_vijjiii"]=function(){return(dynCall_vijjiii=Module["dynCall_vijjiii"]=Module["asm"]["dynCall_vijjiii"]).apply(null,arguments)};var dynCall_vjii=Module["dynCall_vjii"]=function(){return(dynCall_vjii=Module["dynCall_vjii"]=Module["asm"]["dynCall_vjii"]).apply(null,arguments)};var dynCall_jijiji=Module["dynCall_jijiji"]=function(){return(dynCall_jijiji=Module["dynCall_jijiji"]=Module["asm"]["dynCall_jijiji"]).apply(null,arguments)};var dynCall_jijji=Module["dynCall_jijji"]=function(){return(dynCall_jijji=Module["dynCall_jijji"]=Module["asm"]["dynCall_jijji"]).apply(null,arguments)};var dynCall_jiiiji=Module["dynCall_jiiiji"]=function(){return(dynCall_jiiiji=Module["dynCall_jiiiji"]=Module["asm"]["dynCall_jiiiji"]).apply(null,arguments)};var dynCall_jjiji=Module["dynCall_jjiji"]=function(){return(dynCall_jjiji=Module["dynCall_jjiji"]=Module["asm"]["dynCall_jjiji"]).apply(null,arguments)};var dynCall_vijjiiiii=Module["dynCall_vijjiiiii"]=function(){return(dynCall_vijjiiiii=Module["dynCall_vijjiiiii"]=Module["asm"]["dynCall_vijjiiiii"]).apply(null,arguments)};var dynCall_jjjji=Module["dynCall_jjjji"]=function(){return(dynCall_jjjji=Module["dynCall_jjjji"]=Module["asm"]["dynCall_jjjji"]).apply(null,arguments)};var dynCall_vjiiii=Module["dynCall_vjiiii"]=function(){return(dynCall_vjiiii=Module["dynCall_vjiiii"]=Module["asm"]["dynCall_vjiiii"]).apply(null,arguments)};var dynCall_jiiiiiiiii=Module["dynCall_jiiiiiiiii"]=function(){return(dynCall_jiiiiiiiii=Module["dynCall_jiiiiiiiii"]=Module["asm"]["dynCall_jiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiffi=Module["dynCall_iiiiiffi"]=function(){return(dynCall_iiiiiffi=Module["dynCall_iiiiiffi"]=Module["asm"]["dynCall_iiiiiffi"]).apply(null,arguments)};var dynCall_viiiiiiifiii=Module["dynCall_viiiiiiifiii"]=function(){return(dynCall_viiiiiiifiii=Module["dynCall_viiiiiiifiii"]=Module["asm"]["dynCall_viiiiiiifiii"]).apply(null,arguments)};var dynCall_fiiifii=Module["dynCall_fiiifii"]=function(){return(dynCall_fiiifii=Module["dynCall_fiiifii"]=Module["asm"]["dynCall_fiiifii"]).apply(null,arguments)};var dynCall_fifii=Module["dynCall_fifii"]=function(){return(dynCall_fifii=Module["dynCall_fifii"]=Module["asm"]["dynCall_fifii"]).apply(null,arguments)};var dynCall_iiiffii=Module["dynCall_iiiffii"]=function(){return(dynCall_iiiffii=Module["dynCall_iiiffii"]=Module["asm"]["dynCall_iiiffii"]).apply(null,arguments)};var dynCall_fifiii=Module["dynCall_fifiii"]=function(){return(dynCall_fifiii=Module["dynCall_fifiii"]=Module["asm"]["dynCall_fifiii"]).apply(null,arguments)};var dynCall_fiiifi=Module["dynCall_fiiifi"]=function(){return(dynCall_fiiifi=Module["dynCall_fiiifi"]=Module["asm"]["dynCall_fiiifi"]).apply(null,arguments)};var dynCall_viiiiffii=Module["dynCall_viiiiffii"]=function(){return(dynCall_viiiiffii=Module["dynCall_viiiiffii"]=Module["asm"]["dynCall_viiiiffii"]).apply(null,arguments)};var dynCall_viiiiifffi=Module["dynCall_viiiiifffi"]=function(){return(dynCall_viiiiifffi=Module["dynCall_viiiiifffi"]=Module["asm"]["dynCall_viiiiifffi"]).apply(null,arguments)};var dynCall_viiifffi=Module["dynCall_viiifffi"]=function(){return(dynCall_viiifffi=Module["dynCall_viiifffi"]=Module["asm"]["dynCall_viiifffi"]).apply(null,arguments)};var dynCall_viiiffi=Module["dynCall_viiiffi"]=function(){return(dynCall_viiiffi=Module["dynCall_viiiffi"]=Module["asm"]["dynCall_viiiffi"]).apply(null,arguments)};var dynCall_fifiiiii=Module["dynCall_fifiiiii"]=function(){return(dynCall_fifiiiii=Module["dynCall_fifiiiii"]=Module["asm"]["dynCall_fifiiiii"]).apply(null,arguments)};var dynCall_viifiii=Module["dynCall_viifiii"]=function(){return(dynCall_viifiii=Module["dynCall_viifiii"]=Module["asm"]["dynCall_viifiii"]).apply(null,arguments)};var dynCall_vifiiiii=Module["dynCall_vifiiiii"]=function(){return(dynCall_vifiiiii=Module["dynCall_vifiiiii"]=Module["asm"]["dynCall_vifiiiii"]).apply(null,arguments)};var dynCall_viffiifffiii=Module["dynCall_viffiifffiii"]=function(){return(dynCall_viffiifffiii=Module["dynCall_viffiifffiii"]=Module["asm"]["dynCall_viffiifffiii"]).apply(null,arguments)};var dynCall_ffffffi=Module["dynCall_ffffffi"]=function(){return(dynCall_ffffffi=Module["dynCall_ffffffi"]=Module["asm"]["dynCall_ffffffi"]).apply(null,arguments)};var dynCall_viiiiiifi=Module["dynCall_viiiiiifi"]=function(){return(dynCall_viiiiiifi=Module["dynCall_viiiiiifi"]=Module["asm"]["dynCall_viiiiiifi"]).apply(null,arguments)};var dynCall_viiiiffi=Module["dynCall_viiiiffi"]=function(){return(dynCall_viiiiffi=Module["dynCall_viiiiffi"]=Module["asm"]["dynCall_viiiiffi"]).apply(null,arguments)};var dynCall_fiiiiii=Module["dynCall_fiiiiii"]=function(){return(dynCall_fiiiiii=Module["dynCall_fiiiiii"]=Module["asm"]["dynCall_fiiiiii"]).apply(null,arguments)};var dynCall_fifffi=Module["dynCall_fifffi"]=function(){return(dynCall_fifffi=Module["dynCall_fifffi"]=Module["asm"]["dynCall_fifffi"]).apply(null,arguments)};var dynCall_viffiiiii=Module["dynCall_viffiiiii"]=function(){return(dynCall_viffiiiii=Module["dynCall_viffiiiii"]=Module["asm"]["dynCall_viffiiiii"]).apply(null,arguments)};var dynCall_vifffffi=Module["dynCall_vifffffi"]=function(){return(dynCall_vifffffi=Module["dynCall_vifffffi"]=Module["asm"]["dynCall_vifffffi"]).apply(null,arguments)};var dynCall_vifiii=Module["dynCall_vifiii"]=function(){return(dynCall_vifiii=Module["dynCall_vifiii"]=Module["asm"]["dynCall_vifiii"]).apply(null,arguments)};var dynCall_iifiifiii=Module["dynCall_iifiifiii"]=function(){return(dynCall_iifiifiii=Module["dynCall_iifiifiii"]=Module["asm"]["dynCall_iifiifiii"]).apply(null,arguments)};var dynCall_iifiiii=Module["dynCall_iifiiii"]=function(){return(dynCall_iifiiii=Module["dynCall_iifiiii"]=Module["asm"]["dynCall_iifiiii"]).apply(null,arguments)};var dynCall_viddi=Module["dynCall_viddi"]=function(){return(dynCall_viddi=Module["dynCall_viddi"]=Module["asm"]["dynCall_viddi"]).apply(null,arguments)};var dynCall_vijjjji=Module["dynCall_vijjjji"]=function(){return(dynCall_vijjjji=Module["dynCall_vijjjji"]=Module["asm"]["dynCall_vijjjji"]).apply(null,arguments)};var dynCall_iijjjji=Module["dynCall_iijjjji"]=function(){return(dynCall_iijjjji=Module["dynCall_iijjjji"]=Module["asm"]["dynCall_iijjjji"]).apply(null,arguments)};var dynCall_iiidi=Module["dynCall_iiidi"]=function(){return(dynCall_iiidi=Module["dynCall_iiidi"]=Module["asm"]["dynCall_iiidi"]).apply(null,arguments)};var dynCall_iijjjjiii=Module["dynCall_iijjjjiii"]=function(){return(dynCall_iijjjjiii=Module["dynCall_iijjjjiii"]=Module["asm"]["dynCall_iijjjjiii"]).apply(null,arguments)};var dynCall_iiiidi=Module["dynCall_iiiidi"]=function(){return(dynCall_iiiidi=Module["dynCall_iiiidi"]=Module["asm"]["dynCall_iiiidi"]).apply(null,arguments)};var dynCall_viiidi=Module["dynCall_viiidi"]=function(){return(dynCall_viiidi=Module["dynCall_viiidi"]=Module["asm"]["dynCall_viiidi"]).apply(null,arguments)};var dynCall_ffffi=Module["dynCall_ffffi"]=function(){return(dynCall_ffffi=Module["dynCall_ffffi"]=Module["asm"]["dynCall_ffffi"]).apply(null,arguments)};var dynCall_iiffffiii=Module["dynCall_iiffffiii"]=function(){return(dynCall_iiffffiii=Module["dynCall_iiffffiii"]=Module["asm"]["dynCall_iiffffiii"]).apply(null,arguments)};var dynCall_vffi=Module["dynCall_vffi"]=function(){return(dynCall_vffi=Module["dynCall_vffi"]=Module["asm"]["dynCall_vffi"]).apply(null,arguments)};var dynCall_iiidfi=Module["dynCall_iiidfi"]=function(){return(dynCall_iiidfi=Module["dynCall_iiidfi"]=Module["asm"]["dynCall_iiidfi"]).apply(null,arguments)};var dynCall_iiijfi=Module["dynCall_iiijfi"]=function(){return(dynCall_iiijfi=Module["dynCall_iiijfi"]=Module["asm"]["dynCall_iiijfi"]).apply(null,arguments)};var dynCall_iifffi=Module["dynCall_iifffi"]=function(){return(dynCall_iifffi=Module["dynCall_iifffi"]=Module["asm"]["dynCall_iifffi"]).apply(null,arguments)};var dynCall_iiiififi=Module["dynCall_iiiififi"]=function(){return(dynCall_iiiififi=Module["dynCall_iiiififi"]=Module["asm"]["dynCall_iiiififi"]).apply(null,arguments)};var dynCall_iiiffifiiii=Module["dynCall_iiiffifiiii"]=function(){return(dynCall_iiiffifiiii=Module["dynCall_iiiffifiiii"]=Module["asm"]["dynCall_iiiffifiiii"]).apply(null,arguments)};var dynCall_iiifiifiii=Module["dynCall_iiifiifiii"]=function(){return(dynCall_iiifiifiii=Module["dynCall_iiifiifiii"]=Module["asm"]["dynCall_iiifiifiii"]).apply(null,arguments)};var dynCall_iiifiifiiiii=Module["dynCall_iiifiifiiiii"]=function(){return(dynCall_iiifiifiiiii=Module["dynCall_iiifiifiiiii"]=Module["asm"]["dynCall_iiifiifiiiii"]).apply(null,arguments)};var dynCall_ifii=Module["dynCall_ifii"]=function(){return(dynCall_ifii=Module["dynCall_ifii"]=Module["asm"]["dynCall_ifii"]).apply(null,arguments)};var dynCall_ifffii=Module["dynCall_ifffii"]=function(){return(dynCall_ifffii=Module["dynCall_ifffii"]=Module["asm"]["dynCall_ifffii"]).apply(null,arguments)};var dynCall_ffffii=Module["dynCall_ffffii"]=function(){return(dynCall_ffffii=Module["dynCall_ffffii"]=Module["asm"]["dynCall_ffffii"]).apply(null,arguments)};var dynCall_ffffifi=Module["dynCall_ffffifi"]=function(){return(dynCall_ffffifi=Module["dynCall_ffffifi"]=Module["asm"]["dynCall_ffffifi"]).apply(null,arguments)};var dynCall_ffffiffi=Module["dynCall_ffffiffi"]=function(){return(dynCall_ffffiffi=Module["dynCall_ffffiffi"]=Module["asm"]["dynCall_ffffiffi"]).apply(null,arguments)};var dynCall_viiififi=Module["dynCall_viiififi"]=function(){return(dynCall_viiififi=Module["dynCall_viiififi"]=Module["asm"]["dynCall_viiififi"]).apply(null,arguments)};var dynCall_viiififfi=Module["dynCall_viiififfi"]=function(){return(dynCall_viiififfi=Module["dynCall_viiififfi"]=Module["asm"]["dynCall_viiififfi"]).apply(null,arguments)};var dynCall_ifiii=Module["dynCall_ifiii"]=function(){return(dynCall_ifiii=Module["dynCall_ifiii"]=Module["asm"]["dynCall_ifiii"]).apply(null,arguments)};var dynCall_iifiiiiii=Module["dynCall_iifiiiiii"]=function(){return(dynCall_iifiiiiii=Module["dynCall_iifiiiiii"]=Module["asm"]["dynCall_iifiiiiii"]).apply(null,arguments)};var dynCall_iifiiiii=Module["dynCall_iifiiiii"]=function(){return(dynCall_iifiiiii=Module["dynCall_iifiiiii"]=Module["asm"]["dynCall_iifiiiii"]).apply(null,arguments)};var dynCall_iiffiiiii=Module["dynCall_iiffiiiii"]=function(){return(dynCall_iiffiiiii=Module["dynCall_iiffiiiii"]=Module["asm"]["dynCall_iiffiiiii"]).apply(null,arguments)};var dynCall_iiffifiii=Module["dynCall_iiffifiii"]=function(){return(dynCall_iiffifiii=Module["dynCall_iiffifiii"]=Module["asm"]["dynCall_iiffifiii"]).apply(null,arguments)};var dynCall_iififi=Module["dynCall_iififi"]=function(){return(dynCall_iififi=Module["dynCall_iififi"]=Module["asm"]["dynCall_iififi"]).apply(null,arguments)};var dynCall_iiififi=Module["dynCall_iiififi"]=function(){return(dynCall_iiififi=Module["dynCall_iiififi"]=Module["asm"]["dynCall_iiififi"]).apply(null,arguments)};var dynCall_iifiii=Module["dynCall_iifiii"]=function(){return(dynCall_iifiii=Module["dynCall_iifiii"]=Module["asm"]["dynCall_iifiii"]).apply(null,arguments)};var dynCall_iiiiifiiii=Module["dynCall_iiiiifiiii"]=function(){return(dynCall_iiiiifiiii=Module["dynCall_iiiiifiiii"]=Module["asm"]["dynCall_iiiiifiiii"]).apply(null,arguments)};var dynCall_viiiiiifiifiiii=Module["dynCall_viiiiiifiifiiii"]=function(){return(dynCall_viiiiiifiifiiii=Module["dynCall_viiiiiifiifiiii"]=Module["asm"]["dynCall_viiiiiifiifiiii"]).apply(null,arguments)};var dynCall_viidiii=Module["dynCall_viidiii"]=function(){return(dynCall_viidiii=Module["dynCall_viidiii"]=Module["asm"]["dynCall_viidiii"]).apply(null,arguments)};var dynCall_fiifdi=Module["dynCall_fiifdi"]=function(){return(dynCall_fiifdi=Module["dynCall_fiifdi"]=Module["asm"]["dynCall_fiifdi"]).apply(null,arguments)};var dynCall_viiiiiifddfiiii=Module["dynCall_viiiiiifddfiiii"]=function(){return(dynCall_viiiiiifddfiiii=Module["dynCall_viiiiiifddfiiii"]=Module["asm"]["dynCall_viiiiiifddfiiii"]).apply(null,arguments)};var dynCall_fiifji=Module["dynCall_fiifji"]=function(){return(dynCall_fiifji=Module["dynCall_fiifji"]=Module["asm"]["dynCall_fiifji"]).apply(null,arguments)};var dynCall_viiiiiifjjfiiii=Module["dynCall_viiiiiifjjfiiii"]=function(){return(dynCall_viiiiiifjjfiiii=Module["dynCall_viiiiiifjjfiiii"]=Module["asm"]["dynCall_viiiiiifjjfiiii"]).apply(null,arguments)};var dynCall_viiiifiii=Module["dynCall_viiiifiii"]=function(){return(dynCall_viiiifiii=Module["dynCall_viiiifiii"]=Module["asm"]["dynCall_viiiifiii"]).apply(null,arguments)};var dynCall_viiiiiiffffiiii=Module["dynCall_viiiiiiffffiiii"]=function(){return(dynCall_viiiiiiffffiiii=Module["dynCall_viiiiiiffffiiii"]=Module["asm"]["dynCall_viiiiiiffffiiii"]).apply(null,arguments)};var dynCall_viifiiii=Module["dynCall_viifiiii"]=function(){return(dynCall_viifiiii=Module["dynCall_viifiiii"]=Module["asm"]["dynCall_viifiiii"]).apply(null,arguments)};var dynCall_iiiiifiii=Module["dynCall_iiiiifiii"]=function(){return(dynCall_iiiiifiii=Module["dynCall_iiiiifiii"]=Module["asm"]["dynCall_iiiiifiii"]).apply(null,arguments)};var dynCall_fffffi=Module["dynCall_fffffi"]=function(){return(dynCall_fffffi=Module["dynCall_fffffi"]=Module["asm"]["dynCall_fffffi"]).apply(null,arguments)};var dynCall_fiiffffi=Module["dynCall_fiiffffi"]=function(){return(dynCall_fiiffffi=Module["dynCall_fiiffffi"]=Module["asm"]["dynCall_fiiffffi"]).apply(null,arguments)};var dynCall_fffifffi=Module["dynCall_fffifffi"]=function(){return(dynCall_fffifffi=Module["dynCall_fffifffi"]=Module["asm"]["dynCall_fffifffi"]).apply(null,arguments)};var dynCall_fiffii=Module["dynCall_fiffii"]=function(){return(dynCall_fiffii=Module["dynCall_fiffii"]=Module["asm"]["dynCall_fiffii"]).apply(null,arguments)};var dynCall_vdii=Module["dynCall_vdii"]=function(){return(dynCall_vdii=Module["dynCall_vdii"]=Module["asm"]["dynCall_vdii"]).apply(null,arguments)};var dynCall_iiiiiijii=Module["dynCall_iiiiiijii"]=function(){return(dynCall_iiiiiijii=Module["dynCall_iiiiiijii"]=Module["asm"]["dynCall_iiiiiijii"]).apply(null,arguments)};var dynCall_viiiiiiijii=Module["dynCall_viiiiiiijii"]=function(){return(dynCall_viiiiiiijii=Module["dynCall_viiiiiiijii"]=Module["asm"]["dynCall_viiiiiiijii"]).apply(null,arguments)};var dynCall_ifiiii=Module["dynCall_ifiiii"]=function(){return(dynCall_ifiiii=Module["dynCall_ifiiii"]=Module["asm"]["dynCall_ifiiii"]).apply(null,arguments)};var dynCall_idiiiii=Module["dynCall_idiiiii"]=function(){return(dynCall_idiiiii=Module["dynCall_idiiiii"]=Module["asm"]["dynCall_idiiiii"]).apply(null,arguments)};var dynCall_idiiii=Module["dynCall_idiiii"]=function(){return(dynCall_idiiii=Module["dynCall_idiiii"]=Module["asm"]["dynCall_idiiii"]).apply(null,arguments)};var dynCall_idii=Module["dynCall_idii"]=function(){return(dynCall_idii=Module["dynCall_idii"]=Module["asm"]["dynCall_idii"]).apply(null,arguments)};var dynCall_iiijiiii=Module["dynCall_iiijiiii"]=function(){return(dynCall_iiijiiii=Module["dynCall_iiijiiii"]=Module["asm"]["dynCall_iiijiiii"]).apply(null,arguments)};var dynCall_iddi=Module["dynCall_iddi"]=function(){return(dynCall_iddi=Module["dynCall_iddi"]=Module["asm"]["dynCall_iddi"]).apply(null,arguments)};var dynCall_viiiiiji=Module["dynCall_viiiiiji"]=function(){return(dynCall_viiiiiji=Module["dynCall_viiiiiji"]=Module["asm"]["dynCall_viiiiiji"]).apply(null,arguments)};var dynCall_ijjiiii=Module["dynCall_ijjiiii"]=function(){return(dynCall_ijjiiii=Module["dynCall_ijjiiii"]=Module["asm"]["dynCall_ijjiiii"]).apply(null,arguments)};var dynCall_vdiiiii=Module["dynCall_vdiiiii"]=function(){return(dynCall_vdiiiii=Module["dynCall_vdiiiii"]=Module["asm"]["dynCall_vdiiiii"]).apply(null,arguments)};var dynCall_diiji=Module["dynCall_diiji"]=function(){return(dynCall_diiji=Module["dynCall_diiji"]=Module["asm"]["dynCall_diiji"]).apply(null,arguments)};var dynCall_ijiii=Module["dynCall_ijiii"]=function(){return(dynCall_ijiii=Module["dynCall_ijiii"]=Module["asm"]["dynCall_ijiii"]).apply(null,arguments)};var dynCall_idiii=Module["dynCall_idiii"]=function(){return(dynCall_idiii=Module["dynCall_idiii"]=Module["asm"]["dynCall_idiii"]).apply(null,arguments)};var dynCall_vidiii=Module["dynCall_vidiii"]=function(){return(dynCall_vidiii=Module["dynCall_vidiii"]=Module["asm"]["dynCall_vidiii"]).apply(null,arguments)};var dynCall_ijiiii=Module["dynCall_ijiiii"]=function(){return(dynCall_ijiiii=Module["dynCall_ijiiii"]=Module["asm"]["dynCall_ijiiii"]).apply(null,arguments)};var dynCall_viiiiiiiji=Module["dynCall_viiiiiiiji"]=function(){return(dynCall_viiiiiiiji=Module["dynCall_viiiiiiiji"]=Module["asm"]["dynCall_viiiiiiiji"]).apply(null,arguments)};var dynCall_ijjji=Module["dynCall_ijjji"]=function(){return(dynCall_ijjji=Module["dynCall_ijjji"]=Module["asm"]["dynCall_ijjji"]).apply(null,arguments)};var dynCall_vdi=Module["dynCall_vdi"]=function(){return(dynCall_vdi=Module["dynCall_vdi"]=Module["asm"]["dynCall_vdi"]).apply(null,arguments)};var dynCall_diiiii=Module["dynCall_diiiii"]=function(){return(dynCall_diiiii=Module["dynCall_diiiii"]=Module["asm"]["dynCall_diiiii"]).apply(null,arguments)};var dynCall_vjiiiiiiii=Module["dynCall_vjiiiiiiii"]=function(){return(dynCall_vjiiiiiiii=Module["dynCall_vjiiiiiiii"]=Module["asm"]["dynCall_vjiiiiiiii"]).apply(null,arguments)};var dynCall_vjiiiiiii=Module["dynCall_vjiiiiiii"]=function(){return(dynCall_vjiiiiiii=Module["dynCall_vjiiiiiii"]=Module["asm"]["dynCall_vjiiiiiii"]).apply(null,arguments)};var dynCall_diji=Module["dynCall_diji"]=function(){return(dynCall_diji=Module["dynCall_diji"]=Module["asm"]["dynCall_diji"]).apply(null,arguments)};var dynCall_fidi=Module["dynCall_fidi"]=function(){return(dynCall_fidi=Module["dynCall_fidi"]=Module["asm"]["dynCall_fidi"]).apply(null,arguments)};var dynCall_diddi=Module["dynCall_diddi"]=function(){return(dynCall_diddi=Module["dynCall_diddi"]=Module["asm"]["dynCall_diddi"]).apply(null,arguments)};var dynCall_ijiiiiiii=Module["dynCall_ijiiiiiii"]=function(){return(dynCall_ijiiiiiii=Module["dynCall_ijiiiiiii"]=Module["asm"]["dynCall_ijiiiiiii"]).apply(null,arguments)};var dynCall_vijiiiiii=Module["dynCall_vijiiiiii"]=function(){return(dynCall_vijiiiiii=Module["dynCall_vijiiiiii"]=Module["asm"]["dynCall_vijiiiiii"]).apply(null,arguments)};var dynCall_ijiiiii=Module["dynCall_ijiiiii"]=function(){return(dynCall_ijiiiii=Module["dynCall_ijiiiii"]=Module["asm"]["dynCall_ijiiiii"]).apply(null,arguments)};var dynCall_viijiiii=Module["dynCall_viijiiii"]=function(){return(dynCall_viijiiii=Module["dynCall_viijiiii"]=Module["asm"]["dynCall_viijiiii"]).apply(null,arguments)};var dynCall_ijjiii=Module["dynCall_ijjiii"]=function(){return(dynCall_ijjiii=Module["dynCall_ijjiii"]=Module["asm"]["dynCall_ijjiii"]).apply(null,arguments)};var dynCall_iffffi=Module["dynCall_iffffi"]=function(){return(dynCall_iffffi=Module["dynCall_iffffi"]=Module["asm"]["dynCall_iffffi"]).apply(null,arguments)};var dynCall_vfffi=Module["dynCall_vfffi"]=function(){return(dynCall_vfffi=Module["dynCall_vfffi"]=Module["asm"]["dynCall_vfffi"]).apply(null,arguments)};var dynCall_vffffi=Module["dynCall_vffffi"]=function(){return(dynCall_vffffi=Module["dynCall_vffffi"]=Module["asm"]["dynCall_vffffi"]).apply(null,arguments)};var dynCall_vifffii=Module["dynCall_vifffii"]=function(){return(dynCall_vifffii=Module["dynCall_vifffii"]=Module["asm"]["dynCall_vifffii"]).apply(null,arguments)};var dynCall_viffffffi=Module["dynCall_viffffffi"]=function(){return(dynCall_viffffffi=Module["dynCall_viffffffi"]=Module["asm"]["dynCall_viffffffi"]).apply(null,arguments)};var dynCall_vffffffii=Module["dynCall_vffffffii"]=function(){return(dynCall_vffffffii=Module["dynCall_vffffffii"]=Module["asm"]["dynCall_vffffffii"]).apply(null,arguments)};var dynCall_vffffii=Module["dynCall_vffffii"]=function(){return(dynCall_vffffii=Module["dynCall_vffffii"]=Module["asm"]["dynCall_vffffii"]).apply(null,arguments)};var dynCall_viiiifffi=Module["dynCall_viiiifffi"]=function(){return(dynCall_viiiifffi=Module["dynCall_viiiifffi"]=Module["asm"]["dynCall_viiiifffi"]).apply(null,arguments)};var dynCall_vfiii=Module["dynCall_vfiii"]=function(){return(dynCall_vfiii=Module["dynCall_vfiii"]=Module["asm"]["dynCall_vfiii"]).apply(null,arguments)};var dynCall_iffi=Module["dynCall_iffi"]=function(){return(dynCall_iffi=Module["dynCall_iffi"]=Module["asm"]["dynCall_iffi"]).apply(null,arguments)};var dynCall_fdi=Module["dynCall_fdi"]=function(){return(dynCall_fdi=Module["dynCall_fdi"]=Module["asm"]["dynCall_fdi"]).apply(null,arguments)};var dynCall_vfii=Module["dynCall_vfii"]=function(){return(dynCall_vfii=Module["dynCall_vfii"]=Module["asm"]["dynCall_vfii"]).apply(null,arguments)};var dynCall_ddddi=Module["dynCall_ddddi"]=function(){return(dynCall_ddddi=Module["dynCall_ddddi"]=Module["asm"]["dynCall_ddddi"]).apply(null,arguments)};var dynCall_iiiifiiiiii=Module["dynCall_iiiifiiiiii"]=function(){return(dynCall_iiiifiiiiii=Module["dynCall_iiiifiiiiii"]=Module["asm"]["dynCall_iiiifiiiiii"]).apply(null,arguments)};var dynCall_iiiifiiiii=Module["dynCall_iiiifiiiii"]=function(){return(dynCall_iiiifiiiii=Module["dynCall_iiiifiiiii"]=Module["asm"]["dynCall_iiiifiiiii"]).apply(null,arguments)};var dynCall_iiiifiiii=Module["dynCall_iiiifiiii"]=function(){return(dynCall_iiiifiiii=Module["dynCall_iiiifiiii"]=Module["asm"]["dynCall_iiiifiiii"]).apply(null,arguments)};var dynCall_vijjii=Module["dynCall_vijjii"]=function(){return(dynCall_vijjii=Module["dynCall_vijjii"]=Module["asm"]["dynCall_vijjii"]).apply(null,arguments)};var dynCall_viiiiiiiijijiii=Module["dynCall_viiiiiiiijijiii"]=function(){return(dynCall_viiiiiiiijijiii=Module["dynCall_viiiiiiiijijiii"]=Module["asm"]["dynCall_viiiiiiiijijiii"]).apply(null,arguments)};var dynCall_iiiiiiifiiii=Module["dynCall_iiiiiiifiiii"]=function(){return(dynCall_iiiiiiifiiii=Module["dynCall_iiiiiiifiiii"]=Module["asm"]["dynCall_iiiiiiifiiii"]).apply(null,arguments)};var dynCall_viiiiiffii=Module["dynCall_viiiiiffii"]=function(){return(dynCall_viiiiiffii=Module["dynCall_viiiiiffii"]=Module["asm"]["dynCall_viiiiiffii"]).apply(null,arguments)};var dynCall_viffffii=Module["dynCall_viffffii"]=function(){return(dynCall_viffffii=Module["dynCall_viffffii"]=Module["asm"]["dynCall_viffffii"]).apply(null,arguments)};var dynCall_viiifiii=Module["dynCall_viiifiii"]=function(){return(dynCall_viiifiii=Module["dynCall_viiifiii"]=Module["asm"]["dynCall_viiifiii"]).apply(null,arguments)};var dynCall_viffiiii=Module["dynCall_viffiiii"]=function(){return(dynCall_viffiiii=Module["dynCall_viffiiii"]=Module["asm"]["dynCall_viffiiii"]).apply(null,arguments)};var dynCall_viiiffffiiii=Module["dynCall_viiiffffiiii"]=function(){return(dynCall_viiiffffiiii=Module["dynCall_viiiffffiiii"]=Module["asm"]["dynCall_viiiffffiiii"]).apply(null,arguments)};var dynCall_viifffffffiiiii=Module["dynCall_viifffffffiiiii"]=function(){return(dynCall_viifffffffiiiii=Module["dynCall_viifffffffiiiii"]=Module["asm"]["dynCall_viifffffffiiiii"]).apply(null,arguments)};var dynCall_iiiiiiffiiiiiiiiiffffiiii=Module["dynCall_iiiiiiffiiiiiiiiiffffiiii"]=function(){return(dynCall_iiiiiiffiiiiiiiiiffffiiii=Module["dynCall_iiiiiiffiiiiiiiiiffffiiii"]=Module["asm"]["dynCall_iiiiiiffiiiiiiiiiffffiiii"]).apply(null,arguments)};var dynCall_iiiiiiffiiiiiiiiiiiiiii=Module["dynCall_iiiiiiffiiiiiiiiiiiiiii"]=function(){return(dynCall_iiiiiiffiiiiiiiiiiiiiii=Module["dynCall_iiiiiiffiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_iiiiiiffiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viffii=Module["dynCall_viffii"]=function(){return(dynCall_viffii=Module["dynCall_viffii"]=Module["asm"]["dynCall_viffii"]).apply(null,arguments)};var dynCall_vififiii=Module["dynCall_vififiii"]=function(){return(dynCall_vififiii=Module["dynCall_vififiii"]=Module["asm"]["dynCall_vififiii"]).apply(null,arguments)};var dynCall_viififii=Module["dynCall_viififii"]=function(){return(dynCall_viififii=Module["dynCall_viififii"]=Module["asm"]["dynCall_viififii"]).apply(null,arguments)};var dynCall_viiffffi=Module["dynCall_viiffffi"]=function(){return(dynCall_viiffffi=Module["dynCall_viiffffi"]=Module["asm"]["dynCall_viiffffi"]).apply(null,arguments)};var dynCall_ifffi=Module["dynCall_ifffi"]=function(){return(dynCall_ifffi=Module["dynCall_ifffi"]=Module["asm"]["dynCall_ifffi"]).apply(null,arguments)};var dynCall_viffiii=Module["dynCall_viffiii"]=function(){return(dynCall_viffiii=Module["dynCall_viffiii"]=Module["asm"]["dynCall_viffiii"]).apply(null,arguments)};var dynCall_viffifi=Module["dynCall_viffifi"]=function(){return(dynCall_viffifi=Module["dynCall_viffifi"]=Module["asm"]["dynCall_viffifi"]).apply(null,arguments)};var dynCall_fffffffi=Module["dynCall_fffffffi"]=function(){return(dynCall_fffffffi=Module["dynCall_fffffffi"]=Module["asm"]["dynCall_fffffffi"]).apply(null,arguments)};var dynCall_viiffifi=Module["dynCall_viiffifi"]=function(){return(dynCall_viiffifi=Module["dynCall_viiffifi"]=Module["asm"]["dynCall_viiffifi"]).apply(null,arguments)};var dynCall_viiiffiiiiiiiii=Module["dynCall_viiiffiiiiiiiii"]=function(){return(dynCall_viiiffiiiiiiiii=Module["dynCall_viiiffiiiiiiiii"]=Module["asm"]["dynCall_viiiffiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiffiiiiii=Module["dynCall_viiiffiiiiii"]=function(){return(dynCall_viiiffiiiiii=Module["dynCall_viiiffiiiiii"]=Module["asm"]["dynCall_viiiffiiiiii"]).apply(null,arguments)};var dynCall_viiffiiiiiiiiii=Module["dynCall_viiffiiiiiiiiii"]=function(){return(dynCall_viiffiiiiiiiiii=Module["dynCall_viiffiiiiiiiiii"]=Module["asm"]["dynCall_viiffiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiffiiiiiii=Module["dynCall_viiffiiiiiii"]=function(){return(dynCall_viiffiiiiiii=Module["dynCall_viiffiiiiiii"]=Module["asm"]["dynCall_viiffiiiiiii"]).apply(null,arguments)};var dynCall_iiiffiiii=Module["dynCall_iiiffiiii"]=function(){return(dynCall_iiiffiiii=Module["dynCall_iiiffiiii"]=Module["asm"]["dynCall_iiiffiiii"]).apply(null,arguments)};var dynCall_iiiiffiiii=Module["dynCall_iiiiffiiii"]=function(){return(dynCall_iiiiffiiii=Module["dynCall_iiiiffiiii"]=Module["asm"]["dynCall_iiiiffiiii"]).apply(null,arguments)};var dynCall_fiiiffi=Module["dynCall_fiiiffi"]=function(){return(dynCall_fiiiffi=Module["dynCall_fiiiffi"]=Module["asm"]["dynCall_fiiiffi"]).apply(null,arguments)};var dynCall_viiiiiiiijiiii=Module["dynCall_viiiiiiiijiiii"]=function(){return(dynCall_viiiiiiiijiiii=Module["dynCall_viiiiiiiijiiii"]=Module["asm"]["dynCall_viiiiiiiijiiii"]).apply(null,arguments)};var dynCall_viiiiiifiiiiii=Module["dynCall_viiiiiifiiiiii"]=function(){return(dynCall_viiiiiifiiiiii=Module["dynCall_viiiiiifiiiiii"]=Module["asm"]["dynCall_viiiiiifiiiiii"]).apply(null,arguments)};var dynCall_viffffiii=Module["dynCall_viffffiii"]=function(){return(dynCall_viffffiii=Module["dynCall_viffffiii"]=Module["asm"]["dynCall_viffffiii"]).apply(null,arguments)};var dynCall_vifiiiiii=Module["dynCall_vifiiiiii"]=function(){return(dynCall_vifiiiiii=Module["dynCall_vifiiiiii"]=Module["asm"]["dynCall_vifiiiiii"]).apply(null,arguments)};var dynCall_ffii=Module["dynCall_ffii"]=function(){return(dynCall_ffii=Module["dynCall_ffii"]=Module["asm"]["dynCall_ffii"]).apply(null,arguments)};var dynCall_diiidi=Module["dynCall_diiidi"]=function(){return(dynCall_diiidi=Module["dynCall_diiidi"]=Module["asm"]["dynCall_diiidi"]).apply(null,arguments)};var dynCall_viiidii=Module["dynCall_viiidii"]=function(){return(dynCall_viiidii=Module["dynCall_viiidii"]=Module["asm"]["dynCall_viiidii"]).apply(null,arguments)};var dynCall_ijiiiiiiiii=Module["dynCall_ijiiiiiiiii"]=function(){return(dynCall_ijiiiiiiiii=Module["dynCall_ijiiiiiiiii"]=Module["asm"]["dynCall_ijiiiiiiiii"]).apply(null,arguments)};var dynCall_iijjijii=Module["dynCall_iijjijii"]=function(){return(dynCall_iijjijii=Module["dynCall_iijjijii"]=Module["asm"]["dynCall_iijjijii"]).apply(null,arguments)};var dynCall_jiijii=Module["dynCall_jiijii"]=function(){return(dynCall_jiijii=Module["dynCall_jiijii"]=Module["asm"]["dynCall_jiijii"]).apply(null,arguments)};var dynCall_vifffffffffi=Module["dynCall_vifffffffffi"]=function(){return(dynCall_vifffffffffi=Module["dynCall_vifffffffffi"]=Module["asm"]["dynCall_vifffffffffi"]).apply(null,arguments)};var dynCall_viffffffffffffffffi=Module["dynCall_viffffffffffffffffi"]=function(){return(dynCall_viffffffffffffffffi=Module["dynCall_viffffffffffffffffi"]=Module["asm"]["dynCall_viffffffffffffffffi"]).apply(null,arguments)};var dynCall_viifffi=Module["dynCall_viifffi"]=function(){return(dynCall_viifffi=Module["dynCall_viifffi"]=Module["asm"]["dynCall_viifffi"]).apply(null,arguments)};var dynCall_viifffii=Module["dynCall_viifffii"]=function(){return(dynCall_viifffii=Module["dynCall_viifffii"]=Module["asm"]["dynCall_viifffii"]).apply(null,arguments)};var dynCall_viiffiffiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiffiffiiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiffiffiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiffiffiiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiffiffiiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiffiffiiiiiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiffiffiiiiiiiiiiiiiiiiiiiiiiii"]=function(){return(dynCall_viiffiffiiiiiiiiiiiiiiiiiiiiiiii=Module["dynCall_viiffiffiiiiiiiiiiiiiiiiiiiiiiii"]=Module["asm"]["dynCall_viiffiffiiiiiiiiiiiiiiiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiffiiiii=Module["dynCall_viiiiiffiiiii"]=function(){return(dynCall_viiiiiffiiiii=Module["dynCall_viiiiiffiiiii"]=Module["asm"]["dynCall_viiiiiffiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiifiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiifiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiifiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiifiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiifiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiifiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiifiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiifiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiifiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiifiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiifiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiifiiiiiii"]).apply(null,arguments)};var dynCall_iiiiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiifiiiiiii"]=function(){return(dynCall_iiiiiiiiiiiiiiiiifiiiiiii=Module["dynCall_iiiiiiiiiiiiiiiiifiiiiiii"]=Module["asm"]["dynCall_iiiiiiiiiiiiiiiiifiiiiiii"]).apply(null,arguments)};var dynCall_viiiffffi=Module["dynCall_viiiffffi"]=function(){return(dynCall_viiiffffi=Module["dynCall_viiiffffi"]=Module["asm"]["dynCall_viiiffffi"]).apply(null,arguments)};var dynCall_viiffii=Module["dynCall_viiffii"]=function(){return(dynCall_viiffii=Module["dynCall_viiffii"]=Module["asm"]["dynCall_viiffii"]).apply(null,arguments)};var dynCall_vifiiii=Module["dynCall_vifiiii"]=function(){return(dynCall_vifiiii=Module["dynCall_vifiiii"]=Module["asm"]["dynCall_vifiiii"]).apply(null,arguments)};var dynCall_iiiiiiifi=Module["dynCall_iiiiiiifi"]=function(){return(dynCall_iiiiiiifi=Module["dynCall_iiiiiiifi"]=Module["asm"]["dynCall_iiiiiiifi"]).apply(null,arguments)};var dynCall_iiiiiifiii=Module["dynCall_iiiiiifiii"]=function(){return(dynCall_iiiiiifiii=Module["dynCall_iiiiiifiii"]=Module["asm"]["dynCall_iiiiiifiii"]).apply(null,arguments)};var dynCall_iiiiiiiifii=Module["dynCall_iiiiiiiifii"]=function(){return(dynCall_iiiiiiiifii=Module["dynCall_iiiiiiiifii"]=Module["asm"]["dynCall_iiiiiiiifii"]).apply(null,arguments)};var dynCall_viiiifiiii=Module["dynCall_viiiifiiii"]=function(){return(dynCall_viiiifiiii=Module["dynCall_viiiifiiii"]=Module["asm"]["dynCall_viiiifiiii"]).apply(null,arguments)};var dynCall_iiiiiiiifiiiii=Module["dynCall_iiiiiiiifiiiii"]=function(){return(dynCall_iiiiiiiifiiiii=Module["dynCall_iiiiiiiifiiiii"]=Module["asm"]["dynCall_iiiiiiiifiiiii"]).apply(null,arguments)};var dynCall_vffiii=Module["dynCall_vffiii"]=function(){return(dynCall_vffiii=Module["dynCall_vffiii"]=Module["asm"]["dynCall_vffiii"]).apply(null,arguments)};var dynCall_vifffiii=Module["dynCall_vifffiii"]=function(){return(dynCall_vifffiii=Module["dynCall_vifffiii"]=Module["asm"]["dynCall_vifffiii"]).apply(null,arguments)};var dynCall_ifiiiifiii=Module["dynCall_ifiiiifiii"]=function(){return(dynCall_ifiiiifiii=Module["dynCall_ifiiiifiii"]=Module["asm"]["dynCall_ifiiiifiii"]).apply(null,arguments)};var dynCall_viiffffiiiii=Module["dynCall_viiffffiiiii"]=function(){return(dynCall_viiffffiiiii=Module["dynCall_viiffffiiiii"]=Module["asm"]["dynCall_viiffffiiiii"]).apply(null,arguments)};var dynCall_vifiifiifi=Module["dynCall_vifiifiifi"]=function(){return(dynCall_vifiifiifi=Module["dynCall_vifiifiifi"]=Module["asm"]["dynCall_vifiifiifi"]).apply(null,arguments)};var dynCall_vififiiii=Module["dynCall_vififiiii"]=function(){return(dynCall_vififiiii=Module["dynCall_vififiiii"]=Module["asm"]["dynCall_vififiiii"]).apply(null,arguments)};var dynCall_viiiiiiifi=Module["dynCall_viiiiiiifi"]=function(){return(dynCall_viiiiiiifi=Module["dynCall_viiiiiiifi"]=Module["asm"]["dynCall_viiiiiiifi"]).apply(null,arguments)};var dynCall_iiffiiiiiiiiii=Module["dynCall_iiffiiiiiiiiii"]=function(){return(dynCall_iiffiiiiiiiiii=Module["dynCall_iiffiiiiiiiiii"]=Module["asm"]["dynCall_iiffiiiiiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiffiii=Module["dynCall_viiiiiiiiiiffiii"]=function(){return(dynCall_viiiiiiiiiiffiii=Module["dynCall_viiiiiiiiiiffiii"]=Module["asm"]["dynCall_viiiiiiiiiiffiii"]).apply(null,arguments)};var dynCall_jiidi=Module["dynCall_jiidi"]=function(){return(dynCall_jiidi=Module["dynCall_jiidi"]=Module["asm"]["dynCall_jiidi"]).apply(null,arguments)};var dynCall_viiffffffi=Module["dynCall_viiffffffi"]=function(){return(dynCall_viiffffffi=Module["dynCall_viiffffffi"]=Module["asm"]["dynCall_viiffffffi"]).apply(null,arguments)};var dynCall_viifffffffi=Module["dynCall_viifffffffi"]=function(){return(dynCall_viifffffffi=Module["dynCall_viifffffffi"]=Module["asm"]["dynCall_viifffffffi"]).apply(null,arguments)};var dynCall_viiffffffffi=Module["dynCall_viiffffffffi"]=function(){return(dynCall_viiffffffffi=Module["dynCall_viiffffffffi"]=Module["asm"]["dynCall_viiffffffffi"]).apply(null,arguments)};var dynCall_viiffffffffiii=Module["dynCall_viiffffffffiii"]=function(){return(dynCall_viiffffffffiii=Module["dynCall_viiffffffffiii"]=Module["asm"]["dynCall_viiffffffffiii"]).apply(null,arguments)};var dynCall_viiiiffffii=Module["dynCall_viiiiffffii"]=function(){return(dynCall_viiiiffffii=Module["dynCall_viiiiffffii"]=Module["asm"]["dynCall_viiiiffffii"]).apply(null,arguments)};var dynCall_ddidi=Module["dynCall_ddidi"]=function(){return(dynCall_ddidi=Module["dynCall_ddidi"]=Module["asm"]["dynCall_ddidi"]).apply(null,arguments)};var dynCall_vidii=Module["dynCall_vidii"]=function(){return(dynCall_vidii=Module["dynCall_vidii"]=Module["asm"]["dynCall_vidii"]).apply(null,arguments)};var dynCall_viddii=Module["dynCall_viddii"]=function(){return(dynCall_viddii=Module["dynCall_viddii"]=Module["asm"]["dynCall_viddii"]).apply(null,arguments)};var dynCall_iiidii=Module["dynCall_iiidii"]=function(){return(dynCall_iiidii=Module["dynCall_iiidii"]=Module["asm"]["dynCall_iiidii"]).apply(null,arguments)};var dynCall_iiiddi=Module["dynCall_iiiddi"]=function(){return(dynCall_iiiddi=Module["dynCall_iiiddi"]=Module["asm"]["dynCall_iiiddi"]).apply(null,arguments)};var dynCall_viddiiii=Module["dynCall_viddiiii"]=function(){return(dynCall_viddiiii=Module["dynCall_viddiiii"]=Module["asm"]["dynCall_viddiiii"]).apply(null,arguments)};var dynCall_jijjii=Module["dynCall_jijjii"]=function(){return(dynCall_jijjii=Module["dynCall_jijjii"]=Module["asm"]["dynCall_jijjii"]).apply(null,arguments)};var dynCall_vijiiiiiii=Module["dynCall_vijiiiiiii"]=function(){return(dynCall_vijiiiiiii=Module["dynCall_vijiiiiiii"]=Module["asm"]["dynCall_vijiiiiiii"]).apply(null,arguments)};var dynCall_vijiiiiiiii=Module["dynCall_vijiiiiiiii"]=function(){return(dynCall_vijiiiiiiii=Module["dynCall_vijiiiiiiii"]=Module["asm"]["dynCall_vijiiiiiiii"]).apply(null,arguments)};var dynCall_jjiiiii=Module["dynCall_jjiiiii"]=function(){return(dynCall_jjiiiii=Module["dynCall_jjiiiii"]=Module["asm"]["dynCall_jjiiiii"]).apply(null,arguments)};var dynCall_viijiiiiii=Module["dynCall_viijiiiiii"]=function(){return(dynCall_viijiiiiii=Module["dynCall_viijiiiiii"]=Module["asm"]["dynCall_viijiiiiii"]).apply(null,arguments)};var dynCall_jijjji=Module["dynCall_jijjji"]=function(){return(dynCall_jijjji=Module["dynCall_jijjji"]=Module["asm"]["dynCall_jijjji"]).apply(null,arguments)};var dynCall_jijjjii=Module["dynCall_jijjjii"]=function(){return(dynCall_jijjjii=Module["dynCall_jijjjii"]=Module["asm"]["dynCall_jijjjii"]).apply(null,arguments)};var dynCall_jjiii=Module["dynCall_jjiii"]=function(){return(dynCall_jjiii=Module["dynCall_jjiii"]=Module["asm"]["dynCall_jjiii"]).apply(null,arguments)};var dynCall_ijijiiiii=Module["dynCall_ijijiiiii"]=function(){return(dynCall_ijijiiiii=Module["dynCall_ijijiiiii"]=Module["asm"]["dynCall_ijijiiiii"]).apply(null,arguments)};var dynCall_ijjjiii=Module["dynCall_ijjjiii"]=function(){return(dynCall_ijjjiii=Module["dynCall_ijjjiii"]=Module["asm"]["dynCall_ijjjiii"]).apply(null,arguments)};var dynCall_vijjjiijii=Module["dynCall_vijjjiijii"]=function(){return(dynCall_vijjjiijii=Module["dynCall_vijjjiijii"]=Module["asm"]["dynCall_vijjjiijii"]).apply(null,arguments)};var dynCall_ijjjiijii=Module["dynCall_ijjjiijii"]=function(){return(dynCall_ijjjiijii=Module["dynCall_ijjjiijii"]=Module["asm"]["dynCall_ijjjiijii"]).apply(null,arguments)};var dynCall_jfi=Module["dynCall_jfi"]=function(){return(dynCall_jfi=Module["dynCall_jfi"]=Module["asm"]["dynCall_jfi"]).apply(null,arguments)};var dynCall_fji=Module["dynCall_fji"]=function(){return(dynCall_fji=Module["dynCall_fji"]=Module["asm"]["dynCall_fji"]).apply(null,arguments)};var dynCall_dfi=Module["dynCall_dfi"]=function(){return(dynCall_dfi=Module["dynCall_dfi"]=Module["asm"]["dynCall_dfi"]).apply(null,arguments)};var dynCall_jidii=Module["dynCall_jidii"]=function(){return(dynCall_jidii=Module["dynCall_jidii"]=Module["asm"]["dynCall_jidii"]).apply(null,arguments)};var dynCall_viiiiiiiiji=Module["dynCall_viiiiiiiiji"]=function(){return(dynCall_viiiiiiiiji=Module["dynCall_viiiiiiiiji"]=Module["asm"]["dynCall_viiiiiiiiji"]).apply(null,arguments)};var dynCall_viiiiiiiiiji=Module["dynCall_viiiiiiiiiji"]=function(){return(dynCall_viiiiiiiiiji=Module["dynCall_viiiiiiiiiji"]=Module["asm"]["dynCall_viiiiiiiiiji"]).apply(null,arguments)};var dynCall_ijiijii=Module["dynCall_ijiijii"]=function(){return(dynCall_ijiijii=Module["dynCall_ijiijii"]=Module["asm"]["dynCall_ijiijii"]).apply(null,arguments)};var dynCall_vjjiiiii=Module["dynCall_vjjiiiii"]=function(){return(dynCall_vjjiiiii=Module["dynCall_vjjiiiii"]=Module["asm"]["dynCall_vjjiiiii"]).apply(null,arguments)};var dynCall_vjjii=Module["dynCall_vjjii"]=function(){return(dynCall_vjjii=Module["dynCall_vjjii"]=Module["asm"]["dynCall_vjjii"]).apply(null,arguments)};var dynCall_ijiiji=Module["dynCall_ijiiji"]=function(){return(dynCall_ijiiji=Module["dynCall_ijiiji"]=Module["asm"]["dynCall_ijiiji"]).apply(null,arguments)};var dynCall_ijiiiiji=Module["dynCall_ijiiiiji"]=function(){return(dynCall_ijiiiiji=Module["dynCall_ijiiiiji"]=Module["asm"]["dynCall_ijiiiiji"]).apply(null,arguments)};var dynCall_jiiiiii=Module["dynCall_jiiiiii"]=function(){return(dynCall_jiiiiii=Module["dynCall_jiiiiii"]=Module["asm"]["dynCall_jiiiiii"]).apply(null,arguments)};var dynCall_ddii=Module["dynCall_ddii"]=function(){return(dynCall_ddii=Module["dynCall_ddii"]=Module["asm"]["dynCall_ddii"]).apply(null,arguments)};var dynCall_ifiiiii=Module["dynCall_ifiiiii"]=function(){return(dynCall_ifiiiii=Module["dynCall_ifiiiii"]=Module["asm"]["dynCall_ifiiiii"]).apply(null,arguments)};var dynCall_vdiii=Module["dynCall_vdiii"]=function(){return(dynCall_vdiii=Module["dynCall_vdiii"]=Module["asm"]["dynCall_vdiii"]).apply(null,arguments)};var dynCall_jdii=Module["dynCall_jdii"]=function(){return(dynCall_jdii=Module["dynCall_jdii"]=Module["asm"]["dynCall_jdii"]).apply(null,arguments)};var dynCall_vijijji=Module["dynCall_vijijji"]=function(){return(dynCall_vijijji=Module["dynCall_vijijji"]=Module["asm"]["dynCall_vijijji"]).apply(null,arguments)};var dynCall_iijjji=Module["dynCall_iijjji"]=function(){return(dynCall_iijjji=Module["dynCall_iijjji"]=Module["asm"]["dynCall_iijjji"]).apply(null,arguments)};var dynCall_viijjji=Module["dynCall_viijjji"]=function(){return(dynCall_viijjji=Module["dynCall_viijjji"]=Module["asm"]["dynCall_viijjji"]).apply(null,arguments)};var dynCall_iijjii=Module["dynCall_iijjii"]=function(){return(dynCall_iijjii=Module["dynCall_iijjii"]=Module["asm"]["dynCall_iijjii"]).apply(null,arguments)};var dynCall_viijijii=Module["dynCall_viijijii"]=function(){return(dynCall_viijijii=Module["dynCall_viijijii"]=Module["asm"]["dynCall_viijijii"]).apply(null,arguments)};var dynCall_viijijiii=Module["dynCall_viijijiii"]=function(){return(dynCall_viijijiii=Module["dynCall_viijijiii"]=Module["asm"]["dynCall_viijijiii"]).apply(null,arguments)};var dynCall_vijiji=Module["dynCall_vijiji"]=function(){return(dynCall_vijiji=Module["dynCall_vijiji"]=Module["asm"]["dynCall_vijiji"]).apply(null,arguments)};var dynCall_viijiijiii=Module["dynCall_viijiijiii"]=function(){return(dynCall_viijiijiii=Module["dynCall_viijiijiii"]=Module["asm"]["dynCall_viijiijiii"]).apply(null,arguments)};var dynCall_viiiijiiii=Module["dynCall_viiiijiiii"]=function(){return(dynCall_viiiijiiii=Module["dynCall_viiiijiiii"]=Module["asm"]["dynCall_viiiijiiii"]).apply(null,arguments)};var dynCall_viijjii=Module["dynCall_viijjii"]=function(){return(dynCall_viijjii=Module["dynCall_viijjii"]=Module["asm"]["dynCall_viijjii"]).apply(null,arguments)};var dynCall_jiiiiiiiiii=Module["dynCall_jiiiiiiiiii"]=function(){return(dynCall_jiiiiiiiiii=Module["dynCall_jiiiiiiiiii"]=Module["asm"]["dynCall_jiiiiiiiiii"]).apply(null,arguments)};var dynCall_iiiiidii=Module["dynCall_iiiiidii"]=function(){return(dynCall_iiiiidii=Module["dynCall_iiiiidii"]=Module["asm"]["dynCall_iiiiidii"]).apply(null,arguments)};var dynCall_iiidiii=Module["dynCall_iiidiii"]=function(){return(dynCall_iiidiii=Module["dynCall_iiidiii"]=Module["asm"]["dynCall_iiidiii"]).apply(null,arguments)};var dynCall_viiiiiiji=Module["dynCall_viiiiiiji"]=function(){return(dynCall_viiiiiiji=Module["dynCall_viiiiiiji"]=Module["asm"]["dynCall_viiiiiiji"]).apply(null,arguments)};var dynCall_viifffiii=Module["dynCall_viifffiii"]=function(){return(dynCall_viifffiii=Module["dynCall_viifffiii"]=Module["asm"]["dynCall_viifffiii"]).apply(null,arguments)};var dynCall_iidfii=Module["dynCall_iidfii"]=function(){return(dynCall_iidfii=Module["dynCall_iidfii"]=Module["asm"]["dynCall_iidfii"]).apply(null,arguments)};var dynCall_iidfi=Module["dynCall_iidfi"]=function(){return(dynCall_iidfi=Module["dynCall_iidfi"]=Module["asm"]["dynCall_iidfi"]).apply(null,arguments)};var dynCall_iiddfi=Module["dynCall_iiddfi"]=function(){return(dynCall_iiddfi=Module["dynCall_iiddfi"]=Module["asm"]["dynCall_iiddfi"]).apply(null,arguments)};var dynCall_iijfii=Module["dynCall_iijfii"]=function(){return(dynCall_iijfii=Module["dynCall_iijfii"]=Module["asm"]["dynCall_iijfii"]).apply(null,arguments)};var dynCall_iijfi=Module["dynCall_iijfi"]=function(){return(dynCall_iijfi=Module["dynCall_iijfi"]=Module["asm"]["dynCall_iijfi"]).apply(null,arguments)};var dynCall_iijjfi=Module["dynCall_iijjfi"]=function(){return(dynCall_iijjfi=Module["dynCall_iijjfi"]=Module["asm"]["dynCall_iijjfi"]).apply(null,arguments)};var dynCall_iiiiffiiiji=Module["dynCall_iiiiffiiiji"]=function(){return(dynCall_iiiiffiiiji=Module["dynCall_iiiiffiiiji"]=Module["asm"]["dynCall_iiiiffiiiji"]).apply(null,arguments)};var dynCall_iiidfii=Module["dynCall_iiidfii"]=function(){return(dynCall_iiidfii=Module["dynCall_iiidfii"]=Module["asm"]["dynCall_iiidfii"]).apply(null,arguments)};var dynCall_iiijfii=Module["dynCall_iiijfii"]=function(){return(dynCall_iiijfii=Module["dynCall_iiijfii"]=Module["asm"]["dynCall_iiijfii"]).apply(null,arguments)};var dynCall_iiiiffiiiii=Module["dynCall_iiiiffiiiii"]=function(){return(dynCall_iiiiffiiiii=Module["dynCall_iiiiffiiiii"]=Module["asm"]["dynCall_iiiiffiiiii"]).apply(null,arguments)};var dynCall_iiiidfii=Module["dynCall_iiiidfii"]=function(){return(dynCall_iiiidfii=Module["dynCall_iiiidfii"]=Module["asm"]["dynCall_iiiidfii"]).apply(null,arguments)};var dynCall_iiiijfii=Module["dynCall_iiiijfii"]=function(){return(dynCall_iiiijfii=Module["dynCall_iiiijfii"]=Module["asm"]["dynCall_iiiijfii"]).apply(null,arguments)};var dynCall_iiiiffii=Module["dynCall_iiiiffii"]=function(){return(dynCall_iiiiffii=Module["dynCall_iiiiffii"]=Module["asm"]["dynCall_iiiiffii"]).apply(null,arguments)};var dynCall_iidddiii=Module["dynCall_iidddiii"]=function(){return(dynCall_iidddiii=Module["dynCall_iidddiii"]=Module["asm"]["dynCall_iidddiii"]).apply(null,arguments)};var dynCall_iifffiii=Module["dynCall_iifffiii"]=function(){return(dynCall_iifffiii=Module["dynCall_iifffiii"]=Module["asm"]["dynCall_iifffiii"]).apply(null,arguments)};var dynCall_diiiidi=Module["dynCall_diiiidi"]=function(){return(dynCall_diiiidi=Module["dynCall_diiiidi"]=Module["asm"]["dynCall_diiiidi"]).apply(null,arguments)};var dynCall_fiiiifi=Module["dynCall_fiiiifi"]=function(){return(dynCall_fiiiifi=Module["dynCall_fiiiifi"]=Module["asm"]["dynCall_fiiiifi"]).apply(null,arguments)};var dynCall_viiijjiii=Module["dynCall_viiijjiii"]=function(){return(dynCall_viiijjiii=Module["dynCall_viiijjiii"]=Module["asm"]["dynCall_viiijjiii"]).apply(null,arguments)};var dynCall_iiijjii=Module["dynCall_iiijjii"]=function(){return(dynCall_iiijjii=Module["dynCall_iiijjii"]=Module["asm"]["dynCall_iiijjii"]).apply(null,arguments)};var dynCall_ijiiiiii=Module["dynCall_ijiiiiii"]=function(){return(dynCall_ijiiiiii=Module["dynCall_ijiiiiii"]=Module["asm"]["dynCall_ijiiiiii"]).apply(null,arguments)};var dynCall_ijjiiiiii=Module["dynCall_ijjiiiiii"]=function(){return(dynCall_ijjiiiiii=Module["dynCall_ijjiiiiii"]=Module["asm"]["dynCall_ijjiiiiii"]).apply(null,arguments)};var dynCall_iiiij=Module["dynCall_iiiij"]=function(){return(dynCall_iiiij=Module["dynCall_iiiij"]=Module["asm"]["dynCall_iiiij"]).apply(null,arguments)};var dynCall_fff=Module["dynCall_fff"]=function(){return(dynCall_fff=Module["dynCall_fff"]=Module["asm"]["dynCall_fff"]).apply(null,arguments)};var dynCall_vif=Module["dynCall_vif"]=function(){return(dynCall_vif=Module["dynCall_vif"]=Module["asm"]["dynCall_vif"]).apply(null,arguments)};var dynCall_viif=Module["dynCall_viif"]=function(){return(dynCall_viif=Module["dynCall_viif"]=Module["asm"]["dynCall_viif"]).apply(null,arguments)};var dynCall_ijj=Module["dynCall_ijj"]=function(){return(dynCall_ijj=Module["dynCall_ijj"]=Module["asm"]["dynCall_ijj"]).apply(null,arguments)};var dynCall_vjji=Module["dynCall_vjji"]=function(){return(dynCall_vjji=Module["dynCall_vjji"]=Module["asm"]["dynCall_vjji"]).apply(null,arguments)};var dynCall_viffff=Module["dynCall_viffff"]=function(){return(dynCall_viffff=Module["dynCall_viffff"]=Module["asm"]["dynCall_viffff"]).apply(null,arguments)};var dynCall_vid=Module["dynCall_vid"]=function(){return(dynCall_vid=Module["dynCall_vid"]=Module["asm"]["dynCall_vid"]).apply(null,arguments)};var dynCall_viiiiif=Module["dynCall_viiiiif"]=function(){return(dynCall_viiiiif=Module["dynCall_viiiiif"]=Module["asm"]["dynCall_viiiiif"]).apply(null,arguments)};var dynCall_viiiif=Module["dynCall_viiiif"]=function(){return(dynCall_viiiif=Module["dynCall_viiiif"]=Module["asm"]["dynCall_viiiif"]).apply(null,arguments)};var dynCall_viiiiiif=Module["dynCall_viiiiiif"]=function(){return(dynCall_viiiiiif=Module["dynCall_viiiiiif"]=Module["asm"]["dynCall_viiiiiif"]).apply(null,arguments)};var dynCall_iiif=Module["dynCall_iiif"]=function(){return(dynCall_iiif=Module["dynCall_iiif"]=Module["asm"]["dynCall_iiif"]).apply(null,arguments)};var dynCall_fif=Module["dynCall_fif"]=function(){return(dynCall_fif=Module["dynCall_fif"]=Module["asm"]["dynCall_fif"]).apply(null,arguments)};var dynCall_iiiiiifff=Module["dynCall_iiiiiifff"]=function(){return(dynCall_iiiiiifff=Module["dynCall_iiiiiifff"]=Module["asm"]["dynCall_iiiiiifff"]).apply(null,arguments)};var dynCall_iiiiiifiif=Module["dynCall_iiiiiifiif"]=function(){return(dynCall_iiiiiifiif=Module["dynCall_iiiiiifiif"]=Module["asm"]["dynCall_iiiiiifiif"]).apply(null,arguments)};var dynCall_iiiiiiifiif=Module["dynCall_iiiiiiifiif"]=function(){return(dynCall_iiiiiiifiif=Module["dynCall_iiiiiiifiif"]=Module["asm"]["dynCall_iiiiiiifiif"]).apply(null,arguments)};var dynCall_fiff=Module["dynCall_fiff"]=function(){return(dynCall_fiff=Module["dynCall_fiff"]=Module["asm"]["dynCall_fiff"]).apply(null,arguments)};var dynCall_fiiiiiifiifif=Module["dynCall_fiiiiiifiifif"]=function(){return(dynCall_fiiiiiifiifif=Module["dynCall_fiiiiiifiifif"]=Module["asm"]["dynCall_fiiiiiifiifif"]).apply(null,arguments)};var dynCall_fiiiiiifiiiif=Module["dynCall_fiiiiiifiiiif"]=function(){return(dynCall_fiiiiiifiiiif=Module["dynCall_fiiiiiifiiiif"]=Module["asm"]["dynCall_fiiiiiifiiiif"]).apply(null,arguments)};var dynCall_iifiiiijii=Module["dynCall_iifiiiijii"]=function(){return(dynCall_iifiiiijii=Module["dynCall_iifiiiijii"]=Module["asm"]["dynCall_iifiiiijii"]).apply(null,arguments)};var dynCall_vifif=Module["dynCall_vifif"]=function(){return(dynCall_vifif=Module["dynCall_vifif"]=Module["asm"]["dynCall_vifif"]).apply(null,arguments)};var dynCall_vifijii=Module["dynCall_vifijii"]=function(){return(dynCall_vifijii=Module["dynCall_vifijii"]=Module["asm"]["dynCall_vifijii"]).apply(null,arguments)};var dynCall_iiiifffiii=Module["dynCall_iiiifffiii"]=function(){return(dynCall_iiiifffiii=Module["dynCall_iiiifffiii"]=Module["asm"]["dynCall_iiiifffiii"]).apply(null,arguments)};var dynCall_iiiifffffi=Module["dynCall_iiiifffffi"]=function(){return(dynCall_iiiifffffi=Module["dynCall_iiiifffffi"]=Module["asm"]["dynCall_iiiifffffi"]).apply(null,arguments)};var dynCall_viffiiiif=Module["dynCall_viffiiiif"]=function(){return(dynCall_viffiiiif=Module["dynCall_viffiiiif"]=Module["asm"]["dynCall_viffiiiif"]).apply(null,arguments)};var dynCall_viffiifffffiii=Module["dynCall_viffiifffffiii"]=function(){return(dynCall_viffiifffffiii=Module["dynCall_viffiifffffiii"]=Module["asm"]["dynCall_viffiifffffiii"]).apply(null,arguments)};var dynCall_viffffiifffiiiiif=Module["dynCall_viffffiifffiiiiif"]=function(){return(dynCall_viffffiifffiiiiif=Module["dynCall_viffffiifffiiiiif"]=Module["asm"]["dynCall_viffffiifffiiiiif"]).apply(null,arguments)};var dynCall_iiiifffffii=Module["dynCall_iiiifffffii"]=function(){return(dynCall_iiiifffffii=Module["dynCall_iiiifffffii"]=Module["asm"]["dynCall_iiiifffffii"]).apply(null,arguments)};var dynCall_viiiiiiiiiiifii=Module["dynCall_viiiiiiiiiiifii"]=function(){return(dynCall_viiiiiiiiiiifii=Module["dynCall_viiiiiiiiiiifii"]=Module["asm"]["dynCall_viiiiiiiiiiifii"]).apply(null,arguments)};var dynCall_viff=Module["dynCall_viff"]=function(){return(dynCall_viff=Module["dynCall_viff"]=Module["asm"]["dynCall_viff"]).apply(null,arguments)};var dynCall_iiiiifiiiiif=Module["dynCall_iiiiifiiiiif"]=function(){return(dynCall_iiiiifiiiiif=Module["dynCall_iiiiifiiiiif"]=Module["asm"]["dynCall_iiiiifiiiiif"]).apply(null,arguments)};var dynCall_viiff=Module["dynCall_viiff"]=function(){return(dynCall_viiff=Module["dynCall_viiff"]=Module["asm"]["dynCall_viiff"]).apply(null,arguments)};var dynCall_viiifiiiii=Module["dynCall_viiifiiiii"]=function(){return(dynCall_viiifiiiii=Module["dynCall_viiifiiiii"]=Module["asm"]["dynCall_viiifiiiii"]).apply(null,arguments)};var dynCall_viiiifiiiiif=Module["dynCall_viiiifiiiiif"]=function(){return(dynCall_viiiifiiiiif=Module["dynCall_viiiifiiiiif"]=Module["asm"]["dynCall_viiiifiiiiif"]).apply(null,arguments)};var dynCall_iifff=Module["dynCall_iifff"]=function(){return(dynCall_iifff=Module["dynCall_iifff"]=Module["asm"]["dynCall_iifff"]).apply(null,arguments)};var dynCall_iif=Module["dynCall_iif"]=function(){return(dynCall_iif=Module["dynCall_iif"]=Module["asm"]["dynCall_iif"]).apply(null,arguments)};var dynCall_viij=Module["dynCall_viij"]=function(){return(dynCall_viij=Module["dynCall_viij"]=Module["asm"]["dynCall_viij"]).apply(null,arguments)};var dynCall_viijijj=Module["dynCall_viijijj"]=function(){return(dynCall_viijijj=Module["dynCall_viijijj"]=Module["asm"]["dynCall_viijijj"]).apply(null,arguments)};var dynCall_viijj=Module["dynCall_viijj"]=function(){return(dynCall_viijj=Module["dynCall_viijj"]=Module["asm"]["dynCall_viijj"]).apply(null,arguments)};var dynCall_viiiij=Module["dynCall_viiiij"]=function(){return(dynCall_viiiij=Module["dynCall_viiiij"]=Module["asm"]["dynCall_viiiij"]).apply(null,arguments)};var dynCall_iiijji=Module["dynCall_iiijji"]=function(){return(dynCall_iiijji=Module["dynCall_iiijji"]=Module["asm"]["dynCall_iiijji"]).apply(null,arguments)};var dynCall_ijjiiiii=Module["dynCall_ijjiiiii"]=function(){return(dynCall_ijjiiiii=Module["dynCall_ijjiiiii"]=Module["asm"]["dynCall_ijjiiiii"]).apply(null,arguments)};var dynCall_vidd=Module["dynCall_vidd"]=function(){return(dynCall_vidd=Module["dynCall_vidd"]=Module["asm"]["dynCall_vidd"]).apply(null,arguments)};var dynCall_iiiiiifffiiifiii=Module["dynCall_iiiiiifffiiifiii"]=function(){return(dynCall_iiiiiifffiiifiii=Module["dynCall_iiiiiifffiiifiii"]=Module["asm"]["dynCall_iiiiiifffiiifiii"]).apply(null,arguments)};var dynCall_viid=Module["dynCall_viid"]=function(){return(dynCall_viid=Module["dynCall_viid"]=Module["asm"]["dynCall_viid"]).apply(null,arguments)};var dynCall_viiif=Module["dynCall_viiif"]=function(){return(dynCall_viiif=Module["dynCall_viiif"]=Module["asm"]["dynCall_viiif"]).apply(null,arguments)};var dynCall_fiiiif=Module["dynCall_fiiiif"]=function(){return(dynCall_fiiiif=Module["dynCall_fiiiif"]=Module["asm"]["dynCall_fiiiif"]).apply(null,arguments)};var dynCall_ff=Module["dynCall_ff"]=function(){return(dynCall_ff=Module["dynCall_ff"]=Module["asm"]["dynCall_ff"]).apply(null,arguments)};var dynCall_iiiiiff=Module["dynCall_iiiiiff"]=function(){return(dynCall_iiiiiff=Module["dynCall_iiiiiff"]=Module["asm"]["dynCall_iiiiiff"]).apply(null,arguments)};var dynCall_iiij=Module["dynCall_iiij"]=function(){return(dynCall_iiij=Module["dynCall_iiij"]=Module["asm"]["dynCall_iiij"]).apply(null,arguments)};var dynCall_vf=Module["dynCall_vf"]=function(){return(dynCall_vf=Module["dynCall_vf"]=Module["asm"]["dynCall_vf"]).apply(null,arguments)};var dynCall_vffff=Module["dynCall_vffff"]=function(){return(dynCall_vffff=Module["dynCall_vffff"]=Module["asm"]["dynCall_vffff"]).apply(null,arguments)};var dynCall_vff=Module["dynCall_vff"]=function(){return(dynCall_vff=Module["dynCall_vff"]=Module["asm"]["dynCall_vff"]).apply(null,arguments)};var dynCall_vifff=Module["dynCall_vifff"]=function(){return(dynCall_vifff=Module["dynCall_vifff"]=Module["asm"]["dynCall_vifff"]).apply(null,arguments)};var dynCall_viifff=Module["dynCall_viifff"]=function(){return(dynCall_viifff=Module["dynCall_viifff"]=Module["asm"]["dynCall_viifff"]).apply(null,arguments)};var dynCall_vij=Module["dynCall_vij"]=function(){return(dynCall_vij=Module["dynCall_vij"]=Module["asm"]["dynCall_vij"]).apply(null,arguments)};var dynCall_ij=Module["dynCall_ij"]=function(){return(dynCall_ij=Module["dynCall_ij"]=Module["asm"]["dynCall_ij"]).apply(null,arguments)};var dynCall_iiff=Module["dynCall_iiff"]=function(){return(dynCall_iiff=Module["dynCall_iiff"]=Module["asm"]["dynCall_iiff"]).apply(null,arguments)};var dynCall_f=Module["dynCall_f"]=function(){return(dynCall_f=Module["dynCall_f"]=Module["asm"]["dynCall_f"]).apply(null,arguments)};var dynCall_vfff=Module["dynCall_vfff"]=function(){return(dynCall_vfff=Module["dynCall_vfff"]=Module["asm"]["dynCall_vfff"]).apply(null,arguments)};var dynCall_vffffffi=Module["dynCall_vffffffi"]=function(){return(dynCall_vffffffi=Module["dynCall_vffffffi"]=Module["asm"]["dynCall_vffffffi"]).apply(null,arguments)};var dynCall_if=Module["dynCall_if"]=function(){return(dynCall_if=Module["dynCall_if"]=Module["asm"]["dynCall_if"]).apply(null,arguments)};var dynCall_iiiiiiifiii=Module["dynCall_iiiiiiifiii"]=function(){return(dynCall_iiiiiiifiii=Module["dynCall_iiiiiiifiii"]=Module["asm"]["dynCall_iiiiiiifiii"]).apply(null,arguments)};var dynCall_iiifiifii=Module["dynCall_iiifiifii"]=function(){return(dynCall_iiifiifii=Module["dynCall_iiifiifii"]=Module["asm"]["dynCall_iiifiifii"]).apply(null,arguments)};var dynCall_iiiiiiffiiiiiiiiiffffiii=Module["dynCall_iiiiiiffiiiiiiiiiffffiii"]=function(){return(dynCall_iiiiiiffiiiiiiiiiffffiii=Module["dynCall_iiiiiiffiiiiiiiiiffffiii"]=Module["asm"]["dynCall_iiiiiiffiiiiiiiiiffffiii"]).apply(null,arguments)};var dynCall_viififi=Module["dynCall_viififi"]=function(){return(dynCall_viififi=Module["dynCall_viififi"]=Module["asm"]["dynCall_viififi"]).apply(null,arguments)};var dynCall_viiffiiiiiiiii=Module["dynCall_viiffiiiiiiiii"]=function(){return(dynCall_viiffiiiiiiiii=Module["dynCall_viiffiiiiiiiii"]=Module["asm"]["dynCall_viiffiiiiiiiii"]).apply(null,arguments)};var dynCall_viiffiiiiii=Module["dynCall_viiffiiiiii"]=function(){return(dynCall_viiffiiiiii=Module["dynCall_viiffiiiiii"]=Module["asm"]["dynCall_viiffiiiiii"]).apply(null,arguments)};var dynCall_viiiiiiiijiii=Module["dynCall_viiiiiiiijiii"]=function(){return(dynCall_viiiiiiiijiii=Module["dynCall_viiiiiiiijiii"]=Module["asm"]["dynCall_viiiiiiiijiii"]).apply(null,arguments)};function invoke_ii(index,a1){var sp=stackSave();try{return dynCall_ii(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_v(index){var sp=stackSave();try{dynCall_v(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vii(index,a1,a2){var sp=stackSave();try{dynCall_vii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iii(index,a1,a2){var sp=stackSave();try{return dynCall_iii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vi(index,a1){var sp=stackSave();try{dynCall_vi(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viii(index,a1,a2,a3){var sp=stackSave();try{dynCall_viii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_i(index){var sp=stackSave();try{return dynCall_i(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiii(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiiii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiiiiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{return dynCall_iiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_fiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_diii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiiiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return dynCall_iiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{dynCall_viiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiiii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiifii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiifii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viifi(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viifi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiidii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiidii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiifii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiifii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vifi(index,a1,a2,a3){var sp=stackSave();try{dynCall_vifi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fii(index,a1,a2){var sp=stackSave();try{return dynCall_fii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ddiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_ddiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidi(index,a1,a2,a3){var sp=stackSave();try{dynCall_vidi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viidi(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viidi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_dii(index,a1,a2){var sp=stackSave();try{return dynCall_dii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ifi(index,a1,a2){var sp=stackSave();try{return dynCall_ifi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_idi(index,a1,a2){var sp=stackSave();try{return dynCall_idi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return dynCall_iiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{dynCall_viiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiifiifiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14){var sp=stackSave();try{dynCall_viiiiiifiifiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viffi(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viffi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vifii(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_vifii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viifffffi(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viifffffi(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fifi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_fifi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_fiiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiifffiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{dynCall_viiiiifffiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fffi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_fffi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13){var sp=stackSave();try{dynCall_viiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiifiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{return dynCall_iiiiifiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return dynCall_iiiiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiifi(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiiiifi(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_dddi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_dddi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiifi(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiifi(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ffi(index,a1,a2){var sp=stackSave();try{return dynCall_ffi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiifiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return dynCall_iiiiiiiifiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiiiiiifii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viifiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{dynCall_viifiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_fiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fi(index,a1){var sp=stackSave();try{return dynCall_fi(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iifii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iifii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vfi(index,a1,a2){var sp=stackSave();try{dynCall_vfi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiffi(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viiiiiffi(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiifii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiifii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viffffi(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viffffi(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12){var sp=stackSave();try{dynCall_viiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viifii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viifii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vifffi(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_vifffi(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diidi(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_diidi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiifi(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_fiifi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ddi(index,a1,a2){var sp=stackSave();try{return dynCall_ddi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iidi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iidi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iifi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iifi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_diiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_diiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14){var sp=stackSave();try{dynCall_viiiiiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viidii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viidii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiidi(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiidi(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiffi(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiffi(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiifi(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiifi(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiifi(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiifi(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiifii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiiifii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viddii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viddii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiifddfiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14){var sp=stackSave();try{dynCall_viiiiiifddfiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiiffffiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14){var sp=stackSave();try{dynCall_viiiiiiffffiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiifi(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiifi(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiifi(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiifi(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_didi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_didi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iidiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iidiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vidd(index,a1,a2,a3){var sp=stackSave();try{dynCall_vidd(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iij(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iij(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiijiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiijiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiiii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ji(index,a1){var sp=stackSave();try{return dynCall_ji(index,a1)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jii(index,a1,a2){var sp=stackSave();try{return dynCall_jii(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viijii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiij(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiij(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_j(index){var sp=stackSave();try{return dynCall_j(index)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiii(index,a1,a2,a3){var sp=stackSave();try{return dynCall_jiii(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iijiii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiijii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiijii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiji(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_viiji(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiijii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiiijii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viji(index,a1,a2,a3,a4){var sp=stackSave();try{dynCall_viji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{return dynCall_jiiiiiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiji(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iiiji(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iji(index,a1,a2,a3){var sp=stackSave();try{return dynCall_iji(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiji(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_iiji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_iijii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiijjii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiiijjii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijjiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return dynCall_iijjiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iijiiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ijji(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_ijji(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jdi(index,a1,a2){var sp=stackSave();try{return dynCall_jdi(index,a1,a2)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return dynCall_iiiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jidi(index,a1,a2,a3){var sp=stackSave();try{return dynCall_jidi(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_viiiji(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiji(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jiiji(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiijii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{return dynCall_iiiiijii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jjji(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jjji(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jjii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jjii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_vijiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jji(index,a1,a2,a3){var sp=stackSave();try{return dynCall_jji(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_ijii(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_ijii(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_fiji(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_fiji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiji(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iiiiiji(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iijji(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiijjji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiijjji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_vijiiiii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iijiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{return dynCall_iijiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_vijji(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{dynCall_vijii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiijjiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{return dynCall_iiiijjiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijiii(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{dynCall_vijiii(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vijjji(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_vijjji(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9){var sp=stackSave();try{return dynCall_iiiiijiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiiiiiiji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11){var sp=stackSave();try{return dynCall_iiiiiiiiiji(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vji(index,a1,a2,a3){var sp=stackSave();try{dynCall_vji(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_iiiiji(index,a1,a2,a3,a4,a5,a6){var sp=stackSave();try{return dynCall_iiiiji(index,a1,a2,a3,a4,a5,a6)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiji(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viiiiji(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jijii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jijii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijiiijiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13){var sp=stackSave();try{dynCall_viijiiijiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiiiifjjfiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16){var sp=stackSave();try{dynCall_viiiiiifjjfiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10,a11,a12,a13,a14,a15,a16)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiji(index,a1,a2,a3,a4){var sp=stackSave();try{return dynCall_jiji(index,a1,a2,a3,a4)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_dji(index,a1,a2,a3){var sp=stackSave();try{return dynCall_dji(index,a1,a2,a3)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viiiijii(index,a1,a2,a3,a4,a5,a6,a7,a8){var sp=stackSave();try{dynCall_viiiijii(index,a1,a2,a3,a4,a5,a6,a7,a8)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_viijji(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_viijji(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vjjjiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10){var sp=stackSave();try{dynCall_vjjjiiii(index,a1,a2,a3,a4,a5,a6,a7,a8,a9,a10)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_vjiiiii(index,a1,a2,a3,a4,a5,a6,a7){var sp=stackSave();try{dynCall_vjiiiii(index,a1,a2,a3,a4,a5,a6,a7)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}function invoke_jiiiii(index,a1,a2,a3,a4,a5){var sp=stackSave();try{return dynCall_jiiiii(index,a1,a2,a3,a4,a5)}catch(e){stackRestore(sp);if(e!==e+0)throw e;_setThrew(1,0)}}Module["ccall"]=ccall;Module["cwrap"]=cwrap;Module["stackTrace"]=stackTrace;Module["addRunDependency"]=addRunDependency;Module["removeRunDependency"]=removeRunDependency;Module["FS_createPath"]=FS.createPath;Module["FS_createDataFile"]=FS.createDataFile;Module["stackTrace"]=stackTrace;var calledRun;function ExitStatus(status){this.name="ExitStatus";this.message="Program terminated with exit("+status+")";this.status=status}var calledMain=false;dependenciesFulfilled=function runCaller(){if(!calledRun)run();if(!calledRun)dependenciesFulfilled=runCaller};function callMain(args){var entryFunction=Module["_main"];args=args||[];var argc=args.length+1;var argv=stackAlloc((argc+1)*4);HEAP32[argv>>2]=allocateUTF8OnStack(thisProgram);for(var i=1;i<argc;i++){HEAP32[(argv>>2)+i]=allocateUTF8OnStack(args[i-1])}HEAP32[(argv>>2)+argc]=0;try{var ret=entryFunction(argc,argv);exit(ret,true);return ret}catch(e){return handleException(e)}finally{calledMain=true}}function run(args){args=args||arguments_;if(runDependencies>0){return}preRun();if(runDependencies>0){return}function doRun(){if(calledRun)return;calledRun=true;Module["calledRun"]=true;if(ABORT)return;initRuntime();preMain();readyPromiseResolve(Module);if(Module["onRuntimeInitialized"])Module["onRuntimeInitialized"]();if(shouldRunNow)callMain(args);postRun()}if(Module["setStatus"]){Module["setStatus"]("Running...");setTimeout(function(){setTimeout(function(){Module["setStatus"]("")},1);doRun()},1)}else{doRun()}}Module["run"]=run;function exit(status,implicit){EXITSTATUS=status;procExit(status)}function procExit(code){EXITSTATUS=code;if(!keepRuntimeAlive()){if(Module["onExit"])Module["onExit"](code);ABORT=true}quit_(code,new ExitStatus(code))}if(Module["preInit"]){if(typeof Module["preInit"]=="function")Module["preInit"]=[Module["preInit"]];while(Module["preInit"].length>0){Module["preInit"].pop()()}}var shouldRunNow=true;if(Module["noInitialRun"])shouldRunNow=false;run();


  return unityFramework.ready
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
  module.exports = unityFramework;
else if (typeof define === 'function' && define['amd'])
  define([], function() { return unityFramework; });
else if (typeof exports === 'object')
  exports["unityFramework"] = unityFramework;
